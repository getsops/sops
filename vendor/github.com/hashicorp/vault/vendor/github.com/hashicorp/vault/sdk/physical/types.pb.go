// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sdk/physical/types.proto

package physical

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type EncryptedBlobInfo struct {
	Ciphertext []byte       `protobuf:"bytes,1,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	IV         []byte       `protobuf:"bytes,2,opt,name=iv,proto3" json:"iv,omitempty"`
	HMAC       []byte       `protobuf:"bytes,3,opt,name=hmac,proto3" json:"hmac,omitempty"`
	Wrapped    bool         `protobuf:"varint,4,opt,name=wrapped,proto3" json:"wrapped,omitempty"`
	KeyInfo    *SealKeyInfo `protobuf:"bytes,5,opt,name=key_info,json=keyInfo,proto3" json:"key_info,omitempty"`
	// Key is the Key value for the entry that corresponds to
	// physical.Entry.Key's value
	Key                  string   `protobuf:"bytes,6,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptedBlobInfo) Reset()         { *m = EncryptedBlobInfo{} }
func (m *EncryptedBlobInfo) String() string { return proto.CompactTextString(m) }
func (*EncryptedBlobInfo) ProtoMessage()    {}
func (*EncryptedBlobInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21dce1f497d1541e, []int{0}
}

func (m *EncryptedBlobInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptedBlobInfo.Unmarshal(m, b)
}
func (m *EncryptedBlobInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptedBlobInfo.Marshal(b, m, deterministic)
}
func (m *EncryptedBlobInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedBlobInfo.Merge(m, src)
}
func (m *EncryptedBlobInfo) XXX_Size() int {
	return xxx_messageInfo_EncryptedBlobInfo.Size(m)
}
func (m *EncryptedBlobInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedBlobInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedBlobInfo proto.InternalMessageInfo

func (m *EncryptedBlobInfo) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedBlobInfo) GetIV() []byte {
	if m != nil {
		return m.IV
	}
	return nil
}

func (m *EncryptedBlobInfo) GetHMAC() []byte {
	if m != nil {
		return m.HMAC
	}
	return nil
}

func (m *EncryptedBlobInfo) GetWrapped() bool {
	if m != nil {
		return m.Wrapped
	}
	return false
}

func (m *EncryptedBlobInfo) GetKeyInfo() *SealKeyInfo {
	if m != nil {
		return m.KeyInfo
	}
	return nil
}

func (m *EncryptedBlobInfo) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// SealKeyInfo contains information regarding the seal used to encrypt the entry.
type SealKeyInfo struct {
	// Mechanism is the method used by the seal to encrypt and sign the
	// data as defined by the seal.
	Mechanism     uint64 `protobuf:"varint,1,opt,name=Mechanism,proto3" json:"Mechanism,omitempty"`
	HMACMechanism uint64 `protobuf:"varint,2,opt,name=HMACMechanism,proto3" json:"HMACMechanism,omitempty"`
	// This is an opaque ID used by the seal to identify the specific
	// key to use as defined by the seal.  This could be a version, key
	// label, or something else.
	KeyID     string `protobuf:"bytes,3,opt,name=KeyID,proto3" json:"KeyID,omitempty"`
	HMACKeyID string `protobuf:"bytes,4,opt,name=HMACKeyID,proto3" json:"HMACKeyID,omitempty"`
	// These value are used when generating our own data encryption keys
	// and encrypting them using the autoseal
	WrappedKey []byte `protobuf:"bytes,5,opt,name=WrappedKey,proto3" json:"WrappedKey,omitempty"`
	// Mechanism specific flags
	Flags                uint64   `protobuf:"varint,6,opt,name=Flags,proto3" json:"Flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SealKeyInfo) Reset()         { *m = SealKeyInfo{} }
func (m *SealKeyInfo) String() string { return proto.CompactTextString(m) }
func (*SealKeyInfo) ProtoMessage()    {}
func (*SealKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21dce1f497d1541e, []int{1}
}

func (m *SealKeyInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SealKeyInfo.Unmarshal(m, b)
}
func (m *SealKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SealKeyInfo.Marshal(b, m, deterministic)
}
func (m *SealKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealKeyInfo.Merge(m, src)
}
func (m *SealKeyInfo) XXX_Size() int {
	return xxx_messageInfo_SealKeyInfo.Size(m)
}
func (m *SealKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SealKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SealKeyInfo proto.InternalMessageInfo

func (m *SealKeyInfo) GetMechanism() uint64 {
	if m != nil {
		return m.Mechanism
	}
	return 0
}

func (m *SealKeyInfo) GetHMACMechanism() uint64 {
	if m != nil {
		return m.HMACMechanism
	}
	return 0
}

func (m *SealKeyInfo) GetKeyID() string {
	if m != nil {
		return m.KeyID
	}
	return ""
}

func (m *SealKeyInfo) GetHMACKeyID() string {
	if m != nil {
		return m.HMACKeyID
	}
	return ""
}

func (m *SealKeyInfo) GetWrappedKey() []byte {
	if m != nil {
		return m.WrappedKey
	}
	return nil
}

func (m *SealKeyInfo) GetFlags() uint64 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func init() {
	proto.RegisterType((*EncryptedBlobInfo)(nil), "physical.EncryptedBlobInfo")
	proto.RegisterType((*SealKeyInfo)(nil), "physical.SealKeyInfo")
}

func init() { proto.RegisterFile("sdk/physical/types.proto", fileDescriptor_21dce1f497d1541e) }

var fileDescriptor_21dce1f497d1541e = []byte{
	// 316 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x91, 0x5d, 0x4b, 0xfb, 0x30,
	0x14, 0xc6, 0x69, 0xd7, 0xbd, 0x9d, 0xed, 0xff, 0x47, 0x83, 0x42, 0x2e, 0x44, 0xca, 0x10, 0xac,
	0x37, 0xad, 0xe8, 0x27, 0x70, 0xbe, 0xa0, 0x8c, 0xdd, 0xc4, 0x0b, 0xc1, 0x1b, 0xc9, 0xb2, 0x6c,
	0x09, 0xed, 0x9a, 0xd0, 0x66, 0xd3, 0x7c, 0x30, 0xaf, 0xfc, 0x72, 0x92, 0x94, 0xb1, 0x7a, 0x77,
	0xce, 0x2f, 0x0f, 0x0f, 0xcf, 0x93, 0x03, 0xb8, 0x5e, 0xe6, 0x99, 0x16, 0xb6, 0x96, 0x8c, 0x16,
	0x99, 0xb1, 0x9a, 0xd7, 0xa9, 0xae, 0x94, 0x51, 0x68, 0xb0, 0xa7, 0x93, 0xef, 0x00, 0x8e, 0x1f,
	0x4b, 0x56, 0x59, 0x6d, 0xf8, 0x72, 0x5a, 0xa8, 0xc5, 0x4b, 0xb9, 0x52, 0xe8, 0x1c, 0x80, 0x49,
	0x2d, 0x78, 0x65, 0xf8, 0x97, 0xc1, 0x41, 0x1c, 0x24, 0x63, 0xd2, 0x22, 0xe8, 0x3f, 0x84, 0x72,
	0x87, 0x43, 0xcf, 0x43, 0xb9, 0x43, 0x08, 0x22, 0xb1, 0xa1, 0x0c, 0x77, 0x3c, 0xf1, 0x33, 0xc2,
	0xd0, 0xff, 0xac, 0xa8, 0xd6, 0x7c, 0x89, 0xa3, 0x38, 0x48, 0x06, 0x64, 0xbf, 0xa2, 0x6b, 0x18,
	0xe4, 0xdc, 0x7e, 0xc8, 0x72, 0xa5, 0x70, 0x37, 0x0e, 0x92, 0xd1, 0xcd, 0x69, 0xba, 0x0f, 0x94,
	0xbe, 0x72, 0x5a, 0xcc, 0xb8, 0x75, 0x31, 0x48, 0x3f, 0x6f, 0x06, 0x74, 0x04, 0x9d, 0x9c, 0x5b,
	0xdc, 0x8b, 0x83, 0x64, 0x48, 0xdc, 0x38, 0xf9, 0x09, 0x60, 0xd4, 0x92, 0xa2, 0x33, 0x18, 0xce,
	0x39, 0x13, 0xb4, 0x94, 0xf5, 0xc6, 0x07, 0x8e, 0xc8, 0x01, 0xa0, 0x0b, 0xf8, 0xf7, 0x3c, 0xbf,
	0xbb, 0x3f, 0x28, 0x42, 0xaf, 0xf8, 0x0b, 0xd1, 0x09, 0x74, 0x9d, 0xdd, 0x83, 0xaf, 0x31, 0x24,
	0xcd, 0xe2, 0x9c, 0x9d, 0xac, 0x79, 0x89, 0xfc, 0xcb, 0x01, 0xb8, 0x9f, 0x7a, 0x6b, 0x6a, 0xcd,
	0xb8, 0xf5, 0x6d, 0xc6, 0xa4, 0x45, 0x9c, 0xe7, 0x53, 0x41, 0xd7, 0xb5, 0xcf, 0x1e, 0x91, 0x66,
	0x99, 0x5e, 0xbd, 0x5f, 0xae, 0xa5, 0x11, 0xdb, 0x45, 0xca, 0xd4, 0x26, 0x13, 0xb4, 0x16, 0x92,
	0xa9, 0x4a, 0x67, 0x3b, 0xba, 0x2d, 0x4c, 0xd6, 0x3e, 0xdb, 0xa2, 0xe7, 0x2f, 0x76, 0xfb, 0x1b,
	0x00, 0x00, 0xff, 0xff, 0xc6, 0x34, 0xf8, 0x45, 0xcd, 0x01, 0x00, 0x00,
}
