// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package budgets

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/request"
)

const opCreateBudget = "CreateBudget"

// CreateBudgetRequest generates a "aws/request.Request" representing the
// client's request for the CreateBudget operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateBudget for more information on using the CreateBudget
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateBudgetRequest method.
//    req, resp := client.CreateBudgetRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) CreateBudgetRequest(input *CreateBudgetInput) (req *request.Request, output *CreateBudgetOutput) {
	op := &request.Operation{
		Name:       opCreateBudget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBudgetInput{}
	}

	output = &CreateBudgetOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateBudget API operation for AWS Budgets.
//
// Create a new budget
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation CreateBudget for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeCreationLimitExceededException "CreationLimitExceededException"
//   The exception is thrown when customer tries to create a record (e.g. budget),
//   but the number this record already exceeds the limitation.
//
//   * ErrCodeDuplicateRecordException "DuplicateRecordException"
//   The exception is thrown when customer tries to create a record (e.g. budget)
//   that already exists.
//
func (c *Budgets) CreateBudget(input *CreateBudgetInput) (*CreateBudgetOutput, error) {
	req, out := c.CreateBudgetRequest(input)
	return out, req.Send()
}

// CreateBudgetWithContext is the same as CreateBudget with the addition of
// the ability to pass a context and additional request options.
//
// See CreateBudget for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) CreateBudgetWithContext(ctx aws.Context, input *CreateBudgetInput, opts ...request.Option) (*CreateBudgetOutput, error) {
	req, out := c.CreateBudgetRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateNotification = "CreateNotification"

// CreateNotificationRequest generates a "aws/request.Request" representing the
// client's request for the CreateNotification operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateNotification for more information on using the CreateNotification
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateNotificationRequest method.
//    req, resp := client.CreateNotificationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) CreateNotificationRequest(input *CreateNotificationInput) (req *request.Request, output *CreateNotificationOutput) {
	op := &request.Operation{
		Name:       opCreateNotification,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateNotificationInput{}
	}

	output = &CreateNotificationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateNotification API operation for AWS Budgets.
//
// Create a new Notification with subscribers for a budget
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation CreateNotification for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
//   * ErrCodeCreationLimitExceededException "CreationLimitExceededException"
//   The exception is thrown when customer tries to create a record (e.g. budget),
//   but the number this record already exceeds the limitation.
//
//   * ErrCodeDuplicateRecordException "DuplicateRecordException"
//   The exception is thrown when customer tries to create a record (e.g. budget)
//   that already exists.
//
func (c *Budgets) CreateNotification(input *CreateNotificationInput) (*CreateNotificationOutput, error) {
	req, out := c.CreateNotificationRequest(input)
	return out, req.Send()
}

// CreateNotificationWithContext is the same as CreateNotification with the addition of
// the ability to pass a context and additional request options.
//
// See CreateNotification for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) CreateNotificationWithContext(ctx aws.Context, input *CreateNotificationInput, opts ...request.Option) (*CreateNotificationOutput, error) {
	req, out := c.CreateNotificationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateSubscriber = "CreateSubscriber"

// CreateSubscriberRequest generates a "aws/request.Request" representing the
// client's request for the CreateSubscriber operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateSubscriber for more information on using the CreateSubscriber
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateSubscriberRequest method.
//    req, resp := client.CreateSubscriberRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) CreateSubscriberRequest(input *CreateSubscriberInput) (req *request.Request, output *CreateSubscriberOutput) {
	op := &request.Operation{
		Name:       opCreateSubscriber,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateSubscriberInput{}
	}

	output = &CreateSubscriberOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateSubscriber API operation for AWS Budgets.
//
// Create a new Subscriber for a notification
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation CreateSubscriber for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeCreationLimitExceededException "CreationLimitExceededException"
//   The exception is thrown when customer tries to create a record (e.g. budget),
//   but the number this record already exceeds the limitation.
//
//   * ErrCodeDuplicateRecordException "DuplicateRecordException"
//   The exception is thrown when customer tries to create a record (e.g. budget)
//   that already exists.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
func (c *Budgets) CreateSubscriber(input *CreateSubscriberInput) (*CreateSubscriberOutput, error) {
	req, out := c.CreateSubscriberRequest(input)
	return out, req.Send()
}

// CreateSubscriberWithContext is the same as CreateSubscriber with the addition of
// the ability to pass a context and additional request options.
//
// See CreateSubscriber for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) CreateSubscriberWithContext(ctx aws.Context, input *CreateSubscriberInput, opts ...request.Option) (*CreateSubscriberOutput, error) {
	req, out := c.CreateSubscriberRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteBudget = "DeleteBudget"

// DeleteBudgetRequest generates a "aws/request.Request" representing the
// client's request for the DeleteBudget operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteBudget for more information on using the DeleteBudget
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteBudgetRequest method.
//    req, resp := client.DeleteBudgetRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DeleteBudgetRequest(input *DeleteBudgetInput) (req *request.Request, output *DeleteBudgetOutput) {
	op := &request.Operation{
		Name:       opDeleteBudget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBudgetInput{}
	}

	output = &DeleteBudgetOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteBudget API operation for AWS Budgets.
//
// Delete a budget and related notifications
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DeleteBudget for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
func (c *Budgets) DeleteBudget(input *DeleteBudgetInput) (*DeleteBudgetOutput, error) {
	req, out := c.DeleteBudgetRequest(input)
	return out, req.Send()
}

// DeleteBudgetWithContext is the same as DeleteBudget with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteBudget for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DeleteBudgetWithContext(ctx aws.Context, input *DeleteBudgetInput, opts ...request.Option) (*DeleteBudgetOutput, error) {
	req, out := c.DeleteBudgetRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteNotification = "DeleteNotification"

// DeleteNotificationRequest generates a "aws/request.Request" representing the
// client's request for the DeleteNotification operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteNotification for more information on using the DeleteNotification
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteNotificationRequest method.
//    req, resp := client.DeleteNotificationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DeleteNotificationRequest(input *DeleteNotificationInput) (req *request.Request, output *DeleteNotificationOutput) {
	op := &request.Operation{
		Name:       opDeleteNotification,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteNotificationInput{}
	}

	output = &DeleteNotificationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteNotification API operation for AWS Budgets.
//
// Delete a notification and related subscribers
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DeleteNotification for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
func (c *Budgets) DeleteNotification(input *DeleteNotificationInput) (*DeleteNotificationOutput, error) {
	req, out := c.DeleteNotificationRequest(input)
	return out, req.Send()
}

// DeleteNotificationWithContext is the same as DeleteNotification with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteNotification for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DeleteNotificationWithContext(ctx aws.Context, input *DeleteNotificationInput, opts ...request.Option) (*DeleteNotificationOutput, error) {
	req, out := c.DeleteNotificationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteSubscriber = "DeleteSubscriber"

// DeleteSubscriberRequest generates a "aws/request.Request" representing the
// client's request for the DeleteSubscriber operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteSubscriber for more information on using the DeleteSubscriber
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteSubscriberRequest method.
//    req, resp := client.DeleteSubscriberRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DeleteSubscriberRequest(input *DeleteSubscriberInput) (req *request.Request, output *DeleteSubscriberOutput) {
	op := &request.Operation{
		Name:       opDeleteSubscriber,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteSubscriberInput{}
	}

	output = &DeleteSubscriberOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteSubscriber API operation for AWS Budgets.
//
// Delete a Subscriber for a notification
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DeleteSubscriber for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
func (c *Budgets) DeleteSubscriber(input *DeleteSubscriberInput) (*DeleteSubscriberOutput, error) {
	req, out := c.DeleteSubscriberRequest(input)
	return out, req.Send()
}

// DeleteSubscriberWithContext is the same as DeleteSubscriber with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteSubscriber for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DeleteSubscriberWithContext(ctx aws.Context, input *DeleteSubscriberInput, opts ...request.Option) (*DeleteSubscriberOutput, error) {
	req, out := c.DeleteSubscriberRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeBudget = "DescribeBudget"

// DescribeBudgetRequest generates a "aws/request.Request" representing the
// client's request for the DescribeBudget operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeBudget for more information on using the DescribeBudget
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeBudgetRequest method.
//    req, resp := client.DescribeBudgetRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DescribeBudgetRequest(input *DescribeBudgetInput) (req *request.Request, output *DescribeBudgetOutput) {
	op := &request.Operation{
		Name:       opDescribeBudget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeBudgetInput{}
	}

	output = &DescribeBudgetOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeBudget API operation for AWS Budgets.
//
// Get a single budget
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DescribeBudget for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
func (c *Budgets) DescribeBudget(input *DescribeBudgetInput) (*DescribeBudgetOutput, error) {
	req, out := c.DescribeBudgetRequest(input)
	return out, req.Send()
}

// DescribeBudgetWithContext is the same as DescribeBudget with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeBudget for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DescribeBudgetWithContext(ctx aws.Context, input *DescribeBudgetInput, opts ...request.Option) (*DescribeBudgetOutput, error) {
	req, out := c.DescribeBudgetRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeBudgets = "DescribeBudgets"

// DescribeBudgetsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeBudgets operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeBudgets for more information on using the DescribeBudgets
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeBudgetsRequest method.
//    req, resp := client.DescribeBudgetsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DescribeBudgetsRequest(input *DescribeBudgetsInput) (req *request.Request, output *DescribeBudgetsOutput) {
	op := &request.Operation{
		Name:       opDescribeBudgets,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeBudgetsInput{}
	}

	output = &DescribeBudgetsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeBudgets API operation for AWS Budgets.
//
// Get all budgets for an account
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DescribeBudgets for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   This exception is thrown if paging token signature didn't match the token,
//   or the paging token isn't for this request
//
//   * ErrCodeExpiredNextTokenException "ExpiredNextTokenException"
//   This exception is thrown if the paging token is expired - past its TTL
//
func (c *Budgets) DescribeBudgets(input *DescribeBudgetsInput) (*DescribeBudgetsOutput, error) {
	req, out := c.DescribeBudgetsRequest(input)
	return out, req.Send()
}

// DescribeBudgetsWithContext is the same as DescribeBudgets with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeBudgets for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DescribeBudgetsWithContext(ctx aws.Context, input *DescribeBudgetsInput, opts ...request.Option) (*DescribeBudgetsOutput, error) {
	req, out := c.DescribeBudgetsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeNotificationsForBudget = "DescribeNotificationsForBudget"

// DescribeNotificationsForBudgetRequest generates a "aws/request.Request" representing the
// client's request for the DescribeNotificationsForBudget operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeNotificationsForBudget for more information on using the DescribeNotificationsForBudget
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeNotificationsForBudgetRequest method.
//    req, resp := client.DescribeNotificationsForBudgetRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DescribeNotificationsForBudgetRequest(input *DescribeNotificationsForBudgetInput) (req *request.Request, output *DescribeNotificationsForBudgetOutput) {
	op := &request.Operation{
		Name:       opDescribeNotificationsForBudget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeNotificationsForBudgetInput{}
	}

	output = &DescribeNotificationsForBudgetOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeNotificationsForBudget API operation for AWS Budgets.
//
// Get notifications of a budget
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DescribeNotificationsForBudget for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   This exception is thrown if paging token signature didn't match the token,
//   or the paging token isn't for this request
//
//   * ErrCodeExpiredNextTokenException "ExpiredNextTokenException"
//   This exception is thrown if the paging token is expired - past its TTL
//
func (c *Budgets) DescribeNotificationsForBudget(input *DescribeNotificationsForBudgetInput) (*DescribeNotificationsForBudgetOutput, error) {
	req, out := c.DescribeNotificationsForBudgetRequest(input)
	return out, req.Send()
}

// DescribeNotificationsForBudgetWithContext is the same as DescribeNotificationsForBudget with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeNotificationsForBudget for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DescribeNotificationsForBudgetWithContext(ctx aws.Context, input *DescribeNotificationsForBudgetInput, opts ...request.Option) (*DescribeNotificationsForBudgetOutput, error) {
	req, out := c.DescribeNotificationsForBudgetRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeSubscribersForNotification = "DescribeSubscribersForNotification"

// DescribeSubscribersForNotificationRequest generates a "aws/request.Request" representing the
// client's request for the DescribeSubscribersForNotification operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeSubscribersForNotification for more information on using the DescribeSubscribersForNotification
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeSubscribersForNotificationRequest method.
//    req, resp := client.DescribeSubscribersForNotificationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) DescribeSubscribersForNotificationRequest(input *DescribeSubscribersForNotificationInput) (req *request.Request, output *DescribeSubscribersForNotificationOutput) {
	op := &request.Operation{
		Name:       opDescribeSubscribersForNotification,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DescribeSubscribersForNotificationInput{}
	}

	output = &DescribeSubscribersForNotificationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeSubscribersForNotification API operation for AWS Budgets.
//
// Get subscribers of a notification
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation DescribeSubscribersForNotification for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeInvalidNextTokenException "InvalidNextTokenException"
//   This exception is thrown if paging token signature didn't match the token,
//   or the paging token isn't for this request
//
//   * ErrCodeExpiredNextTokenException "ExpiredNextTokenException"
//   This exception is thrown if the paging token is expired - past its TTL
//
func (c *Budgets) DescribeSubscribersForNotification(input *DescribeSubscribersForNotificationInput) (*DescribeSubscribersForNotificationOutput, error) {
	req, out := c.DescribeSubscribersForNotificationRequest(input)
	return out, req.Send()
}

// DescribeSubscribersForNotificationWithContext is the same as DescribeSubscribersForNotification with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeSubscribersForNotification for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) DescribeSubscribersForNotificationWithContext(ctx aws.Context, input *DescribeSubscribersForNotificationInput, opts ...request.Option) (*DescribeSubscribersForNotificationOutput, error) {
	req, out := c.DescribeSubscribersForNotificationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateBudget = "UpdateBudget"

// UpdateBudgetRequest generates a "aws/request.Request" representing the
// client's request for the UpdateBudget operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateBudget for more information on using the UpdateBudget
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateBudgetRequest method.
//    req, resp := client.UpdateBudgetRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) UpdateBudgetRequest(input *UpdateBudgetInput) (req *request.Request, output *UpdateBudgetOutput) {
	op := &request.Operation{
		Name:       opUpdateBudget,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateBudgetInput{}
	}

	output = &UpdateBudgetOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateBudget API operation for AWS Budgets.
//
// Update the information of a budget already created
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation UpdateBudget for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
func (c *Budgets) UpdateBudget(input *UpdateBudgetInput) (*UpdateBudgetOutput, error) {
	req, out := c.UpdateBudgetRequest(input)
	return out, req.Send()
}

// UpdateBudgetWithContext is the same as UpdateBudget with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateBudget for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) UpdateBudgetWithContext(ctx aws.Context, input *UpdateBudgetInput, opts ...request.Option) (*UpdateBudgetOutput, error) {
	req, out := c.UpdateBudgetRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateNotification = "UpdateNotification"

// UpdateNotificationRequest generates a "aws/request.Request" representing the
// client's request for the UpdateNotification operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateNotification for more information on using the UpdateNotification
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateNotificationRequest method.
//    req, resp := client.UpdateNotificationRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) UpdateNotificationRequest(input *UpdateNotificationInput) (req *request.Request, output *UpdateNotificationOutput) {
	op := &request.Operation{
		Name:       opUpdateNotification,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateNotificationInput{}
	}

	output = &UpdateNotificationOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateNotification API operation for AWS Budgets.
//
// Update the information about a notification already created
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation UpdateNotification for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
//   * ErrCodeDuplicateRecordException "DuplicateRecordException"
//   The exception is thrown when customer tries to create a record (e.g. budget)
//   that already exists.
//
func (c *Budgets) UpdateNotification(input *UpdateNotificationInput) (*UpdateNotificationOutput, error) {
	req, out := c.UpdateNotificationRequest(input)
	return out, req.Send()
}

// UpdateNotificationWithContext is the same as UpdateNotification with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateNotification for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) UpdateNotificationWithContext(ctx aws.Context, input *UpdateNotificationInput, opts ...request.Option) (*UpdateNotificationOutput, error) {
	req, out := c.UpdateNotificationRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateSubscriber = "UpdateSubscriber"

// UpdateSubscriberRequest generates a "aws/request.Request" representing the
// client's request for the UpdateSubscriber operation. The "output" return
// value will be populated with the request's response once the request complets
// successfuly.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateSubscriber for more information on using the UpdateSubscriber
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateSubscriberRequest method.
//    req, resp := client.UpdateSubscriberRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
func (c *Budgets) UpdateSubscriberRequest(input *UpdateSubscriberInput) (req *request.Request, output *UpdateSubscriberOutput) {
	op := &request.Operation{
		Name:       opUpdateSubscriber,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateSubscriberInput{}
	}

	output = &UpdateSubscriberOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateSubscriber API operation for AWS Budgets.
//
// Update a subscriber
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS Budgets's
// API operation UpdateSubscriber for usage and error information.
//
// Returned Error Codes:
//   * ErrCodeInternalErrorException "InternalErrorException"
//   This exception is thrown on an unknown internal failure.
//
//   * ErrCodeInvalidParameterException "InvalidParameterException"
//   This exception is thrown if any request is given an invalid parameter. E.g.,
//   if a required Date field is null.
//
//   * ErrCodeNotFoundException "NotFoundException"
//   This exception is thrown if a requested entity is not found. E.g., if a budget
//   id doesn't exist for an account ID.
//
//   * ErrCodeDuplicateRecordException "DuplicateRecordException"
//   The exception is thrown when customer tries to create a record (e.g. budget)
//   that already exists.
//
func (c *Budgets) UpdateSubscriber(input *UpdateSubscriberInput) (*UpdateSubscriberOutput, error) {
	req, out := c.UpdateSubscriberRequest(input)
	return out, req.Send()
}

// UpdateSubscriberWithContext is the same as UpdateSubscriber with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateSubscriber for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *Budgets) UpdateSubscriberWithContext(ctx aws.Context, input *UpdateSubscriberInput, opts ...request.Option) (*UpdateSubscriberOutput, error) {
	req, out := c.UpdateSubscriberRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// AWS Budget model
type Budget struct {
	_ struct{} `type:"structure"`

	// A structure that represents either a cost spend or usage spend. Contains
	// an amount and a unit.
	//
	// BudgetLimit is a required field
	BudgetLimit *Spend `type:"structure" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// The type of a budget. It should be COST, USAGE, or RI_UTILIZATION.
	//
	// BudgetType is a required field
	BudgetType *string `type:"string" required:"true" enum:"BudgetType"`

	// A structure that holds the actual and forecasted spend for a budget.
	CalculatedSpend *CalculatedSpend `type:"structure"`

	// A map that represents the cost filters applied to the budget.
	CostFilters map[string][]*string `type:"map"`

	// This includes the options for getting the cost of a budget.
	//
	// CostTypes is a required field
	CostTypes *CostTypes `type:"structure" required:"true"`

	// A time period indicating the start date and end date of a budget.
	//
	// TimePeriod is a required field
	TimePeriod *TimePeriod `type:"structure" required:"true"`

	// The time unit of the budget. e.g. MONTHLY, QUARTERLY, etc.
	//
	// TimeUnit is a required field
	TimeUnit *string `type:"string" required:"true" enum:"TimeUnit"`
}

// String returns the string representation
func (s Budget) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Budget) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Budget) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "Budget"}
	if s.BudgetLimit == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetLimit"))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.BudgetType == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetType"))
	}
	if s.CostTypes == nil {
		invalidParams.Add(request.NewErrParamRequired("CostTypes"))
	}
	if s.TimePeriod == nil {
		invalidParams.Add(request.NewErrParamRequired("TimePeriod"))
	}
	if s.TimeUnit == nil {
		invalidParams.Add(request.NewErrParamRequired("TimeUnit"))
	}
	if s.BudgetLimit != nil {
		if err := s.BudgetLimit.Validate(); err != nil {
			invalidParams.AddNested("BudgetLimit", err.(request.ErrInvalidParams))
		}
	}
	if s.CalculatedSpend != nil {
		if err := s.CalculatedSpend.Validate(); err != nil {
			invalidParams.AddNested("CalculatedSpend", err.(request.ErrInvalidParams))
		}
	}
	if s.CostTypes != nil {
		if err := s.CostTypes.Validate(); err != nil {
			invalidParams.AddNested("CostTypes", err.(request.ErrInvalidParams))
		}
	}
	if s.TimePeriod != nil {
		if err := s.TimePeriod.Validate(); err != nil {
			invalidParams.AddNested("TimePeriod", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBudgetLimit sets the BudgetLimit field's value.
func (s *Budget) SetBudgetLimit(v *Spend) *Budget {
	s.BudgetLimit = v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *Budget) SetBudgetName(v string) *Budget {
	s.BudgetName = &v
	return s
}

// SetBudgetType sets the BudgetType field's value.
func (s *Budget) SetBudgetType(v string) *Budget {
	s.BudgetType = &v
	return s
}

// SetCalculatedSpend sets the CalculatedSpend field's value.
func (s *Budget) SetCalculatedSpend(v *CalculatedSpend) *Budget {
	s.CalculatedSpend = v
	return s
}

// SetCostFilters sets the CostFilters field's value.
func (s *Budget) SetCostFilters(v map[string][]*string) *Budget {
	s.CostFilters = v
	return s
}

// SetCostTypes sets the CostTypes field's value.
func (s *Budget) SetCostTypes(v *CostTypes) *Budget {
	s.CostTypes = v
	return s
}

// SetTimePeriod sets the TimePeriod field's value.
func (s *Budget) SetTimePeriod(v *TimePeriod) *Budget {
	s.TimePeriod = v
	return s
}

// SetTimeUnit sets the TimeUnit field's value.
func (s *Budget) SetTimeUnit(v string) *Budget {
	s.TimeUnit = &v
	return s
}

// A structure that holds the actual and forecasted spend for a budget.
type CalculatedSpend struct {
	_ struct{} `type:"structure"`

	// A structure that represents either a cost spend or usage spend. Contains
	// an amount and a unit.
	//
	// ActualSpend is a required field
	ActualSpend *Spend `type:"structure" required:"true"`

	// A structure that represents either a cost spend or usage spend. Contains
	// an amount and a unit.
	ForecastedSpend *Spend `type:"structure"`
}

// String returns the string representation
func (s CalculatedSpend) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CalculatedSpend) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CalculatedSpend) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CalculatedSpend"}
	if s.ActualSpend == nil {
		invalidParams.Add(request.NewErrParamRequired("ActualSpend"))
	}
	if s.ActualSpend != nil {
		if err := s.ActualSpend.Validate(); err != nil {
			invalidParams.AddNested("ActualSpend", err.(request.ErrInvalidParams))
		}
	}
	if s.ForecastedSpend != nil {
		if err := s.ForecastedSpend.Validate(); err != nil {
			invalidParams.AddNested("ForecastedSpend", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetActualSpend sets the ActualSpend field's value.
func (s *CalculatedSpend) SetActualSpend(v *Spend) *CalculatedSpend {
	s.ActualSpend = v
	return s
}

// SetForecastedSpend sets the ForecastedSpend field's value.
func (s *CalculatedSpend) SetForecastedSpend(v *Spend) *CalculatedSpend {
	s.ForecastedSpend = v
	return s
}

// This includes the options for getting the cost of a budget.
type CostTypes struct {
	_ struct{} `type:"structure"`

	// A generic boolean value.
	//
	// IncludeSubscription is a required field
	IncludeSubscription *bool `type:"boolean" required:"true"`

	// A generic boolean value.
	//
	// IncludeTax is a required field
	IncludeTax *bool `type:"boolean" required:"true"`

	// A generic boolean value.
	//
	// UseBlended is a required field
	UseBlended *bool `type:"boolean" required:"true"`
}

// String returns the string representation
func (s CostTypes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CostTypes) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CostTypes) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CostTypes"}
	if s.IncludeSubscription == nil {
		invalidParams.Add(request.NewErrParamRequired("IncludeSubscription"))
	}
	if s.IncludeTax == nil {
		invalidParams.Add(request.NewErrParamRequired("IncludeTax"))
	}
	if s.UseBlended == nil {
		invalidParams.Add(request.NewErrParamRequired("UseBlended"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetIncludeSubscription sets the IncludeSubscription field's value.
func (s *CostTypes) SetIncludeSubscription(v bool) *CostTypes {
	s.IncludeSubscription = &v
	return s
}

// SetIncludeTax sets the IncludeTax field's value.
func (s *CostTypes) SetIncludeTax(v bool) *CostTypes {
	s.IncludeTax = &v
	return s
}

// SetUseBlended sets the UseBlended field's value.
func (s *CostTypes) SetUseBlended(v bool) *CostTypes {
	s.UseBlended = &v
	return s
}

// Request of CreateBudget
type CreateBudgetInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// AWS Budget model
	//
	// Budget is a required field
	Budget *Budget `type:"structure" required:"true"`

	// A list of Notifications, each with a list of subscribers.
	NotificationsWithSubscribers []*NotificationWithSubscribers `type:"list"`
}

// String returns the string representation
func (s CreateBudgetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBudgetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBudgetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateBudgetInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.Budget == nil {
		invalidParams.Add(request.NewErrParamRequired("Budget"))
	}
	if s.Budget != nil {
		if err := s.Budget.Validate(); err != nil {
			invalidParams.AddNested("Budget", err.(request.ErrInvalidParams))
		}
	}
	if s.NotificationsWithSubscribers != nil {
		for i, v := range s.NotificationsWithSubscribers {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "NotificationsWithSubscribers", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *CreateBudgetInput) SetAccountId(v string) *CreateBudgetInput {
	s.AccountId = &v
	return s
}

// SetBudget sets the Budget field's value.
func (s *CreateBudgetInput) SetBudget(v *Budget) *CreateBudgetInput {
	s.Budget = v
	return s
}

// SetNotificationsWithSubscribers sets the NotificationsWithSubscribers field's value.
func (s *CreateBudgetInput) SetNotificationsWithSubscribers(v []*NotificationWithSubscribers) *CreateBudgetInput {
	s.NotificationsWithSubscribers = v
	return s
}

// Response of CreateBudget
type CreateBudgetOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s CreateBudgetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBudgetOutput) GoString() string {
	return s.String()
}

// Request of CreateNotification
type CreateNotificationInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`

	// A list of subscribers.
	//
	// Subscribers is a required field
	Subscribers []*Subscriber `min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s CreateNotificationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateNotificationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateNotificationInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateNotificationInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.Subscribers == nil {
		invalidParams.Add(request.NewErrParamRequired("Subscribers"))
	}
	if s.Subscribers != nil && len(s.Subscribers) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("Subscribers", 1))
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}
	if s.Subscribers != nil {
		for i, v := range s.Subscribers {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Subscribers", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *CreateNotificationInput) SetAccountId(v string) *CreateNotificationInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *CreateNotificationInput) SetBudgetName(v string) *CreateNotificationInput {
	s.BudgetName = &v
	return s
}

// SetNotification sets the Notification field's value.
func (s *CreateNotificationInput) SetNotification(v *Notification) *CreateNotificationInput {
	s.Notification = v
	return s
}

// SetSubscribers sets the Subscribers field's value.
func (s *CreateNotificationInput) SetSubscribers(v []*Subscriber) *CreateNotificationInput {
	s.Subscribers = v
	return s
}

// Response of CreateNotification
type CreateNotificationOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s CreateNotificationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateNotificationOutput) GoString() string {
	return s.String()
}

// Request of CreateSubscriber
type CreateSubscriberInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`

	// Subscriber model. Each notification may contain multiple subscribers with
	// different addresses.
	//
	// Subscriber is a required field
	Subscriber *Subscriber `type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateSubscriberInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSubscriberInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateSubscriberInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateSubscriberInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.Subscriber == nil {
		invalidParams.Add(request.NewErrParamRequired("Subscriber"))
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}
	if s.Subscriber != nil {
		if err := s.Subscriber.Validate(); err != nil {
			invalidParams.AddNested("Subscriber", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *CreateSubscriberInput) SetAccountId(v string) *CreateSubscriberInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *CreateSubscriberInput) SetBudgetName(v string) *CreateSubscriberInput {
	s.BudgetName = &v
	return s
}

// SetNotification sets the Notification field's value.
func (s *CreateSubscriberInput) SetNotification(v *Notification) *CreateSubscriberInput {
	s.Notification = v
	return s
}

// SetSubscriber sets the Subscriber field's value.
func (s *CreateSubscriberInput) SetSubscriber(v *Subscriber) *CreateSubscriberInput {
	s.Subscriber = v
	return s
}

// Response of CreateSubscriber
type CreateSubscriberOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s CreateSubscriberOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateSubscriberOutput) GoString() string {
	return s.String()
}

// Request of DeleteBudget
type DeleteBudgetInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBudgetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBudgetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBudgetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteBudgetInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DeleteBudgetInput) SetAccountId(v string) *DeleteBudgetInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *DeleteBudgetInput) SetBudgetName(v string) *DeleteBudgetInput {
	s.BudgetName = &v
	return s
}

// Response of DeleteBudget
type DeleteBudgetOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeleteBudgetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBudgetOutput) GoString() string {
	return s.String()
}

// Request of DeleteNotification
type DeleteNotificationInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`
}

// String returns the string representation
func (s DeleteNotificationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteNotificationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteNotificationInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteNotificationInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DeleteNotificationInput) SetAccountId(v string) *DeleteNotificationInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *DeleteNotificationInput) SetBudgetName(v string) *DeleteNotificationInput {
	s.BudgetName = &v
	return s
}

// SetNotification sets the Notification field's value.
func (s *DeleteNotificationInput) SetNotification(v *Notification) *DeleteNotificationInput {
	s.Notification = v
	return s
}

// Response of DeleteNotification
type DeleteNotificationOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeleteNotificationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteNotificationOutput) GoString() string {
	return s.String()
}

// Request of DeleteSubscriber
type DeleteSubscriberInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`

	// Subscriber model. Each notification may contain multiple subscribers with
	// different addresses.
	//
	// Subscriber is a required field
	Subscriber *Subscriber `type:"structure" required:"true"`
}

// String returns the string representation
func (s DeleteSubscriberInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSubscriberInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteSubscriberInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteSubscriberInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.Subscriber == nil {
		invalidParams.Add(request.NewErrParamRequired("Subscriber"))
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}
	if s.Subscriber != nil {
		if err := s.Subscriber.Validate(); err != nil {
			invalidParams.AddNested("Subscriber", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DeleteSubscriberInput) SetAccountId(v string) *DeleteSubscriberInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *DeleteSubscriberInput) SetBudgetName(v string) *DeleteSubscriberInput {
	s.BudgetName = &v
	return s
}

// SetNotification sets the Notification field's value.
func (s *DeleteSubscriberInput) SetNotification(v *Notification) *DeleteSubscriberInput {
	s.Notification = v
	return s
}

// SetSubscriber sets the Subscriber field's value.
func (s *DeleteSubscriberInput) SetSubscriber(v *Subscriber) *DeleteSubscriberInput {
	s.Subscriber = v
	return s
}

// Response of DeleteSubscriber
type DeleteSubscriberOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DeleteSubscriberOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteSubscriberOutput) GoString() string {
	return s.String()
}

// Request of DescribeBudget
type DescribeBudgetInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeBudgetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBudgetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBudgetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeBudgetInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DescribeBudgetInput) SetAccountId(v string) *DescribeBudgetInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *DescribeBudgetInput) SetBudgetName(v string) *DescribeBudgetInput {
	s.BudgetName = &v
	return s
}

// Response of DescribeBudget
type DescribeBudgetOutput struct {
	_ struct{} `type:"structure"`

	// AWS Budget model
	Budget *Budget `type:"structure"`
}

// String returns the string representation
func (s DescribeBudgetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBudgetOutput) GoString() string {
	return s.String()
}

// SetBudget sets the Budget field's value.
func (s *DescribeBudgetOutput) SetBudget(v *Budget) *DescribeBudgetOutput {
	s.Budget = v
	return s
}

// Request of DescribeBudgets
type DescribeBudgetsInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// An integer to represent how many entries a paginated response contains. Maximum
	// is set to 100.
	MaxResults *int64 `min:"1" type:"integer"`

	// A generic String.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s DescribeBudgetsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBudgetsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeBudgetsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeBudgetsInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(request.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DescribeBudgetsInput) SetAccountId(v string) *DescribeBudgetsInput {
	s.AccountId = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *DescribeBudgetsInput) SetMaxResults(v int64) *DescribeBudgetsInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeBudgetsInput) SetNextToken(v string) *DescribeBudgetsInput {
	s.NextToken = &v
	return s
}

// Response of DescribeBudgets
type DescribeBudgetsOutput struct {
	_ struct{} `type:"structure"`

	// A list of budgets
	Budgets []*Budget `type:"list"`

	// A generic String.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s DescribeBudgetsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeBudgetsOutput) GoString() string {
	return s.String()
}

// SetBudgets sets the Budgets field's value.
func (s *DescribeBudgetsOutput) SetBudgets(v []*Budget) *DescribeBudgetsOutput {
	s.Budgets = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeBudgetsOutput) SetNextToken(v string) *DescribeBudgetsOutput {
	s.NextToken = &v
	return s
}

// Request of DescribeNotificationsForBudget
type DescribeNotificationsForBudgetInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// An integer to represent how many entries a paginated response contains. Maximum
	// is set to 100.
	MaxResults *int64 `min:"1" type:"integer"`

	// A generic String.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s DescribeNotificationsForBudgetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeNotificationsForBudgetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeNotificationsForBudgetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeNotificationsForBudgetInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(request.NewErrParamMinValue("MaxResults", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DescribeNotificationsForBudgetInput) SetAccountId(v string) *DescribeNotificationsForBudgetInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *DescribeNotificationsForBudgetInput) SetBudgetName(v string) *DescribeNotificationsForBudgetInput {
	s.BudgetName = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *DescribeNotificationsForBudgetInput) SetMaxResults(v int64) *DescribeNotificationsForBudgetInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeNotificationsForBudgetInput) SetNextToken(v string) *DescribeNotificationsForBudgetInput {
	s.NextToken = &v
	return s
}

// Response of GetNotificationsForBudget
type DescribeNotificationsForBudgetOutput struct {
	_ struct{} `type:"structure"`

	// A generic String.
	NextToken *string `type:"string"`

	// A list of notifications.
	Notifications []*Notification `type:"list"`
}

// String returns the string representation
func (s DescribeNotificationsForBudgetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeNotificationsForBudgetOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeNotificationsForBudgetOutput) SetNextToken(v string) *DescribeNotificationsForBudgetOutput {
	s.NextToken = &v
	return s
}

// SetNotifications sets the Notifications field's value.
func (s *DescribeNotificationsForBudgetOutput) SetNotifications(v []*Notification) *DescribeNotificationsForBudgetOutput {
	s.Notifications = v
	return s
}

// Request of DescribeSubscribersForNotification
type DescribeSubscribersForNotificationInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// An integer to represent how many entries a paginated response contains. Maximum
	// is set to 100.
	MaxResults *int64 `min:"1" type:"integer"`

	// A generic String.
	NextToken *string `type:"string"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`
}

// String returns the string representation
func (s DescribeSubscribersForNotificationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeSubscribersForNotificationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeSubscribersForNotificationInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeSubscribersForNotificationInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.MaxResults != nil && *s.MaxResults < 1 {
		invalidParams.Add(request.NewErrParamMinValue("MaxResults", 1))
	}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *DescribeSubscribersForNotificationInput) SetAccountId(v string) *DescribeSubscribersForNotificationInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *DescribeSubscribersForNotificationInput) SetBudgetName(v string) *DescribeSubscribersForNotificationInput {
	s.BudgetName = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *DescribeSubscribersForNotificationInput) SetMaxResults(v int64) *DescribeSubscribersForNotificationInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeSubscribersForNotificationInput) SetNextToken(v string) *DescribeSubscribersForNotificationInput {
	s.NextToken = &v
	return s
}

// SetNotification sets the Notification field's value.
func (s *DescribeSubscribersForNotificationInput) SetNotification(v *Notification) *DescribeSubscribersForNotificationInput {
	s.Notification = v
	return s
}

// Response of DescribeSubscribersForNotification
type DescribeSubscribersForNotificationOutput struct {
	_ struct{} `type:"structure"`

	// A generic String.
	NextToken *string `type:"string"`

	// A list of subscribers.
	Subscribers []*Subscriber `min:"1" type:"list"`
}

// String returns the string representation
func (s DescribeSubscribersForNotificationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeSubscribersForNotificationOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeSubscribersForNotificationOutput) SetNextToken(v string) *DescribeSubscribersForNotificationOutput {
	s.NextToken = &v
	return s
}

// SetSubscribers sets the Subscribers field's value.
func (s *DescribeSubscribersForNotificationOutput) SetSubscribers(v []*Subscriber) *DescribeSubscribersForNotificationOutput {
	s.Subscribers = v
	return s
}

// Notification model. Each budget may contain multiple notifications with different
// settings.
type Notification struct {
	_ struct{} `type:"structure"`

	// The comparison operator of a notification. Currently we support less than,
	// equal to and greater than.
	//
	// ComparisonOperator is a required field
	ComparisonOperator *string `type:"string" required:"true" enum:"ComparisonOperator"`

	// The type of a notification. It should be ACTUAL or FORECASTED.
	//
	// NotificationType is a required field
	NotificationType *string `type:"string" required:"true" enum:"NotificationType"`

	// The threshold of a notification. It should be a number between 0 and 1,000,000,000.
	//
	// Threshold is a required field
	Threshold *float64 `min:"0.1" type:"double" required:"true"`

	// The type of threshold for a notification. It can be PERCENTAGE or ABSOLUTE_VALUE.
	ThresholdType *string `type:"string" enum:"ThresholdType"`
}

// String returns the string representation
func (s Notification) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Notification) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Notification) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "Notification"}
	if s.ComparisonOperator == nil {
		invalidParams.Add(request.NewErrParamRequired("ComparisonOperator"))
	}
	if s.NotificationType == nil {
		invalidParams.Add(request.NewErrParamRequired("NotificationType"))
	}
	if s.Threshold == nil {
		invalidParams.Add(request.NewErrParamRequired("Threshold"))
	}
	if s.Threshold != nil && *s.Threshold < 0.1 {
		invalidParams.Add(request.NewErrParamMinValue("Threshold", 0.1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetComparisonOperator sets the ComparisonOperator field's value.
func (s *Notification) SetComparisonOperator(v string) *Notification {
	s.ComparisonOperator = &v
	return s
}

// SetNotificationType sets the NotificationType field's value.
func (s *Notification) SetNotificationType(v string) *Notification {
	s.NotificationType = &v
	return s
}

// SetThreshold sets the Threshold field's value.
func (s *Notification) SetThreshold(v float64) *Notification {
	s.Threshold = &v
	return s
}

// SetThresholdType sets the ThresholdType field's value.
func (s *Notification) SetThresholdType(v string) *Notification {
	s.ThresholdType = &v
	return s
}

// A structure to relate notification and a list of subscribers who belong to
// the notification.
type NotificationWithSubscribers struct {
	_ struct{} `type:"structure"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`

	// A list of subscribers.
	//
	// Subscribers is a required field
	Subscribers []*Subscriber `min:"1" type:"list" required:"true"`
}

// String returns the string representation
func (s NotificationWithSubscribers) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NotificationWithSubscribers) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *NotificationWithSubscribers) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "NotificationWithSubscribers"}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.Subscribers == nil {
		invalidParams.Add(request.NewErrParamRequired("Subscribers"))
	}
	if s.Subscribers != nil && len(s.Subscribers) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("Subscribers", 1))
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}
	if s.Subscribers != nil {
		for i, v := range s.Subscribers {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Subscribers", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetNotification sets the Notification field's value.
func (s *NotificationWithSubscribers) SetNotification(v *Notification) *NotificationWithSubscribers {
	s.Notification = v
	return s
}

// SetSubscribers sets the Subscribers field's value.
func (s *NotificationWithSubscribers) SetSubscribers(v []*Subscriber) *NotificationWithSubscribers {
	s.Subscribers = v
	return s
}

// A structure that represents either a cost spend or usage spend. Contains
// an amount and a unit.
type Spend struct {
	_ struct{} `type:"structure"`

	// A string to represent NumericValue.
	//
	// Amount is a required field
	Amount *string `type:"string" required:"true"`

	// A string to represent budget spend unit. It should be not null and not empty.
	//
	// Unit is a required field
	Unit *string `min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s Spend) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Spend) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Spend) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "Spend"}
	if s.Amount == nil {
		invalidParams.Add(request.NewErrParamRequired("Amount"))
	}
	if s.Unit == nil {
		invalidParams.Add(request.NewErrParamRequired("Unit"))
	}
	if s.Unit != nil && len(*s.Unit) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("Unit", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAmount sets the Amount field's value.
func (s *Spend) SetAmount(v string) *Spend {
	s.Amount = &v
	return s
}

// SetUnit sets the Unit field's value.
func (s *Spend) SetUnit(v string) *Spend {
	s.Unit = &v
	return s
}

// Subscriber model. Each notification may contain multiple subscribers with
// different addresses.
type Subscriber struct {
	_ struct{} `type:"structure"`

	// A generic String.
	//
	// Address is a required field
	Address *string `type:"string" required:"true"`

	// The subscription type of the subscriber. It can be SMS or EMAIL.
	//
	// SubscriptionType is a required field
	SubscriptionType *string `type:"string" required:"true" enum:"SubscriptionType"`
}

// String returns the string representation
func (s Subscriber) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Subscriber) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Subscriber) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "Subscriber"}
	if s.Address == nil {
		invalidParams.Add(request.NewErrParamRequired("Address"))
	}
	if s.SubscriptionType == nil {
		invalidParams.Add(request.NewErrParamRequired("SubscriptionType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAddress sets the Address field's value.
func (s *Subscriber) SetAddress(v string) *Subscriber {
	s.Address = &v
	return s
}

// SetSubscriptionType sets the SubscriptionType field's value.
func (s *Subscriber) SetSubscriptionType(v string) *Subscriber {
	s.SubscriptionType = &v
	return s
}

// A time period indicating the start date and end date of a budget.
type TimePeriod struct {
	_ struct{} `type:"structure"`

	// A generic timestamp. In Java it is transformed to a Date object.
	//
	// End is a required field
	End *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`

	// A generic timestamp. In Java it is transformed to a Date object.
	//
	// Start is a required field
	Start *time.Time `type:"timestamp" timestampFormat:"unix" required:"true"`
}

// String returns the string representation
func (s TimePeriod) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TimePeriod) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TimePeriod) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "TimePeriod"}
	if s.End == nil {
		invalidParams.Add(request.NewErrParamRequired("End"))
	}
	if s.Start == nil {
		invalidParams.Add(request.NewErrParamRequired("Start"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetEnd sets the End field's value.
func (s *TimePeriod) SetEnd(v time.Time) *TimePeriod {
	s.End = &v
	return s
}

// SetStart sets the Start field's value.
func (s *TimePeriod) SetStart(v time.Time) *TimePeriod {
	s.Start = &v
	return s
}

// Request of UpdateBudget
type UpdateBudgetInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// AWS Budget model
	//
	// NewBudget is a required field
	NewBudget *Budget `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateBudgetInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBudgetInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateBudgetInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateBudgetInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.NewBudget == nil {
		invalidParams.Add(request.NewErrParamRequired("NewBudget"))
	}
	if s.NewBudget != nil {
		if err := s.NewBudget.Validate(); err != nil {
			invalidParams.AddNested("NewBudget", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *UpdateBudgetInput) SetAccountId(v string) *UpdateBudgetInput {
	s.AccountId = &v
	return s
}

// SetNewBudget sets the NewBudget field's value.
func (s *UpdateBudgetInput) SetNewBudget(v *Budget) *UpdateBudgetInput {
	s.NewBudget = v
	return s
}

// Response of UpdateBudget
type UpdateBudgetOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdateBudgetOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateBudgetOutput) GoString() string {
	return s.String()
}

// Request of UpdateNotification
type UpdateNotificationInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// NewNotification is a required field
	NewNotification *Notification `type:"structure" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// OldNotification is a required field
	OldNotification *Notification `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateNotificationInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateNotificationInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateNotificationInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateNotificationInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.NewNotification == nil {
		invalidParams.Add(request.NewErrParamRequired("NewNotification"))
	}
	if s.OldNotification == nil {
		invalidParams.Add(request.NewErrParamRequired("OldNotification"))
	}
	if s.NewNotification != nil {
		if err := s.NewNotification.Validate(); err != nil {
			invalidParams.AddNested("NewNotification", err.(request.ErrInvalidParams))
		}
	}
	if s.OldNotification != nil {
		if err := s.OldNotification.Validate(); err != nil {
			invalidParams.AddNested("OldNotification", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *UpdateNotificationInput) SetAccountId(v string) *UpdateNotificationInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *UpdateNotificationInput) SetBudgetName(v string) *UpdateNotificationInput {
	s.BudgetName = &v
	return s
}

// SetNewNotification sets the NewNotification field's value.
func (s *UpdateNotificationInput) SetNewNotification(v *Notification) *UpdateNotificationInput {
	s.NewNotification = v
	return s
}

// SetOldNotification sets the OldNotification field's value.
func (s *UpdateNotificationInput) SetOldNotification(v *Notification) *UpdateNotificationInput {
	s.OldNotification = v
	return s
}

// Response of UpdateNotification
type UpdateNotificationOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdateNotificationOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateNotificationOutput) GoString() string {
	return s.String()
}

// Request of UpdateSubscriber
type UpdateSubscriberInput struct {
	_ struct{} `type:"structure"`

	// Account Id of the customer. It should be a 12 digit number.
	//
	// AccountId is a required field
	AccountId *string `min:"12" type:"string" required:"true"`

	// A string represents the budget name. No ":" and "\" character is allowed.
	//
	// BudgetName is a required field
	BudgetName *string `type:"string" required:"true"`

	// Subscriber model. Each notification may contain multiple subscribers with
	// different addresses.
	//
	// NewSubscriber is a required field
	NewSubscriber *Subscriber `type:"structure" required:"true"`

	// Notification model. Each budget may contain multiple notifications with different
	// settings.
	//
	// Notification is a required field
	Notification *Notification `type:"structure" required:"true"`

	// Subscriber model. Each notification may contain multiple subscribers with
	// different addresses.
	//
	// OldSubscriber is a required field
	OldSubscriber *Subscriber `type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateSubscriberInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateSubscriberInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateSubscriberInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateSubscriberInput"}
	if s.AccountId == nil {
		invalidParams.Add(request.NewErrParamRequired("AccountId"))
	}
	if s.AccountId != nil && len(*s.AccountId) < 12 {
		invalidParams.Add(request.NewErrParamMinLen("AccountId", 12))
	}
	if s.BudgetName == nil {
		invalidParams.Add(request.NewErrParamRequired("BudgetName"))
	}
	if s.NewSubscriber == nil {
		invalidParams.Add(request.NewErrParamRequired("NewSubscriber"))
	}
	if s.Notification == nil {
		invalidParams.Add(request.NewErrParamRequired("Notification"))
	}
	if s.OldSubscriber == nil {
		invalidParams.Add(request.NewErrParamRequired("OldSubscriber"))
	}
	if s.NewSubscriber != nil {
		if err := s.NewSubscriber.Validate(); err != nil {
			invalidParams.AddNested("NewSubscriber", err.(request.ErrInvalidParams))
		}
	}
	if s.Notification != nil {
		if err := s.Notification.Validate(); err != nil {
			invalidParams.AddNested("Notification", err.(request.ErrInvalidParams))
		}
	}
	if s.OldSubscriber != nil {
		if err := s.OldSubscriber.Validate(); err != nil {
			invalidParams.AddNested("OldSubscriber", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAccountId sets the AccountId field's value.
func (s *UpdateSubscriberInput) SetAccountId(v string) *UpdateSubscriberInput {
	s.AccountId = &v
	return s
}

// SetBudgetName sets the BudgetName field's value.
func (s *UpdateSubscriberInput) SetBudgetName(v string) *UpdateSubscriberInput {
	s.BudgetName = &v
	return s
}

// SetNewSubscriber sets the NewSubscriber field's value.
func (s *UpdateSubscriberInput) SetNewSubscriber(v *Subscriber) *UpdateSubscriberInput {
	s.NewSubscriber = v
	return s
}

// SetNotification sets the Notification field's value.
func (s *UpdateSubscriberInput) SetNotification(v *Notification) *UpdateSubscriberInput {
	s.Notification = v
	return s
}

// SetOldSubscriber sets the OldSubscriber field's value.
func (s *UpdateSubscriberInput) SetOldSubscriber(v *Subscriber) *UpdateSubscriberInput {
	s.OldSubscriber = v
	return s
}

// Response of UpdateSubscriber
type UpdateSubscriberOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdateSubscriberOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateSubscriberOutput) GoString() string {
	return s.String()
}

// The type of a budget. It should be COST, USAGE, or RI_UTILIZATION.
const (
	// BudgetTypeUsage is a BudgetType enum value
	BudgetTypeUsage = "USAGE"

	// BudgetTypeCost is a BudgetType enum value
	BudgetTypeCost = "COST"

	// BudgetTypeRiUtilization is a BudgetType enum value
	BudgetTypeRiUtilization = "RI_UTILIZATION"
)

// The comparison operator of a notification. Currently we support less than,
// equal to and greater than.
const (
	// ComparisonOperatorGreaterThan is a ComparisonOperator enum value
	ComparisonOperatorGreaterThan = "GREATER_THAN"

	// ComparisonOperatorLessThan is a ComparisonOperator enum value
	ComparisonOperatorLessThan = "LESS_THAN"

	// ComparisonOperatorEqualTo is a ComparisonOperator enum value
	ComparisonOperatorEqualTo = "EQUAL_TO"
)

// The type of a notification. It should be ACTUAL or FORECASTED.
const (
	// NotificationTypeActual is a NotificationType enum value
	NotificationTypeActual = "ACTUAL"

	// NotificationTypeForecasted is a NotificationType enum value
	NotificationTypeForecasted = "FORECASTED"
)

// The subscription type of the subscriber. It can be SMS or EMAIL.
const (
	// SubscriptionTypeSns is a SubscriptionType enum value
	SubscriptionTypeSns = "SNS"

	// SubscriptionTypeEmail is a SubscriptionType enum value
	SubscriptionTypeEmail = "EMAIL"
)

// The type of threshold for a notification. It can be PERCENTAGE or ABSOLUTE_VALUE.
const (
	// ThresholdTypePercentage is a ThresholdType enum value
	ThresholdTypePercentage = "PERCENTAGE"

	// ThresholdTypeAbsoluteValue is a ThresholdType enum value
	ThresholdTypeAbsoluteValue = "ABSOLUTE_VALUE"
)

// The time unit of the budget. e.g. MONTHLY, QUARTERLY, etc.
const (
	// TimeUnitDaily is a TimeUnit enum value
	TimeUnitDaily = "DAILY"

	// TimeUnitMonthly is a TimeUnit enum value
	TimeUnitMonthly = "MONTHLY"

	// TimeUnitQuarterly is a TimeUnit enum value
	TimeUnitQuarterly = "QUARTERLY"

	// TimeUnitAnnually is a TimeUnit enum value
	TimeUnitAnnually = "ANNUALLY"
)
