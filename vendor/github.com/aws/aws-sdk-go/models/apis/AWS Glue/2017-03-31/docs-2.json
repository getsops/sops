{
  "version": "2.0",
  "service": "Defines service operations used by the GlueFrontendService",
  "operations": {
    "BatchCreatePartition": "<p>Creates one or more partitions in a batch operation.</p>",
    "BatchDeleteConnection": "<p>Deletes a list of connection definitions from the Data Catalog.</p>",
    "BatchDeletePartition": "<p>Deletes one or more partitions in a batch operation.</p>",
    "BatchDeleteTable": "<p>Deletes multiple tables at once.</p>",
    "BatchGetPartition": "<p>Retrieves partitions in a batch request.</p>",
    "CreateClassifier": "<p>Creates a <code>Classifier</code> in the user's account.</p>",
    "CreateConnection": "<p>Creates a connection definition in the Data Catalog.</p>",
    "CreateCrawler": "<p>Creates a new <code>Crawler</code> with specified targets, role, configuration, and optional schedule. At least one crawl target must be specified, in either the <i>s3Targets</i> or the <i>jdbcTargets</i> field.</p>",
    "CreateDatabase": "<p>Creates a new database in a Data Catalog.</p>",
    "CreateDevEndpoint": "<p>Creates a new DevEndpoint.</p>",
    "CreateJob": "<p>Creates a new job.</p>",
    "CreatePartition": "<p>Creates a new partition.</p>",
    "CreateScript": "<p>Transforms a directed acyclic graph (DAG) into a Python script.</p>",
    "CreateTable": "<p>Creates a new table definition in the Data Catalog.</p>",
    "CreateTrigger": "<p>Creates a new trigger.</p>",
    "CreateUserDefinedFunction": "<p>Creates a new function definition in the Data Catalog.</p>",
    "DeleteClassifier": "<p>Removes a <code>Classifier</code> from the metadata store.</p>",
    "DeleteConnection": "<p>Deletes a connection from the Data Catalog.</p>",
    "DeleteCrawler": "<p>Removes a specified <code>Crawler</code> from the metadata store, unless the <code>Crawler</code> state is <code>RUNNING</code>.</p>",
    "DeleteDatabase": "<p>Removes a specified Database from a Data Catalog.</p>",
    "DeleteDevEndpoint": "<p>Deletes a specified DevEndpoint.</p>",
    "DeleteJob": "<p>Deletes a specified job.</p>",
    "DeletePartition": "<p>Deletes a specified partition.</p>",
    "DeleteTable": "<p>Removes a table definition from the Data Catalog.</p>",
    "DeleteTrigger": "<p>Deletes a specified trigger.</p>",
    "DeleteUserDefinedFunction": "<p>Deletes an existing function definition from the Data Catalog.</p>",
    "GetCatalogImportStatus": "<p>Retrieves the status of a migration operation.</p>",
    "GetClassifier": "<p>Retrieve a <code>Classifier</code> by name.</p>",
    "GetClassifiers": "<p>Lists all Classifier objects in the metadata store.</p>",
    "GetConnection": "<p>Retrieves a connection definition from the Data Catalog.</p>",
    "GetConnections": "<p>Retrieves a list of connection definitions from the Data Catalog.</p>",
    "GetCrawler": "<p>Retrieves metadata for a specified <code>Crawler</code>.</p>",
    "GetCrawlerMetrics": "<p>Retrieves metrics about specified crawlers.</p>",
    "GetCrawlers": "<p>Retrieves metadata for all <code>Crawlers</code> defined in the customer account.</p>",
    "GetDatabase": "<p>Retrieves the definition of a specified database.</p>",
    "GetDatabases": "<p>Retrieves all Databases defined in a given Data Catalog.</p>",
    "GetDataflowGraph": "<p>Transforms a Python script into a directed acyclic graph (DAG). </p>",
    "GetDevEndpoint": "<p>Retrieves information about a specified DevEndpoint.</p>",
    "GetDevEndpoints": "<p>Retrieves all the DevEndpoints in this AWS account.</p>",
    "GetJob": "<p>Retrieves an existing job definition.</p>",
    "GetJobRun": "<p>Retrieves the metadata for a given job run.</p>",
    "GetJobRuns": "<p>Retrieves metadata for all runs of a given job.</p>",
    "GetJobs": "<p>Retrieves all current jobs.</p>",
    "GetMapping": "<p>Creates mappings.</p>",
    "GetPartition": "<p>Retrieves information about a specified partition.</p>",
    "GetPartitions": "<p>Retrieves information about the partitions in a table.</p>",
    "GetPlan": "<p>Gets a Python script to perform a specified mapping.</p>",
    "GetTable": "<p>Retrieves the <code>Table</code> definition in a Data Catalog for a specified table.</p>",
    "GetTableVersions": "<p>Retrieves a list of strings that identify available versions of a specified table.</p>",
    "GetTables": "<p>Retrieves the definitions of some or all of the tables in a given <code>Database</code>.</p>",
    "GetTrigger": "<p>Retrieves the definition of a trigger.</p>",
    "GetTriggers": "<p>Gets all the triggers associated with a job.</p>",
    "GetUserDefinedFunction": "<p>Retrieves a specified function definition from the Data Catalog.</p>",
    "GetUserDefinedFunctions": "<p>Retrieves a multiple function definitions from the Data Catalog.</p>",
    "ImportCatalogToGlue": "<p>Imports an existing Athena Data Catalog to AWS Glue</p>",
    "ResetJobBookmark": "<p>Resets a bookmark entry.</p>",
    "StartCrawler": "<p>Starts a crawl using the specified <code>Crawler</code>, regardless of what is scheduled. If the <code>Crawler</code> is already running, does nothing.</p>",
    "StartCrawlerSchedule": "<p>Changes the schedule state of the specified crawler to <code>SCHEDULED</code>, unless the crawler is already running or the schedule state is already <code>SCHEDULED</code>.</p>",
    "StartJobRun": "<p>Runs a job.</p>",
    "StartTrigger": "<p>Starts an existing trigger.</p>",
    "StopCrawler": "<p>If the specified <code>Crawler</code> is running, stops the crawl.</p>",
    "StopCrawlerSchedule": "<p>Sets the schedule state of the specified crawler to <code>NOT_SCHEDULED</code>, but does not stop the crawler if it is already running.</p>",
    "StopTrigger": "<p>Stops a specified trigger.</p>",
    "UpdateClassifier": "<p>Modifies an existing <code>Classifier</code>.</p>",
    "UpdateConnection": "<p>Updates a connection definition in the Data Catalog.</p>",
    "UpdateCrawler": "<p>Updates a <code>Crawler</code>. If a <code>Crawler</code> is running, you must stop it using <code>StopCrawler</code> before updating it.</p>",
    "UpdateCrawlerSchedule": "<p>Updates the schedule of a crawler using a Cron expression. </p>",
    "UpdateDatabase": "<p>Updates an existing database definition in a Data Catalog.</p>",
    "UpdateDevEndpoint": "<p>Updates a specified DevEndpoint.</p>",
    "UpdateJob": "<p>Updates an existing job definition.</p>",
    "UpdatePartition": "<p>Updates a partition.</p>",
    "UpdateTable": "<p>Updates a metadata table in the Data Catalog.</p>",
    "UpdateTrigger": "<p>Updates a trigger definition.</p>",
    "UpdateUserDefinedFunction": "<p>Updates an existing function definition in the Data Catalog.</p>"
  },
  "shapes": {
    "AccessDeniedException": {
      "base": "<p>Access to a resource was denied.</p>",
      "refs": {
      }
    },
    "Action": {
      "base": null,
      "refs": {
        "ActionList$member": null
      }
    },
    "ActionList": {
      "base": null,
      "refs": {
        "CreateTriggerRequest$Actions": "<p>The actions initiated by this trigger when it fires.</p>",
        "Trigger$Actions": "<p>The actions initiated by this trigger.</p>",
        "TriggerUpdate$Actions": "<p>The actions initiated by this trigger.</p>"
      }
    },
    "AlreadyExistsException": {
      "base": "<p>A resource to be created or added already exists.</p>",
      "refs": {
      }
    },
    "AttemptCount": {
      "base": null,
      "refs": {
        "JobRun$Attempt": "<p>The number or the attempt to run this job.</p>"
      }
    },
    "BatchCreatePartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "BatchCreatePartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "BatchDeleteConnectionRequest": {
      "base": null,
      "refs": {
      }
    },
    "BatchDeleteConnectionResponse": {
      "base": null,
      "refs": {
      }
    },
    "BatchDeletePartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "BatchDeletePartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "BatchDeletePartitionValueList": {
      "base": null,
      "refs": {
        "BatchDeletePartitionRequest$PartitionsToDelete": "<p>A list of <code>PartitionInput</code> structures that define the partitions to be deleted.</p>"
      }
    },
    "BatchDeleteTableNameList": {
      "base": null,
      "refs": {
        "BatchDeleteTableRequest$TablesToDelete": "<p>A list of the table to delete.</p>"
      }
    },
    "BatchDeleteTableRequest": {
      "base": null,
      "refs": {
      }
    },
    "BatchDeleteTableResponse": {
      "base": null,
      "refs": {
      }
    },
    "BatchGetPartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "BatchGetPartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "BatchGetPartitionValueList": {
      "base": null,
      "refs": {
        "BatchGetPartitionRequest$PartitionsToGet": "<p>A list of partition values identifying the partitions to retrieve.</p>",
        "BatchGetPartitionResponse$UnprocessedKeys": "<p>A list of the partition values in the request for which partions were not returned.</p>"
      }
    },
    "Boolean": {
      "base": null,
      "refs": {
        "CatalogImportStatus$ImportCompleted": "<p>True if the migration has completed, or False otherwise.</p>",
        "CodeGenNodeArg$Param": "<p>True if the value is used as a parameter.</p>",
        "CrawlerMetrics$StillEstimating": "<p>True if the crawler is estimating its </p>",
        "StorageDescriptor$Compressed": "<p>True if the data in the table is compressed, or False if not.</p>",
        "StorageDescriptor$StoredAsSubDirectories": "<p>True if the table data is stored in subdirectories, or False if not.</p>"
      }
    },
    "BooleanValue": {
      "base": null,
      "refs": {
        "GetJobRunRequest$PredecessorsIncluded": "<p>A list of the predecessor runs to return as well.</p>"
      }
    },
    "BoundedPartitionValueList": {
      "base": null,
      "refs": {
        "UpdatePartitionRequest$PartitionValueList": "<p>A list of the values defining the partition.</p>"
      }
    },
    "CatalogEntries": {
      "base": null,
      "refs": {
        "GetMappingRequest$Sinks": "<p>A list of target tables.</p>",
        "GetPlanRequest$Sinks": "<p>The target tables.</p>"
      }
    },
    "CatalogEntry": {
      "base": "<p>Specifies a table definition in the Data Catalog.</p>",
      "refs": {
        "CatalogEntries$member": null,
        "GetMappingRequest$Source": "<p>Specifies the source table.</p>",
        "GetPlanRequest$Source": "<p>The source table.</p>"
      }
    },
    "CatalogIdString": {
      "base": null,
      "refs": {
        "BatchCreatePartitionRequest$CatalogId": "<p>The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.</p>",
        "BatchDeleteConnectionRequest$CatalogId": "<p>The ID of the Data Catalog in which the connections reside. If none is supplied, the AWS account ID is used by default.</p>",
        "BatchDeletePartitionRequest$CatalogId": "<p>The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.</p>",
        "BatchDeleteTableRequest$CatalogId": "<p>The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.</p>",
        "BatchGetPartitionRequest$CatalogId": "<p>The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.</p>",
        "CreateConnectionRequest$CatalogId": "<p>The ID of the Data Catalog in which to create the connection. If none is supplied, the AWS account ID is used by default.</p>",
        "CreateDatabaseRequest$CatalogId": "<p>The ID of the Data Catalog in which to create the database. If none is supplied, the AWS account ID is used by default.</p>",
        "CreatePartitionRequest$CatalogId": "<p>The ID of the catalog in which the partion is to be created. Currently, this should be the AWS account ID.</p>",
        "CreateTableRequest$CatalogId": "<p>The ID of the Data Catalog in which to create the <code>Table</code>. If none is supplied, the AWS account ID is used by default.</p>",
        "CreateUserDefinedFunctionRequest$CatalogId": "<p>The ID of the Data Catalog in which to create the function. If none is supplied, the AWS account ID is used by default.</p>",
        "DeleteConnectionRequest$CatalogId": "<p>The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.</p>",
        "DeleteDatabaseRequest$CatalogId": "<p>The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.</p>",
        "DeletePartitionRequest$CatalogId": "<p>The ID of the Data Catalog where the partition to be deleted resides. If none is supplied, the AWS account ID is used by default.</p>",
        "DeleteTableRequest$CatalogId": "<p>The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.</p>",
        "DeleteUserDefinedFunctionRequest$CatalogId": "<p>The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the AWS account ID is used by default.</p>",
        "GetCatalogImportStatusRequest$CatalogId": "<p>The ID of the catalog to migrate. Currently, this should be the AWS account ID.</p>",
        "GetConnectionRequest$CatalogId": "<p>The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.</p>",
        "GetConnectionsRequest$CatalogId": "<p>The ID of the Data Catalog in which the connections reside. If none is supplied, the AWS account ID is used by default.</p>",
        "GetDatabaseRequest$CatalogId": "<p>The ID of the Data Catalog in which the database resides. If none is supplied, the AWS account ID is used by default.</p>",
        "GetDatabasesRequest$CatalogId": "<p>The ID of the Data Catalog from which to retrieve <code>Databases</code>. If none is supplied, the AWS account ID is used by default.</p>",
        "GetPartitionRequest$CatalogId": "<p>The ID of the Data Catalog where the partition in question resides. If none is supplied, the AWS account ID is used by default.</p>",
        "GetPartitionsRequest$CatalogId": "<p>The ID of the Data Catalog where the partitions in question reside. If none is supplied, the AWS account ID is used by default.</p>",
        "GetTableRequest$CatalogId": "<p>The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.</p>",
        "GetTableVersionsRequest$CatalogId": "<p>The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.</p>",
        "GetTablesRequest$CatalogId": "<p>The ID of the Data Catalog where the tables reside. If none is supplied, the AWS account ID is used by default.</p>",
        "GetUserDefinedFunctionRequest$CatalogId": "<p>The ID of the Data Catalog where the function to be retrieved is located. If none is supplied, the AWS account ID is used by default.</p>",
        "GetUserDefinedFunctionsRequest$CatalogId": "<p>The ID of the Data Catalog where the functions to be retrieved are located. If none is supplied, the AWS account ID is used by default.</p>",
        "ImportCatalogToGlueRequest$CatalogId": "<p>The ID of the catalog to import. Currently, this should be the AWS account ID.</p>",
        "UpdateConnectionRequest$CatalogId": "<p>The ID of the Data Catalog in which the connection resides. If none is supplied, the AWS account ID is used by default.</p>",
        "UpdateDatabaseRequest$CatalogId": "<p>The ID of the Data Catalog in which the metadata database resides. If none is supplied, the AWS account ID is used by default.</p>",
        "UpdatePartitionRequest$CatalogId": "<p>The ID of the Data Catalog where the partition to be updated resides. If none is supplied, the AWS account ID is used by default.</p>",
        "UpdateTableRequest$CatalogId": "<p>The ID of the Data Catalog where the table resides. If none is supplied, the AWS account ID is used by default.</p>",
        "UpdateUserDefinedFunctionRequest$CatalogId": "<p>The ID of the Data Catalog where the function to be updated is located. If none is supplied, the AWS account ID is used by default.</p>"
      }
    },
    "CatalogImportStatus": {
      "base": "<p>A structure containing migration status information.</p>",
      "refs": {
        "GetCatalogImportStatusResponse$ImportStatus": "<p>The status of the specified catalog migration.</p>"
      }
    },
    "Classification": {
      "base": null,
      "refs": {
        "CreateGrokClassifierRequest$Classification": "<p>The type of result that the classifier matches, such as Twitter Json, Omniture logs, Cloudwatch logs, and so forth.</p>",
        "GrokClassifier$Classification": "<p>The data form that the classifier matches, such as Twitter, JSON, Omniture Logs, and so forth.</p>",
        "UpdateGrokClassifierRequest$Classification": "<p>The type of result that the classifier matches, such as Twitter Json, Omniture logs, Cloudwatch logs, and so forth.</p>"
      }
    },
    "Classifier": {
      "base": "<p>Classifiers are written in Python and triggered during a Crawl Task. You can write your own Classifiers to best categorize your data sources and specify the appropriate schemas to use for them. A Classifier first checks whether a given file is in a format it can handle, and then, if so, creates a schema in the form of a <code>StructType</code> object that matches that data format.</p>",
      "refs": {
        "ClassifierList$member": null,
        "GetClassifierResponse$Classifier": "<p>The requested <code>Classifier</code>.</p>"
      }
    },
    "ClassifierList": {
      "base": null,
      "refs": {
        "GetClassifiersResponse$Classifiers": "<p>The requested list of <code>Classifier</code> objects.</p>"
      }
    },
    "ClassifierNameList": {
      "base": null,
      "refs": {
        "Crawler$Classifiers": "<p>A list of custom <code>Classifier</code>s associated with this Crawler.</p>",
        "CreateCrawlerRequest$Classifiers": "<p>A list of custom <code>Classifier</code> names that the user has registered. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.</p>",
        "UpdateCrawlerRequest$Classifiers": "<p>A list of custom <code>Classifier</code> names that the user has registered. By default, all AWS classifiers are included in a crawl, but these custom classifiers always override the default classifiers for a given classification.</p>"
      }
    },
    "CodeGenArgName": {
      "base": null,
      "refs": {
        "CodeGenEdge$TargetParameter": "<p>The target of the edge.</p>",
        "CodeGenNodeArg$Name": "<p>The name of the argument or property.</p>"
      }
    },
    "CodeGenArgValue": {
      "base": null,
      "refs": {
        "CodeGenNodeArg$Value": "<p>The value of the argument or property.</p>"
      }
    },
    "CodeGenEdge": {
      "base": "<p>Represents a directional edge in a directed acyclic graph (DAG).</p>",
      "refs": {
        "DagEdges$member": null
      }
    },
    "CodeGenIdentifier": {
      "base": null,
      "refs": {
        "CodeGenEdge$Source": "<p>The ID of the node at which the edge starts.</p>",
        "CodeGenEdge$Target": "<p>The ID of the node at which the edge ends.</p>",
        "CodeGenNode$Id": "<p>A node identifier that is unique within the node's graph.</p>"
      }
    },
    "CodeGenNode": {
      "base": "<p>Represents a node in a directed acyclic graph (DAG)</p>",
      "refs": {
        "DagNodes$member": null
      }
    },
    "CodeGenNodeArg": {
      "base": "<p>An argument or property of a node.</p>",
      "refs": {
        "CodeGenNodeArgs$member": null
      }
    },
    "CodeGenNodeArgs": {
      "base": null,
      "refs": {
        "CodeGenNode$Args": "<p>Properties of the node, in the form of name-value pairs.</p>",
        "Location$Jdbc": "<p>A JDBC location.</p>",
        "Location$S3": "<p>An AWS S3 location.</p>"
      }
    },
    "CodeGenNodeType": {
      "base": null,
      "refs": {
        "CodeGenNode$NodeType": "<p>The type of node this is.</p>"
      }
    },
    "Column": {
      "base": "<p>A column in a <code>Table</code>.</p>",
      "refs": {
        "ColumnList$member": null
      }
    },
    "ColumnList": {
      "base": null,
      "refs": {
        "StorageDescriptor$Columns": "<p>A list of the <code>Columns</code> in the table.</p>",
        "Table$PartitionKeys": "<p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>",
        "TableInput$PartitionKeys": "<p>A list of columns by which the table is partitioned. Only primitive types are supported as partition keys.</p>"
      }
    },
    "ColumnTypeString": {
      "base": null,
      "refs": {
        "Column$Type": "<p>The datatype of data in the <code>Column</code>.</p>"
      }
    },
    "ColumnValueStringList": {
      "base": null,
      "refs": {
        "SkewedInfo$SkewedColumnValues": "<p>A list of values that appear so frequently as to be considered skewed.</p>"
      }
    },
    "ColumnValuesString": {
      "base": null,
      "refs": {
        "ColumnValueStringList$member": null,
        "LocationMap$key": null,
        "LocationMap$value": null
      }
    },
    "CommentString": {
      "base": null,
      "refs": {
        "Column$Comment": "<p>Free-form text comment.</p>"
      }
    },
    "ConcurrentModificationException": {
      "base": "<p>Two processes are trying to modify a resource simultaneously.</p>",
      "refs": {
      }
    },
    "ConcurrentRunsExceededException": {
      "base": "<p>Too many jobs are being run concurrently.</p>",
      "refs": {
      }
    },
    "Condition": {
      "base": null,
      "refs": {
        "ConditionList$member": null
      }
    },
    "ConditionList": {
      "base": null,
      "refs": {
        "Predicate$Conditions": "<p>A list of the conditions that determine when the trigger will fire.</p>"
      }
    },
    "Connection": {
      "base": "<p>Defines a connection to a data source.</p>",
      "refs": {
        "ConnectionList$member": null,
        "GetConnectionResponse$Connection": "<p>The requested connection definition.</p>"
      }
    },
    "ConnectionInput": {
      "base": "<p>A structure used to specify a connection to create or update.</p>",
      "refs": {
        "CreateConnectionRequest$ConnectionInput": "<p>A <code>ConnectionInput</code> object defining the connection to create.</p>",
        "UpdateConnectionRequest$ConnectionInput": "<p>A <code>ConnectionInput</code> object that redefines the connection in question.</p>"
      }
    },
    "ConnectionList": {
      "base": null,
      "refs": {
        "GetConnectionsResponse$ConnectionList": "<p>A list of requested connection definitions.</p>"
      }
    },
    "ConnectionName": {
      "base": null,
      "refs": {
        "JdbcTarget$ConnectionName": "<p>The name of the connection to use for the JDBC target.</p>"
      }
    },
    "ConnectionProperties": {
      "base": null,
      "refs": {
        "Connection$ConnectionProperties": "<p>A list of key-value pairs used as parameters for this connection.</p>",
        "ConnectionInput$ConnectionProperties": "<p>A list of key-value pairs used as parameters for this connection.</p>"
      }
    },
    "ConnectionPropertyKey": {
      "base": null,
      "refs": {
        "ConnectionProperties$key": null
      }
    },
    "ConnectionType": {
      "base": null,
      "refs": {
        "Connection$ConnectionType": "<p>The type of the connection.</p>",
        "ConnectionInput$ConnectionType": "<p>The type of the connection.</p>",
        "GetConnectionsFilter$ConnectionType": "<p>The type of connections to return.</p>"
      }
    },
    "ConnectionsList": {
      "base": "<p>Specifies the connections used by a job.</p>",
      "refs": {
        "CreateJobRequest$Connections": "<p>The connections used for this job.</p>",
        "Job$Connections": "<p>The connections used for this job.</p>",
        "JobUpdate$Connections": "<p>The connections used for this job.</p>"
      }
    },
    "Crawler": {
      "base": "<p>Specifies a crawler program that examines a data source and uses classifiers to try to its schema. If successful, the crawler records metatdata concerning the data source in the Data Catalog.</p>",
      "refs": {
        "CrawlerList$member": null,
        "GetCrawlerResponse$Crawler": "<p>The metadata for the specified <code>Crawler</code>.</p>"
      }
    },
    "CrawlerList": {
      "base": null,
      "refs": {
        "GetCrawlersResponse$Crawlers": "<p>A list of <code>Crawler</code> metadata.</p>"
      }
    },
    "CrawlerMetrics": {
      "base": "<p>Metrics for a specified crawler.</p>",
      "refs": {
        "CrawlerMetricsList$member": null
      }
    },
    "CrawlerMetricsList": {
      "base": null,
      "refs": {
        "GetCrawlerMetricsResponse$CrawlerMetricsList": "<p>A list of metrics for the specified crawler.</p>"
      }
    },
    "CrawlerNameList": {
      "base": null,
      "refs": {
        "GetCrawlerMetricsRequest$CrawlerNameList": "<p>A list of the names of crawlers about which to retrieve metrics.</p>"
      }
    },
    "CrawlerNotRunningException": {
      "base": "<p>The specified crawler is not running.</p>",
      "refs": {
      }
    },
    "CrawlerRunningException": {
      "base": "<p>The operation cannot be performed because the crawler is already running.</p>",
      "refs": {
      }
    },
    "CrawlerState": {
      "base": null,
      "refs": {
        "Crawler$State": "<p>Indicates whether this Crawler is running, or whether a run is pending.</p>"
      }
    },
    "CrawlerStoppingException": {
      "base": "<p>The specified crawler is stopping.</p>",
      "refs": {
      }
    },
    "CrawlerTargets": {
      "base": "<p>Specifies crawler targets.</p>",
      "refs": {
        "Crawler$Targets": "<p>A collection of targets to crawl.</p>",
        "CreateCrawlerRequest$Targets": "<p>A list of collection of targets to crawl.</p>",
        "UpdateCrawlerRequest$Targets": "<p>A list of collection of targets to crawl.</p>"
      }
    },
    "CreateClassifierRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateClassifierResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateConnectionRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateConnectionResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateCrawlerRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateCrawlerResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateDatabaseRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateDatabaseResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateDevEndpointRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateDevEndpointResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateGrokClassifierRequest": {
      "base": "<p>Specifies a Grok classifier for CreateClassifier to create.</p>",
      "refs": {
        "CreateClassifierRequest$GrokClassifier": "<p>A grok classifier to create.</p>"
      }
    },
    "CreateJobRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateJobResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreatePartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreatePartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateScriptRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateScriptResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateTableRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateTableResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateTriggerRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateTriggerResponse": {
      "base": null,
      "refs": {
      }
    },
    "CreateUserDefinedFunctionRequest": {
      "base": null,
      "refs": {
      }
    },
    "CreateUserDefinedFunctionResponse": {
      "base": null,
      "refs": {
      }
    },
    "CronExpression": {
      "base": null,
      "refs": {
        "CreateCrawlerRequest$Schedule": "<p>A cron expression that can be used as a Cloudwatch event (see <a href=\"http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html\">CloudWatch Schedule Expression Syntax</a>. For example, to run every day at 12:15 UTC, specify: <code>cron(15 12 * * ? *)</code>.</p>",
        "Schedule$ScheduleExpression": "<p>A <code>cron</code> expression that can be used as a Cloudwatch event to schedule something (see <a href=\"http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html\">CloudWatch Schedule Expression Syntax</a>. For example, to run something every day at 12:15 UTC, you would specify: <code>cron(15 12 * * ? *)</code>.</p>",
        "UpdateCrawlerRequest$Schedule": "<p>A cron expression that can be used as a Cloudwatch event (see <a href=\"http://docs.aws.amazon.com/AmazonCloudWatch/latest/events/ScheduledEvents.html\">CloudWatch Schedule Expression Syntax</a>. For example, to run every day at 12:15 UTC, specify: <code>cron(15 12 * * ? *)</code>.</p>",
        "UpdateCrawlerScheduleRequest$Schedule": "<p>Cron expression of the updated schedule.</p>"
      }
    },
    "CustomPatterns": {
      "base": null,
      "refs": {
        "CreateGrokClassifierRequest$CustomPatterns": "<p>Custom grok patterns used by this classifier.</p>",
        "GrokClassifier$CustomPatterns": "<p>Custom grok patterns used by this classifier.</p>",
        "UpdateGrokClassifierRequest$CustomPatterns": "<p>Custom grok patterns used by this classifier.</p>"
      }
    },
    "DagEdges": {
      "base": null,
      "refs": {
        "CreateScriptRequest$DagEdges": "<p>A list of the edges in the DAG.</p>",
        "GetDataflowGraphResponse$DagEdges": "<p>A list of the edges in the resulting DAG.</p>"
      }
    },
    "DagNodes": {
      "base": null,
      "refs": {
        "CreateScriptRequest$DagNodes": "<p>A list of the nodes in the DAG.</p>",
        "GetDataflowGraphResponse$DagNodes": "<p>A list of the nodes in the resulting DAG.</p>"
      }
    },
    "Database": {
      "base": "<p>The <code>Database</code> object represents a logical grouping of tables that may reside in a Hive metastore or an RDBMS.</p>",
      "refs": {
        "DatabaseList$member": null,
        "GetDatabaseResponse$Database": "<p>The definition of the specified database in the catalog.</p>"
      }
    },
    "DatabaseInput": {
      "base": "<p>The structure used to create or updata a database.</p>",
      "refs": {
        "CreateDatabaseRequest$DatabaseInput": "<p>A <code>DatabaseInput</code> object defining the metadata database to create in the catalog.</p>",
        "UpdateDatabaseRequest$DatabaseInput": "<p>A <code>DatabaseInput</code> object specifying the new definition of the metadata database in the catalog.</p>"
      }
    },
    "DatabaseList": {
      "base": null,
      "refs": {
        "GetDatabasesResponse$DatabaseList": "<p>A list of <code>Database</code> objects from the specified catalog.</p>"
      }
    },
    "DatabaseName": {
      "base": null,
      "refs": {
        "Crawler$DatabaseName": "<p>The <code>Database</code> where this Crawler's output should be stored.</p>",
        "CreateCrawlerRequest$DatabaseName": "<p>The Glue <code>Database</code> where results will be stored, such as: <code>arn:aws:daylight:us-east-1::database/sometable/*</code>.</p>",
        "UpdateCrawlerRequest$DatabaseName": "<p>The Glue <code>Database</code> where results will be stored, such as: <code>arn:aws:daylight:us-east-1::database/sometable/*</code>.</p>"
      }
    },
    "DeleteBehavior": {
      "base": null,
      "refs": {
        "SchemaChangePolicy$DeleteBehavior": "<p>The deletion behavior.</p>"
      }
    },
    "DeleteClassifierRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteClassifierResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteConnectionNameList": {
      "base": null,
      "refs": {
        "BatchDeleteConnectionRequest$ConnectionNameList": "<p>A list of names of the connections to delete.</p>"
      }
    },
    "DeleteConnectionRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteConnectionResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteCrawlerRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteCrawlerResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteDatabaseRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteDatabaseResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteDevEndpointRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteDevEndpointResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteJobRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteJobResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeletePartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeletePartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteTableRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteTableResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteTriggerRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteTriggerResponse": {
      "base": null,
      "refs": {
      }
    },
    "DeleteUserDefinedFunctionRequest": {
      "base": null,
      "refs": {
      }
    },
    "DeleteUserDefinedFunctionResponse": {
      "base": null,
      "refs": {
      }
    },
    "DescriptionString": {
      "base": null,
      "refs": {
        "Connection$Description": "<p>Description of the connection.</p>",
        "ConnectionInput$Description": "<p>Description of the connection.</p>",
        "Crawler$Description": "<p>A description of this Crawler and where it should be used.</p>",
        "CreateCrawlerRequest$Description": "<p>A description of the new <code>Crawler</code>.</p>",
        "CreateJobRequest$Description": "<p>Description of the job.</p>",
        "CreateTriggerRequest$Description": "<p>A description of the new trigger.</p>",
        "Database$Description": "<p>Description of the database.</p>",
        "DatabaseInput$Description": "<p>Description of the database</p>",
        "ErrorDetail$ErrorMessage": "<p>A message describing the error.</p>",
        "Job$Description": "<p>Description of this job.</p>",
        "JobUpdate$Description": "<p>Description of the job.</p>",
        "LastCrawlInfo$ErrorMessage": "<p>Error information about the last crawl, if an error occurred.</p>",
        "Table$Description": "<p>Description of the table.</p>",
        "TableInput$Description": "<p>Description of the table.</p>",
        "Trigger$Description": "<p>A description of this trigger.</p>",
        "TriggerUpdate$Description": "<p>A description of this trigger.</p>"
      }
    },
    "DescriptionStringRemovable": {
      "base": null,
      "refs": {
        "UpdateCrawlerRequest$Description": "<p>A description of the new <code>Crawler</code>.</p>"
      }
    },
    "DevEndpoint": {
      "base": "<p>A development endpoint where a developer can remotely debug ETL scripts.</p>",
      "refs": {
        "DevEndpointList$member": null,
        "GetDevEndpointResponse$DevEndpoint": "<p>A DevEndpoint definition.</p>"
      }
    },
    "DevEndpointCustomLibraries": {
      "base": "<p>Custom libraries to be loaded into a DevEndpoint.</p>",
      "refs": {
        "UpdateDevEndpointRequest$CustomLibraries": "<p>Custom Python or Java custom libraries to be loaded in the DevEndpoint.</p>"
      }
    },
    "DevEndpointList": {
      "base": null,
      "refs": {
        "GetDevEndpointsResponse$DevEndpoints": "<p>A list of DevEndpoint definitions.</p>"
      }
    },
    "EntityNotFoundException": {
      "base": "<p>A specified entity does not exist</p>",
      "refs": {
      }
    },
    "ErrorByName": {
      "base": null,
      "refs": {
        "BatchDeleteConnectionResponse$Errors": "<p>A map of the names of connections that were not successfully deleted to error details.</p>"
      }
    },
    "ErrorDetail": {
      "base": "<p>Contains details about an error.</p>",
      "refs": {
        "ErrorByName$value": null,
        "PartitionError$ErrorDetail": "<p>Details about the partition error.</p>",
        "TableError$ErrorDetail": "<p>Detail about the error.</p>"
      }
    },
    "ErrorString": {
      "base": null,
      "refs": {
        "JobRun$ErrorMessage": "<p>An error message associated with this job run.</p>"
      }
    },
    "ExecutionProperty": {
      "base": "<p>An execution property of a job.</p>",
      "refs": {
        "CreateJobRequest$ExecutionProperty": "<p>An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.</p>",
        "Job$ExecutionProperty": "<p>An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.</p>",
        "JobUpdate$ExecutionProperty": "<p>An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.</p>"
      }
    },
    "FieldType": {
      "base": null,
      "refs": {
        "MappingEntry$SourceType": "<p>The source type.</p>",
        "MappingEntry$TargetType": "<p>The target type.</p>"
      }
    },
    "FilterString": {
      "base": null,
      "refs": {
        "GetTablesRequest$Expression": "<p>A regular expression pattern. If present, only those tables whose names match the pattern are returned.</p>"
      }
    },
    "FormatString": {
      "base": null,
      "refs": {
        "StorageDescriptor$InputFormat": "<p>The input format: <code>SequenceFileInputFormat</code> (binary), or <code>TextInputFormat</code>, or a custom format.</p>",
        "StorageDescriptor$OutputFormat": "<p>The output format: <code>SequenceFileOutputFormat</code> (binary), or <code>IgnoreKeyTextOutputFormat</code>, or a custom format.</p>"
      }
    },
    "GenericMap": {
      "base": null,
      "refs": {
        "Action$Arguments": null,
        "CreateJobRequest$DefaultArguments": "<p>The default parameters for this job.</p>",
        "Job$DefaultArguments": "<p>The default parameters for this job.</p>",
        "JobRun$Arguments": "<p>The job arguments associated with this run.</p>",
        "JobUpdate$DefaultArguments": "<p>The default parameters for this job.</p>",
        "StartJobRunRequest$Arguments": "<p>Specific arguments for this job run.</p>"
      }
    },
    "GenericString": {
      "base": null,
      "refs": {
        "CreateDevEndpointRequest$EndpointName": "<p>The name to be assigned to the new DevEndpoint.</p>",
        "CreateDevEndpointRequest$SubnetId": "<p>The subnet ID for the new DevEndpoint to use.</p>",
        "CreateDevEndpointRequest$PublicKey": "<p>The public key to use for authentication.</p>",
        "CreateDevEndpointRequest$ExtraPythonLibsS3Path": "<p>Path to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint.</p>",
        "CreateDevEndpointRequest$ExtraJarsS3Path": "<p>Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint.</p>",
        "CreateDevEndpointResponse$EndpointName": "<p>The name assigned to the new DevEndpoint.</p>",
        "CreateDevEndpointResponse$Status": "<p>The current status of the new DevEndpoint.</p>",
        "CreateDevEndpointResponse$SubnetId": "<p>The subnet ID assigned to the new DevEndpoint.</p>",
        "CreateDevEndpointResponse$YarnEndpointAddress": "<p>The address of the YARN endpoint used by this DevEndpoint.</p>",
        "CreateDevEndpointResponse$AvailabilityZone": "<p>The AWS availability zone where this DevEndpoint is located.</p>",
        "CreateDevEndpointResponse$VpcId": "<p>The ID of the VPC used by this DevEndpoint.</p>",
        "CreateDevEndpointResponse$ExtraPythonLibsS3Path": "<p>Path to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint.</p>",
        "CreateDevEndpointResponse$ExtraJarsS3Path": "<p>Path to one or more Java Jars in an S3 bucket that will be loaded in your DevEndpoint.</p>",
        "CreateDevEndpointResponse$FailureReason": "<p>The reason for a current failure in this DevEndpoint.</p>",
        "CreateTriggerRequest$Schedule": "<p>A cron schedule expression for the new trigger.</p>",
        "DeleteDevEndpointRequest$EndpointName": "<p>The name of the DevEndpoint.</p>",
        "DevEndpoint$EndpointName": "<p>The name of the DevEndpoint.</p>",
        "DevEndpoint$SubnetId": "<p>The subnet ID for this DevEndpoint.</p>",
        "DevEndpoint$YarnEndpointAddress": "<p>The YARN endpoint address used by this DevEndpoint.</p>",
        "DevEndpoint$PublicAddress": "<p>The public address used by this DevEndpoint.</p>",
        "DevEndpoint$Status": "<p>The current status of this DevEndpoint.</p>",
        "DevEndpoint$AvailabilityZone": "<p>The AWS availability zone where this DevEndpoint is located.</p>",
        "DevEndpoint$VpcId": "<p>The ID of the virtual private cloud (VPC) used by this DevEndpoint.</p>",
        "DevEndpoint$ExtraPythonLibsS3Path": "<p>Path to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint.</p>",
        "DevEndpoint$ExtraJarsS3Path": "<p>Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint.</p>",
        "DevEndpoint$FailureReason": "<p>The reason for a current failure in this DevEndpoint.</p>",
        "DevEndpoint$LastUpdateStatus": "<p>The status of the last update.</p>",
        "DevEndpoint$PublicKey": "<p>The public key to be used by this DevEndpoint for authentication.</p>",
        "DevEndpointCustomLibraries$ExtraPythonLibsS3Path": "<p>Path to one or more Python libraries in an S3 bucket that should be loaded in your DevEndpoint.</p>",
        "DevEndpointCustomLibraries$ExtraJarsS3Path": "<p>Path to one or more Java Jars in an S3 bucket that should be loaded in your DevEndpoint.</p>",
        "GenericMap$key": null,
        "GenericMap$value": null,
        "GetDevEndpointRequest$EndpointName": "<p>Name of the DevEndpoint for which to retrieve information.</p>",
        "GetDevEndpointsRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetDevEndpointsResponse$NextToken": "<p>A continuation token, if not all DevEndpoint definitions have yet been returned.</p>",
        "GetJobRunsRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetJobRunsResponse$NextToken": "<p>A continuation token, if not all reequested job runs have been returned.</p>",
        "GetJobsRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetJobsResponse$NextToken": "<p>A continuation token, if not all jobs have yet been returned.</p>",
        "GetTriggersRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetTriggersResponse$NextToken": "<p>A continuation token, if not all the requested triggers have yet been returned.</p>",
        "JobCommand$Name": "<p>The name of this job command.</p>",
        "StringList$member": null,
        "Trigger$Schedule": "<p>A cron schedule expression.</p>",
        "TriggerUpdate$Schedule": "<p>A cron expression specifying the schedule.</p>",
        "UpdateDevEndpointRequest$EndpointName": "<p>The name of the DevEndpoint to be updated.</p>",
        "UpdateDevEndpointRequest$PublicKey": "<p>The public key for the DevEndpoint to use.</p>"
      }
    },
    "GetCatalogImportStatusRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetCatalogImportStatusResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetClassifierRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetClassifierResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetClassifiersRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetClassifiersResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetConnectionRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetConnectionResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetConnectionsFilter": {
      "base": "<p>Filters the connection definitions returned by the <code>GetConnections</code> API.</p>",
      "refs": {
        "GetConnectionsRequest$Filter": "<p>A filter that controls which connections will be returned.</p>"
      }
    },
    "GetConnectionsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetConnectionsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetCrawlerMetricsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetCrawlerMetricsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetCrawlerRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetCrawlerResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetCrawlersRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetCrawlersResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetDatabaseRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetDatabaseResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetDatabasesRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetDatabasesResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetDataflowGraphRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetDataflowGraphResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetDevEndpointRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetDevEndpointResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetDevEndpointsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetDevEndpointsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetJobRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetJobResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetJobRunRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetJobRunResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetJobRunsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetJobRunsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetJobsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetJobsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetMappingRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetMappingResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetPartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetPartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetPartitionsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetPartitionsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetPlanRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetPlanResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetTableRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetTableResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetTableVersionsList": {
      "base": null,
      "refs": {
        "GetTableVersionsResponse$TableVersions": "<p>A list of strings identifying available versions of the specified table.</p>"
      }
    },
    "GetTableVersionsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetTableVersionsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetTablesRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetTablesResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetTriggerRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetTriggerResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetTriggersRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetTriggersResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetUserDefinedFunctionRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetUserDefinedFunctionResponse": {
      "base": null,
      "refs": {
      }
    },
    "GetUserDefinedFunctionsRequest": {
      "base": null,
      "refs": {
      }
    },
    "GetUserDefinedFunctionsResponse": {
      "base": null,
      "refs": {
      }
    },
    "GrokClassifier": {
      "base": "<p>A classifier that uses <code>grok</code>.</p>",
      "refs": {
        "Classifier$GrokClassifier": "<p>A GrokClassifier object.</p>"
      }
    },
    "GrokPattern": {
      "base": null,
      "refs": {
        "CreateGrokClassifierRequest$GrokPattern": "<p>The grok pattern used by this classifier.</p>",
        "GrokClassifier$GrokPattern": "<p>The grok pattern used by this classifier.</p>",
        "UpdateGrokClassifierRequest$GrokPattern": "<p>The grok pattern used by this classifier.</p>"
      }
    },
    "IdString": {
      "base": null,
      "refs": {
        "GetJobRunRequest$RunId": "<p>The ID of the job run.</p>",
        "JobRun$Id": "<p>The ID of this job run.</p>",
        "JobRun$PreviousRunId": "<p>The ID of the previous run of this job.</p>",
        "Predecessor$RunId": "<p>The job-run ID of the precessor job run.</p>",
        "StartJobRunRequest$JobRunId": "<p>The ID of the job run to start.</p>",
        "StartJobRunResponse$JobRunId": "<p>The ID assigned to this job run.</p>",
        "Trigger$Id": "<p>The trigger ID.</p>"
      }
    },
    "IdempotentParameterMismatchException": {
      "base": "<p>The same unique identifier was associated with two different records.</p>",
      "refs": {
      }
    },
    "ImportCatalogToGlueRequest": {
      "base": null,
      "refs": {
      }
    },
    "ImportCatalogToGlueResponse": {
      "base": null,
      "refs": {
      }
    },
    "Integer": {
      "base": null,
      "refs": {
        "CodeGenNode$LineNumber": "<p>The line number of the node.</p>",
        "StorageDescriptor$NumberOfBuckets": "<p>Must be specified if the table contains any dimension columns.</p>"
      }
    },
    "IntegerFlag": {
      "base": null,
      "refs": {
        "Order$SortOrder": "<p>Indicates that the column is sorted in ascending order (<code>== 1</code>), or in descending order (<code>==0</code>).</p>"
      }
    },
    "IntegerValue": {
      "base": null,
      "refs": {
        "CreateDevEndpointRequest$NumberOfNodes": "<p>The number of nodes to use.</p>",
        "CreateDevEndpointResponse$NumberOfNodes": "<p>The number of nodes in this DevEndpoint.</p>",
        "CreateJobRequest$AllocatedCapacity": "<p>The number of capacity units allocated to this job.</p>",
        "DevEndpoint$NumberOfNodes": "<p>The number of nodes used by this DevEndpoint.</p>",
        "Job$AllocatedCapacity": "<p>The number of capacity units allocated to this job.</p>",
        "JobBookmarkEntry$Version": "<p>Version of the job.</p>",
        "JobBookmarkEntry$Run": "<p>The run ID number.</p>",
        "JobBookmarkEntry$Attempt": "<p>The attempt ID number.</p>",
        "JobRun$AllocatedCapacity": "<p>The amount of infrastructure capacity allocated to this job run.</p>",
        "JobUpdate$AllocatedCapacity": "<p>The number of capacity units allocated to this job.</p>",
        "StartJobRunRequest$AllocatedCapacity": "<p>The infrastructure capacity to allocate to this job.</p>"
      }
    },
    "InternalServiceException": {
      "base": "<p>An internal service error occurred.</p>",
      "refs": {
      }
    },
    "InvalidInputException": {
      "base": "<p>The input provided was not valid.</p>",
      "refs": {
      }
    },
    "JdbcTarget": {
      "base": "<p>Specifies a JDBC target for a crawl.</p>",
      "refs": {
        "JdbcTargetList$member": null
      }
    },
    "JdbcTargetList": {
      "base": null,
      "refs": {
        "CrawlerTargets$JdbcTargets": "<p>Specifies JDBC targets.</p>"
      }
    },
    "Job": {
      "base": "<p>Specifies a job in the Data Catalog.</p>",
      "refs": {
        "GetJobResponse$Job": "<p>The requested job definition.</p>",
        "JobList$member": null
      }
    },
    "JobBookmarkEntry": {
      "base": "<p>Defines a point which a job can resume processing.</p>",
      "refs": {
        "ResetJobBookmarkResponse$JobBookmarkEntry": "<p>The reset bookmark entry.</p>"
      }
    },
    "JobCommand": {
      "base": "<p>Specifies code that executes a job.</p>",
      "refs": {
        "CreateJobRequest$Command": "<p>The JobCommand that executes this job.</p>",
        "Job$Command": "<p>The JobCommand that executes this job.</p>",
        "JobUpdate$Command": "<p>The JobCommand that executes this job.</p>"
      }
    },
    "JobList": {
      "base": null,
      "refs": {
        "GetJobsResponse$Jobs": "<p>A list of jobs.</p>"
      }
    },
    "JobName": {
      "base": null,
      "refs": {
        "JobBookmarkEntry$JobName": "<p>Name of the job in question.</p>",
        "ResetJobBookmarkRequest$JobName": "<p>The name of the job in question.</p>"
      }
    },
    "JobRun": {
      "base": "<p>Contains information about a job run.</p>",
      "refs": {
        "GetJobRunResponse$JobRun": "<p>The requested job-run metadata.</p>",
        "JobRunList$member": null
      }
    },
    "JobRunList": {
      "base": null,
      "refs": {
        "GetJobRunsResponse$JobRuns": "<p>A list of job-run metatdata objects.</p>"
      }
    },
    "JobRunState": {
      "base": null,
      "refs": {
        "Condition$State": null,
        "JobRun$JobRunState": "<p>The current state of the job run.</p>"
      }
    },
    "JobUpdate": {
      "base": "<p>Specifies information used to update an existing job.</p>",
      "refs": {
        "UpdateJobRequest$JobUpdate": "<p>Specifies the values with which to update the job.</p>"
      }
    },
    "JsonValue": {
      "base": null,
      "refs": {
        "JobBookmarkEntry$JobBookmark": "<p>The bookmark itself.</p>"
      }
    },
    "KeyString": {
      "base": null,
      "refs": {
        "ParametersMap$key": null
      }
    },
    "LastCrawlInfo": {
      "base": "<p>Status and error information about the most recent crawl.</p>",
      "refs": {
        "Crawler$LastCrawl": "<p>The status of the last crawl, and potentially error information if an error occurred.</p>"
      }
    },
    "LastCrawlStatus": {
      "base": null,
      "refs": {
        "LastCrawlInfo$Status": "<p>Status of the last crawl.</p>"
      }
    },
    "Location": {
      "base": "<p>The location of resources.</p>",
      "refs": {
        "GetMappingRequest$Location": "<p>Parameters for the mapping.</p>",
        "GetPlanRequest$Location": "<p>Parameters for the mapping.</p>"
      }
    },
    "LocationMap": {
      "base": null,
      "refs": {
        "SkewedInfo$SkewedColumnValueLocationMaps": "<p>A mapping of skewed values to the columns that contain them.</p>"
      }
    },
    "LocationString": {
      "base": null,
      "refs": {
        "StorageDescriptor$Location": "<p>The physical location of the table. By default this takes the form of the warehouse location, followed by the database location in the warehouse, followed by the table name.</p>"
      }
    },
    "LogGroup": {
      "base": null,
      "refs": {
        "LastCrawlInfo$LogGroup": "<p>The log group for the last crawl.</p>"
      }
    },
    "LogStream": {
      "base": null,
      "refs": {
        "LastCrawlInfo$LogStream": "<p>The log stream for the last crawl.</p>"
      }
    },
    "Logical": {
      "base": null,
      "refs": {
        "Predicate$Logical": "<p>Currently \"OR\" is not supported.</p>"
      }
    },
    "LogicalOperator": {
      "base": null,
      "refs": {
        "Condition$LogicalOperator": null
      }
    },
    "MappingEntry": {
      "base": "<p>Defines a mapping.</p>",
      "refs": {
        "MappingList$member": null
      }
    },
    "MappingList": {
      "base": null,
      "refs": {
        "GetMappingResponse$Mapping": "<p>A list of mappings to the specified targets.</p>",
        "GetPlanRequest$Mapping": "<p>The list of mappings from a source table to target tables.</p>"
      }
    },
    "MatchCriteria": {
      "base": null,
      "refs": {
        "Connection$MatchCriteria": "<p>A list of criteria that can be used in selecting this connection.</p>",
        "ConnectionInput$MatchCriteria": "<p>A list of criteria that can be used in selecting this connection.</p>",
        "GetConnectionsFilter$MatchCriteria": "<p>A criteria string that must match the criteria recorded in the connection definition for that connection definition to be returned.</p>"
      }
    },
    "MaxConcurrentRuns": {
      "base": null,
      "refs": {
        "ExecutionProperty$MaxConcurrentRuns": "<p>The maximum number of concurrent runs allowed for a job.</p>"
      }
    },
    "MaxRetries": {
      "base": null,
      "refs": {
        "CreateJobRequest$MaxRetries": "<p>The maximum number of times to retry this job if it fails.</p>",
        "Job$MaxRetries": "<p>The maximum number of times to retry this job if it fails.</p>",
        "JobUpdate$MaxRetries": "<p>The maximum number of times to retry this job if it fails.</p>"
      }
    },
    "MessagePrefix": {
      "base": null,
      "refs": {
        "LastCrawlInfo$MessagePrefix": "<p>The prefix for a message about this crawl.</p>"
      }
    },
    "MessageString": {
      "base": null,
      "refs": {
        "AccessDeniedException$Message": "<p>A message describing the problem.</p>",
        "AlreadyExistsException$Message": "<p>A message describing the problem.</p>",
        "ConcurrentModificationException$Message": "<p>A message describing the problem.</p>",
        "ConcurrentRunsExceededException$Message": "<p>A message describing the problem.</p>",
        "CrawlerNotRunningException$Message": "<p>A message describing the problem.</p>",
        "CrawlerRunningException$Message": "<p>A message describing the problem.</p>",
        "CrawlerStoppingException$Message": "<p>A message describing the problem.</p>",
        "EntityNotFoundException$Message": "<p>A message describing the problem.</p>",
        "IdempotentParameterMismatchException$Message": "<p>A message describing the problem.</p>",
        "InternalServiceException$Message": "<p>A message describing the problem.</p>",
        "InvalidInputException$Message": "<p>A message describing the problem.</p>",
        "NoScheduleException$Message": "<p>A message describing the problem.</p>",
        "OperationTimeoutException$Message": "<p>A message describing the problem.</p>",
        "ResourceNumberLimitExceededException$Message": "<p>A message describing the problem.</p>",
        "SchedulerNotRunningException$Message": "<p>A message describing the problem.</p>",
        "SchedulerRunningException$Message": "<p>A message describing the problem.</p>",
        "SchedulerTransitioningException$Message": "<p>A message describing the problem.</p>",
        "ValidationException$Message": "<p>A message describing the problem.</p>",
        "VersionMismatchException$Message": "<p>A message describing the problem.</p>"
      }
    },
    "MillisecondsCount": {
      "base": null,
      "refs": {
        "Crawler$CrawlElapsedTime": "<p>If this Crawler is running, contains the total time elapsed since the last crawl began.</p>"
      }
    },
    "NameString": {
      "base": null,
      "refs": {
        "Action$JobName": null,
        "BatchCreatePartitionRequest$DatabaseName": "<p>The name of the metadata database in which the partition is to be created.</p>",
        "BatchCreatePartitionRequest$TableName": "<p>The name of the metadata table in which the partition is to be created.</p>",
        "BatchDeletePartitionRequest$DatabaseName": "<p>The name of the catalog database in which the table in question resides.</p>",
        "BatchDeletePartitionRequest$TableName": "<p>The name of the table where the partitions to be deleted is located.</p>",
        "BatchDeleteTableNameList$member": null,
        "BatchDeleteTableRequest$DatabaseName": "<p>The name of the catalog database where the tables to delete reside.</p>",
        "BatchGetPartitionRequest$DatabaseName": "<p>The name of the catalog database where the partitions reside.</p>",
        "BatchGetPartitionRequest$TableName": "<p>The name of the partitions' table.</p>",
        "CatalogEntry$DatabaseName": "<p>The database in which the table metadata resides.</p>",
        "CatalogEntry$TableName": "<p>The name of the table in question.</p>",
        "CatalogImportStatus$ImportedBy": "<p>The name of the person who initiated the migration.</p>",
        "ClassifierNameList$member": null,
        "Column$Name": "<p>The name of the <code>Column</code>.</p>",
        "Condition$JobName": null,
        "Connection$Name": "<p>The name of the connection definition.</p>",
        "Connection$LastUpdatedBy": "<p>The user, group or role that last updated this connection definition.</p>",
        "ConnectionInput$Name": "<p>The name of the connection.</p>",
        "Crawler$Name": "<p>The <code>Crawler</code> name.</p>",
        "CrawlerMetrics$CrawlerName": "<p>The name of the crawler.</p>",
        "CrawlerNameList$member": null,
        "CreateCrawlerRequest$Name": "<p>Name of the new <code>Crawler</code>.</p>",
        "CreateGrokClassifierRequest$Name": "<p>The name of the new Classifier.</p>",
        "CreateJobRequest$Name": "<p>The name you assign to this job.</p>",
        "CreateJobResponse$Name": "<p>The unique name of the new job that has been created.</p>",
        "CreatePartitionRequest$DatabaseName": "<p>The name of the metadata database in which the partition is to be created.</p>",
        "CreatePartitionRequest$TableName": "<p>The name of the metadata table in which the partition is to be created.</p>",
        "CreateTableRequest$DatabaseName": "<p>The catalog database in which to create the new table.</p>",
        "CreateTriggerRequest$Name": "<p>The name to assign to the new trigger.</p>",
        "CreateTriggerResponse$Name": "<p>The name assigned to the new trigger.</p>",
        "CreateUserDefinedFunctionRequest$DatabaseName": "<p>The name of the catalog database in which to create the function.</p>",
        "Database$Name": "<p>Name of the database.</p>",
        "DatabaseInput$Name": "<p>Name of the database.</p>",
        "DeleteClassifierRequest$Name": "<p>Name of the <code>Classifier</code> to remove.</p>",
        "DeleteConnectionNameList$member": null,
        "DeleteConnectionRequest$ConnectionName": "<p>The name of the connection to delete.</p>",
        "DeleteCrawlerRequest$Name": "<p>Name of the <code>Crawler</code> to remove.</p>",
        "DeleteDatabaseRequest$Name": "<p>The name of the Database to delete.</p>",
        "DeleteJobRequest$JobName": "<p>The name of the job to delete.</p>",
        "DeleteJobResponse$JobName": "<p>The name of the job that was deleted.</p>",
        "DeletePartitionRequest$DatabaseName": "<p>The name of the catalog database in which the table in question resides.</p>",
        "DeletePartitionRequest$TableName": "<p>The name of the table where the partition to be deleted is located.</p>",
        "DeleteTableRequest$DatabaseName": "<p>The name of the catalog database in which the table resides.</p>",
        "DeleteTableRequest$Name": "<p>The name of the table to be deleted.</p>",
        "DeleteTriggerRequest$Name": "<p>The name of the trigger to delete.</p>",
        "DeleteTriggerResponse$Name": "<p>The name of the trigger that was deleted.</p>",
        "DeleteUserDefinedFunctionRequest$DatabaseName": "<p>The name of the catalog database where the function is located.</p>",
        "DeleteUserDefinedFunctionRequest$FunctionName": "<p>The name of the function definition to be deleted.</p>",
        "ErrorByName$key": null,
        "ErrorDetail$ErrorCode": "<p>The code associated with this error.</p>",
        "GetClassifierRequest$Name": "<p>Name of the <code>Classifier</code> to retrieve.</p>",
        "GetConnectionRequest$Name": "<p>The name of the connection definition to retrieve.</p>",
        "GetCrawlerRequest$Name": "<p>Name of the <code>Crawler</code> to retrieve metadata for.</p>",
        "GetDatabaseRequest$Name": "<p>The name of the database to retrieve.</p>",
        "GetJobRequest$JobName": "<p>The name of the job to retrieve.</p>",
        "GetJobRunRequest$JobName": "<p>Name of the job being run.</p>",
        "GetJobRunsRequest$JobName": "<p>The name of the job for which to retrieve all job runs.</p>",
        "GetPartitionRequest$DatabaseName": "<p>The name of the catalog database where the partition resides.</p>",
        "GetPartitionRequest$TableName": "<p>The name of the partition's table.</p>",
        "GetPartitionsRequest$DatabaseName": "<p>The name of the catalog database where the partitions reside.</p>",
        "GetPartitionsRequest$TableName": "<p>The name of the partitions' table.</p>",
        "GetTableRequest$DatabaseName": "<p>The name of the database in the catalog in which the table resides.</p>",
        "GetTableRequest$Name": "<p>The name of the table for which to retrieve the definition.</p>",
        "GetTableVersionsRequest$DatabaseName": "<p>The database in the catalog in which the table resides.</p>",
        "GetTableVersionsRequest$TableName": "<p>The name of the table.</p>",
        "GetTablesRequest$DatabaseName": "<p>The database in the catalog whose tables to list.</p>",
        "GetTriggerRequest$Name": "<p>The name of the trigger to retrieve.</p>",
        "GetTriggersRequest$DependentJobName": "<p>The name of the job for which to retrieve triggers.</p>",
        "GetUserDefinedFunctionRequest$DatabaseName": "<p>The name of the catalog database where the function is located.</p>",
        "GetUserDefinedFunctionRequest$FunctionName": "<p>The name of the function.</p>",
        "GetUserDefinedFunctionsRequest$DatabaseName": "<p>The name of the catalog database where the functions are located.</p>",
        "GetUserDefinedFunctionsRequest$Pattern": "<p>An optional function-name pattern string that filters the function definitions returned.</p>",
        "GrokClassifier$Name": "<p>The name of the classifier.</p>",
        "Job$Name": "<p>The name you assign to this job.</p>",
        "JobRun$TriggerName": "<p>The name of the trigger for this job run.</p>",
        "JobRun$JobName": "<p>The name of the job being run.</p>",
        "MatchCriteria$member": null,
        "NameStringList$member": null,
        "Order$Column": "<p>The name of the column.</p>",
        "Partition$DatabaseName": "<p>The name of the catalog database where the table in question is located.</p>",
        "Partition$TableName": "<p>The name of the table in question.</p>",
        "PhysicalConnectionRequirements$SubnetId": "<p>The subnet ID used by the connection.</p>",
        "PhysicalConnectionRequirements$AvailabilityZone": "<p>The connection's availability zone.</p>",
        "Predecessor$JobName": "<p>The name of the predecessor job.</p>",
        "SecurityGroupIdList$member": null,
        "SerDeInfo$Name": "<p>Name of the SerDe.</p>",
        "SerDeInfo$SerializationLibrary": "<p>Usually the class that implements the SerDe. An example is: <code>org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe</code>.</p>",
        "StartCrawlerRequest$Name": "<p>Name of the <code>Crawler</code> to start.</p>",
        "StartCrawlerScheduleRequest$CrawlerName": "<p>Name of the crawler to schedule.</p>",
        "StartJobRunRequest$JobName": "<p>The name of the job to start.</p>",
        "StartTriggerRequest$Name": "<p>The name of the trigger to start.</p>",
        "StartTriggerResponse$Name": "<p>The name of the trigger that was started.</p>",
        "StopCrawlerRequest$Name": "<p>Name of the <code>Crawler</code> to stop.</p>",
        "StopCrawlerScheduleRequest$CrawlerName": "<p>Name of the crawler whose schedule state to set.</p>",
        "StopTriggerRequest$Name": "<p>The name of the trigger to stop.</p>",
        "StopTriggerResponse$Name": "<p>The name of the trigger that was stopped.</p>",
        "Table$Name": "<p>Name of the table.</p>",
        "Table$DatabaseName": "<p>Name of the metadata database where the table metadata resides.</p>",
        "Table$Owner": "<p>Owner of the table.</p>",
        "Table$CreatedBy": "<p>Person or entity who created the table.</p>",
        "TableError$TableName": "<p>Name of the table.</p>",
        "TableInput$Name": "<p>Name of the table.</p>",
        "TableInput$Owner": "<p>Owner of the table.</p>",
        "Trigger$Name": "<p>Name of the trigger.</p>",
        "TriggerUpdate$Name": "<p>The name of the trigger.</p>",
        "UpdateConnectionRequest$Name": "<p>The name of the connection definition to update.</p>",
        "UpdateCrawlerRequest$Name": "<p>Name of the new <code>Crawler</code>.</p>",
        "UpdateCrawlerScheduleRequest$CrawlerName": "<p>Name of the crawler whose schedule to update.</p>",
        "UpdateDatabaseRequest$Name": "<p>The name of the metadata database to update in the catalog.</p>",
        "UpdateGrokClassifierRequest$Name": "<p>The name of the <code>GrokClassifier</code>.</p>",
        "UpdateJobRequest$JobName": "<p>Name of the job definition to update.</p>",
        "UpdateJobResponse$JobName": "<p>Returns the name of the updated job.</p>",
        "UpdatePartitionRequest$DatabaseName": "<p>The name of the catalog database in which the table in question resides.</p>",
        "UpdatePartitionRequest$TableName": "<p>The name of the table where the partition to be updated is located.</p>",
        "UpdateTableRequest$DatabaseName": "<p>The name of the catalog database in which the table resides.</p>",
        "UpdateTriggerRequest$Name": "<p>The name of the trigger to update.</p>",
        "UpdateUserDefinedFunctionRequest$DatabaseName": "<p>The name of the catalog database where the function to be updated is located.</p>",
        "UpdateUserDefinedFunctionRequest$FunctionName": "<p>The name of the function.</p>",
        "UserDefinedFunction$FunctionName": "<p>The name of the function.</p>",
        "UserDefinedFunction$ClassName": "<p>The Java class that contains the function code.</p>",
        "UserDefinedFunction$OwnerName": "<p>The owner of the function.</p>",
        "UserDefinedFunctionInput$FunctionName": "<p>The name of the function.</p>",
        "UserDefinedFunctionInput$ClassName": "<p>The Java class that contains the function code.</p>",
        "UserDefinedFunctionInput$OwnerName": "<p>The owner of the function.</p>"
      }
    },
    "NameStringList": {
      "base": null,
      "refs": {
        "BatchDeleteConnectionResponse$Succeeded": "<p>A list of names of the connection definitions that were successfully deleted.</p>",
        "SkewedInfo$SkewedColumnNames": "<p>A list of names of columns that contain skewed values.</p>",
        "StorageDescriptor$BucketColumns": "<p>A list of reducer grouping columns, clustering columns, and bucketing columns in the table.</p>"
      }
    },
    "NoScheduleException": {
      "base": "<p>There is no applicable schedule.</p>",
      "refs": {
      }
    },
    "NonNegativeDouble": {
      "base": null,
      "refs": {
        "CrawlerMetrics$TimeLeftSeconds": "<p>The estimated time left to complete a running crawl.</p>",
        "CrawlerMetrics$LastRuntimeSeconds": "<p>The duration of the crawler's most recent run, in seconds.</p>",
        "CrawlerMetrics$MedianRuntimeSeconds": "<p>The median duration of this crawler's runs, in seconds.</p>"
      }
    },
    "NonNegativeInteger": {
      "base": null,
      "refs": {
        "CrawlerMetrics$TablesCreated": "<p>A list of the tables created by this crawler.</p>",
        "CrawlerMetrics$TablesUpdated": "<p>A list of the tables created by this crawler.</p>",
        "CrawlerMetrics$TablesDeleted": "<p>A list of the tables deleted by this crawler.</p>",
        "Segment$SegmentNumber": "<p>The zero-based index number of the this segment. For example, if the total number of segments is 4, SegmentNumber values will range from zero through three.</p>",
        "Table$Retention": "<p>Retention time for this table.</p>",
        "TableInput$Retention": "<p>Retention time for this table.</p>"
      }
    },
    "OperationTimeoutException": {
      "base": "<p>The operation timed out.</p>",
      "refs": {
      }
    },
    "Order": {
      "base": "<p>Specifies the sort order of a sorted column.</p>",
      "refs": {
        "OrderList$member": null
      }
    },
    "OrderList": {
      "base": null,
      "refs": {
        "StorageDescriptor$SortColumns": "<p>A list specifying the sort order of each bucket in the table.</p>"
      }
    },
    "PageSize": {
      "base": null,
      "refs": {
        "GetClassifiersRequest$MaxResults": "<p>Size of the list to return (optional).</p>",
        "GetConnectionsRequest$MaxResults": "<p>The maximum number of connections to return in one response.</p>",
        "GetCrawlerMetricsRequest$MaxResults": "<p>The maximum size of a list to return.</p>",
        "GetCrawlersRequest$MaxResults": "<p>The number of Crawlers to return on each call.</p>",
        "GetDatabasesRequest$MaxResults": "<p>The maximum number of databases to return in one response.</p>",
        "GetDevEndpointsRequest$MaxResults": "<p>The maximum size of information to return.</p>",
        "GetJobRunsRequest$MaxResults": "<p>The maximum size of the response.</p>",
        "GetJobsRequest$MaxResults": "<p>The maximum size of the response.</p>",
        "GetPartitionsRequest$MaxResults": "<p>The maximum number of partitions to return in a single response.</p>",
        "GetTableVersionsRequest$MaxResults": "<p>The maximum number of table versions to return in one response.</p>",
        "GetTablesRequest$MaxResults": "<p>The maximum number of tables to return in a single response.</p>",
        "GetTriggersRequest$MaxResults": "<p>The maximum size of the response.</p>",
        "GetUserDefinedFunctionsRequest$MaxResults": "<p>The maximum number of functions to return in one response.</p>"
      }
    },
    "ParametersMap": {
      "base": null,
      "refs": {
        "Database$Parameters": "<p>A list of key-value pairs that define parameters and properties of the database.</p>",
        "DatabaseInput$Parameters": "<p>A list of key-value pairs that define parameters and properties of the database.</p>",
        "Partition$Parameters": "<p>Partition parameters, in the form of a list of key-value pairs.</p>",
        "PartitionInput$Parameters": "<p>Partition parameters, in the form of a list of key-value pairs.</p>",
        "SerDeInfo$Parameters": "<p>A list of initialization parameters for the SerDe, in key-value form.</p>",
        "StorageDescriptor$Parameters": "<p>User-supplied properties in key-value form.</p>",
        "Table$Parameters": "<p>Properties associated with this table, as a list of key-value pairs.</p>",
        "TableInput$Parameters": "<p>Properties associated with this table, as a list of key-value pairs.</p>"
      }
    },
    "ParametersMapValue": {
      "base": null,
      "refs": {
        "ParametersMap$value": null
      }
    },
    "Partition": {
      "base": "<p>Represents a slice of table data.</p>",
      "refs": {
        "GetPartitionResponse$Partition": "<p>The requested information, in the form of a <code>Partition</code> object.</p>",
        "PartitionList$member": null
      }
    },
    "PartitionError": {
      "base": "<p>Contains information about a partition error.</p>",
      "refs": {
        "PartitionErrors$member": null
      }
    },
    "PartitionErrors": {
      "base": null,
      "refs": {
        "BatchCreatePartitionResponse$Errors": "<p>Errors encountered when trying to create the requested partitions.</p>",
        "BatchDeletePartitionResponse$Errors": "<p>Errors encountered when trying to delete the requested partitions.</p>"
      }
    },
    "PartitionInput": {
      "base": "<p>The structure used to create and update a partion.</p>",
      "refs": {
        "CreatePartitionRequest$PartitionInput": "<p>A <code>PartitionInput</code> structure defining the partition to be created.</p>",
        "PartitionInputList$member": null,
        "UpdatePartitionRequest$PartitionInput": "<p>The new partition object to which to update the partition.</p>"
      }
    },
    "PartitionInputList": {
      "base": null,
      "refs": {
        "BatchCreatePartitionRequest$PartitionInputList": "<p>A list of <code>PartitionInput</code> structures that define the partitions to be created.</p>"
      }
    },
    "PartitionList": {
      "base": null,
      "refs": {
        "BatchGetPartitionResponse$Partitions": "<p>A list of the requested partitions.</p>",
        "GetPartitionsResponse$Partitions": "<p>A list of requested partitions.</p>"
      }
    },
    "PartitionValueList": {
      "base": null,
      "refs": {
        "BatchDeletePartitionValueList$member": null,
        "BatchGetPartitionValueList$member": null
      }
    },
    "Path": {
      "base": null,
      "refs": {
        "JdbcTarget$Path": "<p>The path of the JDBC target.</p>",
        "PathList$member": null,
        "S3Target$Path": "<p>The path to the S3 target.</p>"
      }
    },
    "PathList": {
      "base": null,
      "refs": {
        "JdbcTarget$Exclusions": "<p>A list of items to exclude from the crawl.</p>",
        "S3Target$Exclusions": "<p>A list of S3 objects to exclude from the crawl.</p>"
      }
    },
    "PhysicalConnectionRequirements": {
      "base": "<p>Specifies the physical requirements for a connection.</p>",
      "refs": {
        "Connection$PhysicalConnectionRequirements": "<p>A map of physical connection requirements, such as VPC and SecurityGroup, needed for making this connection successfully.</p>",
        "ConnectionInput$PhysicalConnectionRequirements": "<p>A map of physical connection requirements, such as VPC and SecurityGroup, needed for making this connection successfully.</p>"
      }
    },
    "Predecessor": {
      "base": "<p>A job run that preceded this one.</p>",
      "refs": {
        "PredecessorList$member": null
      }
    },
    "PredecessorList": {
      "base": null,
      "refs": {
        "JobRun$PredecessorRuns": "<p>A list of predecessors to this job run.</p>"
      }
    },
    "Predicate": {
      "base": "<p>Defines the predicate of the trigger, which determines when it fires.</p>",
      "refs": {
        "CreateTriggerRequest$Predicate": "<p>A predicate to specify when the new trigger should fire.</p>",
        "Trigger$Predicate": "<p>The predicate of this trigger.</p>",
        "TriggerUpdate$Predicate": "<p>The predicate of this trigger, which defines when it will fire.</p>"
      }
    },
    "PredicateString": {
      "base": null,
      "refs": {
        "GetPartitionsRequest$Expression": "<p>An expression filtering the partitions to be returned.</p>"
      }
    },
    "PrincipalType": {
      "base": null,
      "refs": {
        "UserDefinedFunction$OwnerType": "<p>The owner type.</p>",
        "UserDefinedFunctionInput$OwnerType": "<p>The owner type.</p>"
      }
    },
    "PythonScript": {
      "base": null,
      "refs": {
        "CreateScriptResponse$PythonScript": "<p>The Python script generated from the DAG.</p>",
        "GetDataflowGraphRequest$PythonScript": "<p>The Python script to transform.</p>",
        "GetPlanResponse$PythonScript": "<p>A python script to perform the mapping.</p>"
      }
    },
    "ResetJobBookmarkRequest": {
      "base": null,
      "refs": {
      }
    },
    "ResetJobBookmarkResponse": {
      "base": null,
      "refs": {
      }
    },
    "ResourceNumberLimitExceededException": {
      "base": "<p>A resource numerical limit was exceeded.</p>",
      "refs": {
      }
    },
    "ResourceType": {
      "base": null,
      "refs": {
        "ResourceUri$ResourceType": "<p>The type of the resource.</p>"
      }
    },
    "ResourceUri": {
      "base": "<p>URIs for function resources.</p>",
      "refs": {
        "ResourceUriList$member": null
      }
    },
    "ResourceUriList": {
      "base": null,
      "refs": {
        "UserDefinedFunction$ResourceUris": "<p>The resource URIs for the function.</p>",
        "UserDefinedFunctionInput$ResourceUris": "<p>The resource URIs for the function.</p>"
      }
    },
    "RoleArn": {
      "base": null,
      "refs": {
        "Crawler$Role": "<p>The ARN of an IAM role used to access customer resources such as data in S3.</p>",
        "CreateCrawlerRequest$Role": "<p>The AWS ARN of the IAM role used by the new <code>Crawler</code> to access customer resources.</p>",
        "CreateDevEndpointRequest$RoleArn": "<p>The IAM role for the DevEndpoint.</p>",
        "CreateDevEndpointResponse$RoleArn": "<p>The AWS ARN of the role assigned to the new DevEndpoint.</p>",
        "DevEndpoint$RoleArn": "<p>The AWS ARN of the IAM role used in this DevEndpoint.</p>",
        "UpdateCrawlerRequest$Role": "<p>The AWS ARN of the IAM role used by the new <code>Crawler</code> to access customer resources.</p>"
      }
    },
    "RoleString": {
      "base": null,
      "refs": {
        "CreateJobRequest$Role": "<p>The role associated with this job.</p>",
        "Job$Role": "<p>The role associated with this job.</p>",
        "JobUpdate$Role": "<p>The role associated with this job.</p>"
      }
    },
    "S3Target": {
      "base": "<p>Specifies a crawler target in AWS S3.</p>",
      "refs": {
        "S3TargetList$member": null
      }
    },
    "S3TargetList": {
      "base": null,
      "refs": {
        "CrawlerTargets$S3Targets": "<p>Specifies targets in AWS S3.</p>"
      }
    },
    "Schedule": {
      "base": "<p>A scheduling object using a <code>cron</code> statement to schedule an event.</p>",
      "refs": {
        "Crawler$Schedule": "<p>A <code>Schedule</code> object that specifies the schedule on which this Crawler is to be run.</p>"
      }
    },
    "ScheduleState": {
      "base": null,
      "refs": {
        "Schedule$State": "<p>The state of the schedule.</p>"
      }
    },
    "SchedulerNotRunningException": {
      "base": "<p>The specified scheduler is not running.</p>",
      "refs": {
      }
    },
    "SchedulerRunningException": {
      "base": "<p>The specified scheduler is already running.</p>",
      "refs": {
      }
    },
    "SchedulerTransitioningException": {
      "base": "<p>The specified scheduler is transitioning.</p>",
      "refs": {
      }
    },
    "SchemaChangePolicy": {
      "base": "<p>Crawler policy for update and deletion behavior.</p>",
      "refs": {
        "Crawler$SchemaChangePolicy": "<p>Sets policy for the crawler's update and delete behavior.</p>",
        "CreateCrawlerRequest$SchemaChangePolicy": "<p>Policy for the crawler's update and deletion behavior.</p>",
        "UpdateCrawlerRequest$SchemaChangePolicy": "<p>Policy for the crawler's update and deletion behavior.</p>"
      }
    },
    "SchemaPathString": {
      "base": null,
      "refs": {
        "MappingEntry$SourcePath": "<p>The source path.</p>",
        "MappingEntry$TargetPath": "<p>The target path.</p>"
      }
    },
    "ScriptLocationString": {
      "base": null,
      "refs": {
        "JobCommand$ScriptLocation": "<p>Specifies the location of a script that executes a job.</p>"
      }
    },
    "SecurityGroupIdList": {
      "base": null,
      "refs": {
        "PhysicalConnectionRequirements$SecurityGroupIdList": "<p>The security group ID list used by the connection.</p>"
      }
    },
    "Segment": {
      "base": "<p>Defines a non-overlapping region of a table's partitions, allowing multiple requests to be executed in parallel.</p>",
      "refs": {
        "GetPartitionsRequest$Segment": "<p>The segment of the table's partitions to scan in this request.</p>"
      }
    },
    "SerDeInfo": {
      "base": "<p>Information about a serialization/deserialization program (SerDe) which serves as an extractor and loader.</p>",
      "refs": {
        "StorageDescriptor$SerdeInfo": "<p>Serialization/deserialization (SerDe) information.</p>"
      }
    },
    "SkewedInfo": {
      "base": "<p>Specifies skewed values in a table. Skewed are ones that occur with very high frequency.</p>",
      "refs": {
        "StorageDescriptor$SkewedInfo": "<p>Information about values that appear very frequently in a column (skewed values).</p>"
      }
    },
    "StartCrawlerRequest": {
      "base": null,
      "refs": {
      }
    },
    "StartCrawlerResponse": {
      "base": null,
      "refs": {
      }
    },
    "StartCrawlerScheduleRequest": {
      "base": null,
      "refs": {
      }
    },
    "StartCrawlerScheduleResponse": {
      "base": null,
      "refs": {
      }
    },
    "StartJobRunRequest": {
      "base": null,
      "refs": {
      }
    },
    "StartJobRunResponse": {
      "base": null,
      "refs": {
      }
    },
    "StartTriggerRequest": {
      "base": null,
      "refs": {
      }
    },
    "StartTriggerResponse": {
      "base": null,
      "refs": {
      }
    },
    "StopCrawlerRequest": {
      "base": null,
      "refs": {
      }
    },
    "StopCrawlerResponse": {
      "base": null,
      "refs": {
      }
    },
    "StopCrawlerScheduleRequest": {
      "base": null,
      "refs": {
      }
    },
    "StopCrawlerScheduleResponse": {
      "base": null,
      "refs": {
      }
    },
    "StopTriggerRequest": {
      "base": null,
      "refs": {
      }
    },
    "StopTriggerResponse": {
      "base": null,
      "refs": {
      }
    },
    "StorageDescriptor": {
      "base": "<p>Describes the physical storage of table data.</p>",
      "refs": {
        "Partition$StorageDescriptor": "<p>Provides information about the physical location where the partition is stored.</p>",
        "PartitionInput$StorageDescriptor": "<p>Provides information about the physical location where the partition is stored.</p>",
        "Table$StorageDescriptor": "<p>A storage descriptor containing information about the physical storage of this table.</p>",
        "TableInput$StorageDescriptor": "<p>A storage descriptor containing information about the physical storage of this table.</p>"
      }
    },
    "StringList": {
      "base": null,
      "refs": {
        "ConnectionsList$Connections": "<p>A list of connections used by the job.</p>",
        "CreateDevEndpointRequest$SecurityGroupIds": "<p>Security group IDs for the security groups to be used by the new DevEndpoint.</p>",
        "CreateDevEndpointResponse$SecurityGroupIds": "<p>The security groups assigned to the new DevEndpoint.</p>",
        "DevEndpoint$SecurityGroupIds": "<p>A list of security group identifiers used in this DevEndpoint.</p>"
      }
    },
    "Table": {
      "base": "<p>Represents a collection of related data organized in columns and rows.</p>",
      "refs": {
        "GetTableResponse$Table": "<p>The <code>Table</code> object that defines the specified table.</p>",
        "TableList$member": null,
        "TableVersion$Table": null
      }
    },
    "TableError": {
      "base": "<p>An error record for table operations.</p>",
      "refs": {
        "TableErrors$member": null
      }
    },
    "TableErrors": {
      "base": null,
      "refs": {
        "BatchDeleteTableResponse$Errors": "<p>A list of errors encountered in attempting to delete the specified tables.</p>"
      }
    },
    "TableInput": {
      "base": "<p>Structure used to create or update the table.</p>",
      "refs": {
        "CreateTableRequest$TableInput": "<p>The <code>TableInput</code> object that defines the metadata table to create in the catalog.</p>",
        "UpdateTableRequest$TableInput": "<p>An updated <code>TableInput</code> object to define the metadata table in the catalog.</p>"
      }
    },
    "TableList": {
      "base": null,
      "refs": {
        "GetTablesResponse$TableList": "<p>A list of the requested <code>Table</code> objects.</p>"
      }
    },
    "TableName": {
      "base": null,
      "refs": {
        "MappingEntry$SourceTable": "<p>The name of the source table.</p>",
        "MappingEntry$TargetTable": "<p>The target table.</p>"
      }
    },
    "TablePrefix": {
      "base": null,
      "refs": {
        "Crawler$TablePrefix": "<p>The table prefix used for catalog tables created.</p>",
        "CreateCrawlerRequest$TablePrefix": "<p>The table prefix used for catalog tables created.</p>",
        "UpdateCrawlerRequest$TablePrefix": "<p>The table prefix used for catalog tables created.</p>"
      }
    },
    "TableTypeString": {
      "base": null,
      "refs": {
        "Table$TableType": "<p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>",
        "TableInput$TableType": "<p>The type of this table (<code>EXTERNAL_TABLE</code>, <code>VIRTUAL_VIEW</code>, etc.).</p>"
      }
    },
    "TableVersion": {
      "base": null,
      "refs": {
        "GetTableVersionsList$member": null
      }
    },
    "Timestamp": {
      "base": null,
      "refs": {
        "CatalogImportStatus$ImportTime": "<p>The time that the migration was started.</p>",
        "Connection$CreationTime": "<p>The time this connection definition was created.</p>",
        "Connection$LastUpdatedTime": "<p>The last time this connection definition was updated.</p>",
        "Crawler$CreationTime": "<p>The time when the Crawler was created.</p>",
        "Crawler$LastUpdated": "<p>The time the Crawler was last updated.</p>",
        "Database$CreateTime": "<p>The time at which the metadata database was created in the catalog.</p>",
        "GrokClassifier$CreationTime": "<p>The time this classifier was registered.</p>",
        "GrokClassifier$LastUpdated": "<p>The time this classifier was last updated.</p>",
        "LastCrawlInfo$StartTime": "<p>The time at which the crawl started.</p>",
        "Partition$CreationTime": "<p>The time at which the partition was created.</p>",
        "Partition$LastAccessTime": "<p>The last time at which the partition was accessed.</p>",
        "Partition$LastAnalyzedTime": "<p>The last time at which column statistics were computed for this partition.</p>",
        "PartitionInput$LastAccessTime": "<p>The last time at which the partition was accessed.</p>",
        "PartitionInput$LastAnalyzedTime": "<p>The last time at which column statistics were computed for this partition.</p>",
        "Table$CreateTime": "<p>Time when the table definition was created in the Data Catalog.</p>",
        "Table$UpdateTime": "<p>Last time the table was updated.</p>",
        "Table$LastAccessTime": "<p>Last time the table was accessed. This is usually taken from HDFS, and may not be reliable.</p>",
        "Table$LastAnalyzedTime": "<p>Last time column statistics were computed for this table.</p>",
        "TableInput$LastAccessTime": "<p>Last time the table was accessed.</p>",
        "TableInput$LastAnalyzedTime": "<p>Last time column statistics were computed for this table.</p>",
        "UserDefinedFunction$CreateTime": "<p>The time at which the function was created.</p>"
      }
    },
    "TimestampValue": {
      "base": null,
      "refs": {
        "CreateDevEndpointResponse$CreatedTimestamp": "<p>The point in time at which this DevEndpoint was created.</p>",
        "DevEndpoint$CreatedTimestamp": "<p>The point in time at which this DevEndpoint was created.</p>",
        "DevEndpoint$LastModifiedTimestamp": "<p>The point in time at which this DevEndpoint was last modified.</p>",
        "Job$CreatedOn": "<p>The time and date that this job specification was created.</p>",
        "Job$LastModifiedOn": "<p>The last point in time when this job specification was modified.</p>",
        "JobRun$StartedOn": "<p>The date and time at which this job run was started.</p>",
        "JobRun$LastModifiedOn": "<p>The last time this job run was modified.</p>",
        "JobRun$CompletedOn": "<p>The date and time this job run completed.</p>"
      }
    },
    "Token": {
      "base": null,
      "refs": {
        "GetClassifiersRequest$NextToken": "<p>An optional continuation token.</p>",
        "GetClassifiersResponse$NextToken": "<p>A continuation token.</p>",
        "GetConnectionsRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetConnectionsResponse$NextToken": "<p>A continuation token, if the list of connections returned does not include the last of the filtered connections.</p>",
        "GetCrawlerMetricsRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetCrawlerMetricsResponse$NextToken": "<p>A continuation token, if the returned list does not contain the last metric available.</p>",
        "GetCrawlersRequest$NextToken": "<p>A continuation token, if this is a continuation request.</p>",
        "GetCrawlersResponse$NextToken": "<p>A continuation token, if the returned list has not reached the end of those defined in this customer account.</p>",
        "GetDatabasesRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetDatabasesResponse$NextToken": "<p>A continuation token for paginating the returned list of tokens, returned if the current segment of the list is not the last.</p>",
        "GetPartitionsRequest$NextToken": "<p>A continuation token, if this is not the first call to retrieve these partitions.</p>",
        "GetPartitionsResponse$NextToken": "<p>A continuation token, if the returned list of partitions does not does not include the last one.</p>",
        "GetTableVersionsRequest$NextToken": "<p>A continuation token, if this is not the first call.</p>",
        "GetTableVersionsResponse$NextToken": "<p>A continuation token, if the list of available versions does not include the last one.</p>",
        "GetTablesRequest$NextToken": "<p>A continuation token, included if this is a continuation call.</p>",
        "GetTablesResponse$NextToken": "<p>A continuation token, present if the current list segment is not the last.</p>",
        "GetUserDefinedFunctionsRequest$NextToken": "<p>A continuation token, if this is a continuation call.</p>",
        "GetUserDefinedFunctionsResponse$NextToken": "<p>A continuation token, if the list of functions returned does not include the last requested function.</p>"
      }
    },
    "TotalSegmentsInteger": {
      "base": null,
      "refs": {
        "Segment$TotalSegments": "<p>The total numer of segments.</p>"
      }
    },
    "Trigger": {
      "base": "<p>Information about a specific trigger.</p>",
      "refs": {
        "GetTriggerResponse$Trigger": "<p>The requested trigger definition.</p>",
        "TriggerList$member": null,
        "UpdateTriggerResponse$Trigger": "<p>The resulting trigger definition.</p>"
      }
    },
    "TriggerList": {
      "base": null,
      "refs": {
        "GetTriggersResponse$Triggers": "<p>A list of triggers for the specified job.</p>"
      }
    },
    "TriggerState": {
      "base": null,
      "refs": {
        "Trigger$State": "<p>The current state of the trigger.</p>"
      }
    },
    "TriggerType": {
      "base": null,
      "refs": {
        "CreateTriggerRequest$Type": "<p>The type of the new trigger.</p>",
        "Trigger$Type": "<p>The type of trigger that this is.</p>"
      }
    },
    "TriggerUpdate": {
      "base": "<p>A structure used to provide information used to updata a trigger.</p>",
      "refs": {
        "UpdateTriggerRequest$TriggerUpdate": "<p>The new values with which to update the trigger.</p>"
      }
    },
    "URI": {
      "base": null,
      "refs": {
        "Database$LocationUri": "<p>The location of the database (for example, an HDFS path).</p>",
        "DatabaseInput$LocationUri": "<p>The location of the database (for example, an HDFS path).</p>",
        "ResourceUri$Uri": "<p>The URI for accessing the resource.</p>"
      }
    },
    "UpdateBehavior": {
      "base": null,
      "refs": {
        "SchemaChangePolicy$UpdateBehavior": "<p>The update behavior.</p>"
      }
    },
    "UpdateClassifierRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateClassifierResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateConnectionRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateConnectionResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateCrawlerRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateCrawlerResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateCrawlerScheduleRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateCrawlerScheduleResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateDatabaseRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateDatabaseResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateDevEndpointRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateDevEndpointResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateGrokClassifierRequest": {
      "base": "<p>Specifies a Grok classifier to update when passed to UpdateClassifier.</p>",
      "refs": {
        "UpdateClassifierRequest$GrokClassifier": "<p>A <code>GrokClassifier</code> object with updated fields.</p>"
      }
    },
    "UpdateJobRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateJobResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdatePartitionRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdatePartitionResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateTableRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateTableResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateTriggerRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateTriggerResponse": {
      "base": null,
      "refs": {
      }
    },
    "UpdateUserDefinedFunctionRequest": {
      "base": null,
      "refs": {
      }
    },
    "UpdateUserDefinedFunctionResponse": {
      "base": null,
      "refs": {
      }
    },
    "UriString": {
      "base": null,
      "refs": {
        "CreateJobRequest$LogUri": "<p>Location of the logs for this job.</p>",
        "Job$LogUri": "<p>Location of the logs for this job.</p>",
        "JobUpdate$LogUri": "<p>Location of the logs for this job.</p>"
      }
    },
    "UserDefinedFunction": {
      "base": "<p>Represents the equivalent of a Hive user-defined function (<code>UDF</code>) definition.</p>",
      "refs": {
        "GetUserDefinedFunctionResponse$UserDefinedFunction": "<p>The requested function definition.</p>",
        "UserDefinedFunctionList$member": null
      }
    },
    "UserDefinedFunctionInput": {
      "base": "<p>A structure used to create or updata a user-defined function.</p>",
      "refs": {
        "CreateUserDefinedFunctionRequest$FunctionInput": "<p>A <code>FunctionInput</code> object that defines the function to create in the Data Catalog.</p>",
        "UpdateUserDefinedFunctionRequest$FunctionInput": "<p>A <code>FunctionInput</code> object that re-defines the function in the Data Catalog.</p>"
      }
    },
    "UserDefinedFunctionList": {
      "base": null,
      "refs": {
        "GetUserDefinedFunctionsResponse$UserDefinedFunctions": "<p>A list of requested function definitions.</p>"
      }
    },
    "ValidationException": {
      "base": "<p>A value could not be validated.</p>",
      "refs": {
      }
    },
    "ValueString": {
      "base": null,
      "refs": {
        "BoundedPartitionValueList$member": null,
        "ConnectionProperties$value": null,
        "ValueStringList$member": null
      }
    },
    "ValueStringList": {
      "base": null,
      "refs": {
        "DeletePartitionRequest$PartitionValues": "<p>The values that define the partition.</p>",
        "GetPartitionRequest$PartitionValues": "<p>The values that define the partition.</p>",
        "Partition$Values": "<p>The values of the partition.</p>",
        "PartitionError$PartitionValues": "<p>The values that define the partition.</p>",
        "PartitionInput$Values": "<p>The values of the partition.</p>",
        "PartitionValueList$Values": null
      }
    },
    "VersionId": {
      "base": null,
      "refs": {
        "Crawler$Version": "<p>The version of the Crawler.</p>",
        "GrokClassifier$Version": "<p>The version of this classifier.</p>"
      }
    },
    "VersionMismatchException": {
      "base": "<p>There was a version conflict.</p>",
      "refs": {
      }
    },
    "VersionString": {
      "base": null,
      "refs": {
        "TableVersion$VersionId": null
      }
    },
    "ViewTextString": {
      "base": null,
      "refs": {
        "Table$ViewOriginalText": "<p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>",
        "Table$ViewExpandedText": "<p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>",
        "TableInput$ViewOriginalText": "<p>If the table is a view, the original text of the view; otherwise <code>null</code>.</p>",
        "TableInput$ViewExpandedText": "<p>If the table is a view, the expanded text of the view; otherwise <code>null</code>.</p>"
      }
    }
  }
}
