package web

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// AppsClient is the webSite Management Client
type AppsClient struct {
	BaseClient
}

// NewAppsClient creates an instance of the AppsClient client.
func NewAppsClient(subscriptionID string) AppsClient {
	return NewAppsClientWithBaseURI(DefaultBaseURI, subscriptionID)
}

// NewAppsClientWithBaseURI creates an instance of the AppsClient client.
func NewAppsClientWithBaseURI(baseURI string, subscriptionID string) AppsClient {
	return AppsClient{NewWithBaseURI(baseURI, subscriptionID)}
}

// AddPremierAddOn updates a named add-on of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
// premierAddOn - a JSON representation of the edited premier add-on.
func (client AppsClient) AddPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.AddPremierAddOn")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "AddPremierAddOn", err.Error())
	}

	req, err := client.AddPremierAddOnPreparer(ctx, resourceGroupName, name, premierAddOnName, premierAddOn)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AddPremierAddOn", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddPremierAddOnSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AddPremierAddOn", resp, "Failure sending request")
		return
	}

	result, err = client.AddPremierAddOnResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AddPremierAddOn", resp, "Failure responding to request")
	}

	return
}

// AddPremierAddOnPreparer prepares the AddPremierAddOn request.
func (client AppsClient) AddPremierAddOnPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithJSON(premierAddOn),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AddPremierAddOnSender sends the AddPremierAddOn request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) AddPremierAddOnSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// AddPremierAddOnResponder handles the response to the AddPremierAddOn request. The method always
// closes the http.Response Body.
func (client AppsClient) AddPremierAddOnResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AddPremierAddOnSlot updates a named add-on of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
// premierAddOn - a JSON representation of the edited premier add-on.
// slot - name of the deployment slot. If a slot is not specified, the API will update the named add-on for the
// production slot.
func (client AppsClient) AddPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, slot string) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.AddPremierAddOnSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "AddPremierAddOnSlot", err.Error())
	}

	req, err := client.AddPremierAddOnSlotPreparer(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AddPremierAddOnSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddPremierAddOnSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AddPremierAddOnSlot", resp, "Failure sending request")
		return
	}

	result, err = client.AddPremierAddOnSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AddPremierAddOnSlot", resp, "Failure responding to request")
	}

	return
}

// AddPremierAddOnSlotPreparer prepares the AddPremierAddOnSlot request.
func (client AppsClient) AddPremierAddOnSlotPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithJSON(premierAddOn),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AddPremierAddOnSlotSender sends the AddPremierAddOnSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) AddPremierAddOnSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// AddPremierAddOnSlotResponder handles the response to the AddPremierAddOnSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) AddPremierAddOnSlotResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AnalyzeCustomHostname analyze a custom hostname.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// hostName - custom hostname.
func (client AppsClient) AnalyzeCustomHostname(ctx context.Context, resourceGroupName string, name string, hostName string) (result CustomHostnameAnalysisResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.AnalyzeCustomHostname")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "AnalyzeCustomHostname", err.Error())
	}

	req, err := client.AnalyzeCustomHostnamePreparer(ctx, resourceGroupName, name, hostName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AnalyzeCustomHostname", nil, "Failure preparing request")
		return
	}

	resp, err := client.AnalyzeCustomHostnameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AnalyzeCustomHostname", resp, "Failure sending request")
		return
	}

	result, err = client.AnalyzeCustomHostnameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AnalyzeCustomHostname", resp, "Failure responding to request")
	}

	return
}

// AnalyzeCustomHostnamePreparer prepares the AnalyzeCustomHostname request.
func (client AppsClient) AnalyzeCustomHostnamePreparer(ctx context.Context, resourceGroupName string, name string, hostName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(hostName) > 0 {
		queryParameters["hostName"] = autorest.Encode("query", hostName)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AnalyzeCustomHostnameSender sends the AnalyzeCustomHostname request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) AnalyzeCustomHostnameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// AnalyzeCustomHostnameResponder handles the response to the AnalyzeCustomHostname request. The method always
// closes the http.Response Body.
func (client AppsClient) AnalyzeCustomHostnameResponder(resp *http.Response) (result CustomHostnameAnalysisResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// AnalyzeCustomHostnameSlot analyze a custom hostname.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
// hostName - custom hostname.
func (client AppsClient) AnalyzeCustomHostnameSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string) (result CustomHostnameAnalysisResult, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.AnalyzeCustomHostnameSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "AnalyzeCustomHostnameSlot", err.Error())
	}

	req, err := client.AnalyzeCustomHostnameSlotPreparer(ctx, resourceGroupName, name, slot, hostName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AnalyzeCustomHostnameSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.AnalyzeCustomHostnameSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AnalyzeCustomHostnameSlot", resp, "Failure sending request")
		return
	}

	result, err = client.AnalyzeCustomHostnameSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "AnalyzeCustomHostnameSlot", resp, "Failure responding to request")
	}

	return
}

// AnalyzeCustomHostnameSlotPreparer prepares the AnalyzeCustomHostnameSlot request.
func (client AppsClient) AnalyzeCustomHostnameSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, hostName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(hostName) > 0 {
		queryParameters["hostName"] = autorest.Encode("query", hostName)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// AnalyzeCustomHostnameSlotSender sends the AnalyzeCustomHostnameSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) AnalyzeCustomHostnameSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// AnalyzeCustomHostnameSlotResponder handles the response to the AnalyzeCustomHostnameSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) AnalyzeCustomHostnameSlotResponder(resp *http.Response) (result CustomHostnameAnalysisResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ApplySlotConfigToProduction applies the configuration settings from the target slot onto the current slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
func (client AppsClient) ApplySlotConfigToProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ApplySlotConfigToProduction")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: slotSwapEntity,
			Constraints: []validation.Constraint{{Target: "slotSwapEntity.TargetSlot", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "slotSwapEntity.PreserveVnet", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ApplySlotConfigToProduction", err.Error())
	}

	req, err := client.ApplySlotConfigToProductionPreparer(ctx, resourceGroupName, name, slotSwapEntity)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ApplySlotConfigToProduction", nil, "Failure preparing request")
		return
	}

	resp, err := client.ApplySlotConfigToProductionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ApplySlotConfigToProduction", resp, "Failure sending request")
		return
	}

	result, err = client.ApplySlotConfigToProductionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ApplySlotConfigToProduction", resp, "Failure responding to request")
	}

	return
}

// ApplySlotConfigToProductionPreparer prepares the ApplySlotConfigToProduction request.
func (client AppsClient) ApplySlotConfigToProductionPreparer(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig", pathParameters),
		autorest.WithJSON(slotSwapEntity),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ApplySlotConfigToProductionSender sends the ApplySlotConfigToProduction request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ApplySlotConfigToProductionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ApplySlotConfigToProductionResponder handles the response to the ApplySlotConfigToProduction request. The method always
// closes the http.Response Body.
func (client AppsClient) ApplySlotConfigToProductionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ApplySlotConfigurationSlot applies the configuration settings from the target slot onto the current slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// slot - name of the source slot. If a slot is not specified, the production slot is used as the source slot.
func (client AppsClient) ApplySlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ApplySlotConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: slotSwapEntity,
			Constraints: []validation.Constraint{{Target: "slotSwapEntity.TargetSlot", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "slotSwapEntity.PreserveVnet", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ApplySlotConfigurationSlot", err.Error())
	}

	req, err := client.ApplySlotConfigurationSlotPreparer(ctx, resourceGroupName, name, slotSwapEntity, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ApplySlotConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ApplySlotConfigurationSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ApplySlotConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ApplySlotConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ApplySlotConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// ApplySlotConfigurationSlotPreparer prepares the ApplySlotConfigurationSlot request.
func (client AppsClient) ApplySlotConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig", pathParameters),
		autorest.WithJSON(slotSwapEntity),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ApplySlotConfigurationSlotSender sends the ApplySlotConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ApplySlotConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ApplySlotConfigurationSlotResponder handles the response to the ApplySlotConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ApplySlotConfigurationSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Backup creates a backup of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - backup configuration. You can use the JSON response from the POST action as input here.
func (client AppsClient) Backup(ctx context.Context, resourceGroupName string, name string, request BackupRequest) (result BackupItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Backup")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.BackupRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.BackupRequestProperties.BackupSchedule", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.BackupSchedule.FrequencyInterval", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.KeepAtLeastOneBackup", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.RetentionPeriodInDays", Name: validation.Null, Rule: true, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Backup", err.Error())
	}

	req, err := client.BackupPreparer(ctx, resourceGroupName, name, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Backup", nil, "Failure preparing request")
		return
	}

	resp, err := client.BackupSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Backup", resp, "Failure sending request")
		return
	}

	result, err = client.BackupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Backup", resp, "Failure responding to request")
	}

	return
}

// BackupPreparer prepares the Backup request.
func (client AppsClient) BackupPreparer(ctx context.Context, resourceGroupName string, name string, request BackupRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BackupSender sends the Backup request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) BackupSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// BackupResponder handles the response to the Backup request. The method always
// closes the http.Response Body.
func (client AppsClient) BackupResponder(resp *http.Response) (result BackupItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// BackupSlot creates a backup of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - backup configuration. You can use the JSON response from the POST action as input here.
// slot - name of the deployment slot. If a slot is not specified, the API will create a backup for the
// production slot.
func (client AppsClient) BackupSlot(ctx context.Context, resourceGroupName string, name string, request BackupRequest, slot string) (result BackupItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.BackupSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.BackupRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.BackupRequestProperties.BackupSchedule", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.BackupSchedule.FrequencyInterval", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.KeepAtLeastOneBackup", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.RetentionPeriodInDays", Name: validation.Null, Rule: true, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "BackupSlot", err.Error())
	}

	req, err := client.BackupSlotPreparer(ctx, resourceGroupName, name, request, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "BackupSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.BackupSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "BackupSlot", resp, "Failure sending request")
		return
	}

	result, err = client.BackupSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "BackupSlot", resp, "Failure responding to request")
	}

	return
}

// BackupSlotPreparer prepares the BackupSlot request.
func (client AppsClient) BackupSlotPreparer(ctx context.Context, resourceGroupName string, name string, request BackupRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// BackupSlotSender sends the BackupSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) BackupSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// BackupSlotResponder handles the response to the BackupSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) BackupSlotResponder(resp *http.Response) (result BackupItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateDeployment create a deployment for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - ID of an existing deployment.
// deployment - deployment details.
func (client AppsClient) CreateDeployment(ctx context.Context, resourceGroupName string, name string, ID string, deployment Deployment) (result Deployment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateDeployment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateDeployment", err.Error())
	}

	req, err := client.CreateDeploymentPreparer(ctx, resourceGroupName, name, ID, deployment)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateDeploymentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.CreateDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateDeployment", resp, "Failure responding to request")
	}

	return
}

// CreateDeploymentPreparer prepares the CreateDeployment request.
func (client AppsClient) CreateDeploymentPreparer(ctx context.Context, resourceGroupName string, name string, ID string, deployment Deployment) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", pathParameters),
		autorest.WithJSON(deployment),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateDeploymentSender sends the CreateDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateDeploymentResponder handles the response to the CreateDeployment request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateDeploymentResponder(resp *http.Response) (result Deployment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateDeploymentSlot create a deployment for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - ID of an existing deployment.
// slot - name of the deployment slot. If a slot is not specified, the API creates a deployment for the
// production slot.
// deployment - deployment details.
func (client AppsClient) CreateDeploymentSlot(ctx context.Context, resourceGroupName string, name string, ID string, slot string, deployment Deployment) (result Deployment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateDeploymentSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateDeploymentSlot", err.Error())
	}

	req, err := client.CreateDeploymentSlotPreparer(ctx, resourceGroupName, name, ID, slot, deployment)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateDeploymentSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateDeploymentSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateDeploymentSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateDeploymentSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateDeploymentSlot", resp, "Failure responding to request")
	}

	return
}

// CreateDeploymentSlotPreparer prepares the CreateDeploymentSlot request.
func (client AppsClient) CreateDeploymentSlotPreparer(ctx context.Context, resourceGroupName string, name string, ID string, slot string, deployment Deployment) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", pathParameters),
		autorest.WithJSON(deployment),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateDeploymentSlotSender sends the CreateDeploymentSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateDeploymentSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateDeploymentSlotResponder handles the response to the CreateDeploymentSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateDeploymentSlotResponder(resp *http.Response) (result Deployment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateFunction create function for web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
// functionEnvelope - function details.
func (client AppsClient) CreateFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope) (result AppsCreateFunctionFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateFunction")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateFunction", err.Error())
	}

	req, err := client.CreateFunctionPreparer(ctx, resourceGroupName, name, functionName, functionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateFunction", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateFunctionSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateFunction", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateFunctionPreparer prepares the CreateFunction request.
func (client AppsClient) CreateFunctionPreparer(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}", pathParameters),
		autorest.WithJSON(functionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateFunctionSender sends the CreateFunction request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateFunctionSender(req *http.Request) (future AppsCreateFunctionFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateFunctionResponder handles the response to the CreateFunction request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateFunctionResponder(resp *http.Response) (result FunctionEnvelope, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateInstanceFunctionSlot create function for web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
// functionEnvelope - function details.
func (client AppsClient) CreateInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope) (result AppsCreateInstanceFunctionSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateInstanceFunctionSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateInstanceFunctionSlot", err.Error())
	}

	req, err := client.CreateInstanceFunctionSlotPreparer(ctx, resourceGroupName, name, functionName, slot, functionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateInstanceFunctionSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateInstanceFunctionSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateInstanceFunctionSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateInstanceFunctionSlotPreparer prepares the CreateInstanceFunctionSlot request.
func (client AppsClient) CreateInstanceFunctionSlotPreparer(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}", pathParameters),
		autorest.WithJSON(functionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateInstanceFunctionSlotSender sends the CreateInstanceFunctionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateInstanceFunctionSlotSender(req *http.Request) (future AppsCreateInstanceFunctionSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateInstanceFunctionSlotResponder handles the response to the CreateInstanceFunctionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateInstanceFunctionSlotResponder(resp *http.Response) (result FunctionEnvelope, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateInstanceMSDeployOperation invoke the MSDeploy web app extension.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// instanceID - ID of web app instance.
// mSDeploy - details of MSDeploy operation
func (client AppsClient) CreateInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, mSDeploy MSDeploy) (result AppsCreateInstanceMSDeployOperationFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateInstanceMSDeployOperation")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateInstanceMSDeployOperation", err.Error())
	}

	req, err := client.CreateInstanceMSDeployOperationPreparer(ctx, resourceGroupName, name, instanceID, mSDeploy)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateInstanceMSDeployOperation", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateInstanceMSDeployOperationSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateInstanceMSDeployOperation", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateInstanceMSDeployOperationPreparer prepares the CreateInstanceMSDeployOperation request.
func (client AppsClient) CreateInstanceMSDeployOperationPreparer(ctx context.Context, resourceGroupName string, name string, instanceID string, mSDeploy MSDeploy) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy", pathParameters),
		autorest.WithJSON(mSDeploy),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateInstanceMSDeployOperationSender sends the CreateInstanceMSDeployOperation request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateInstanceMSDeployOperationSender(req *http.Request) (future AppsCreateInstanceMSDeployOperationFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateInstanceMSDeployOperationResponder handles the response to the CreateInstanceMSDeployOperation request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateInstanceMSDeployOperationResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusConflict),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateInstanceMSDeployOperationSlot invoke the MSDeploy web app extension.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
// instanceID - ID of web app instance.
// mSDeploy - details of MSDeploy operation
func (client AppsClient) CreateInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, mSDeploy MSDeploy) (result AppsCreateInstanceMSDeployOperationSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateInstanceMSDeployOperationSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateInstanceMSDeployOperationSlot", err.Error())
	}

	req, err := client.CreateInstanceMSDeployOperationSlotPreparer(ctx, resourceGroupName, name, slot, instanceID, mSDeploy)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateInstanceMSDeployOperationSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateInstanceMSDeployOperationSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateInstanceMSDeployOperationSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateInstanceMSDeployOperationSlotPreparer prepares the CreateInstanceMSDeployOperationSlot request.
func (client AppsClient) CreateInstanceMSDeployOperationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, mSDeploy MSDeploy) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy", pathParameters),
		autorest.WithJSON(mSDeploy),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateInstanceMSDeployOperationSlotSender sends the CreateInstanceMSDeployOperationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateInstanceMSDeployOperationSlotSender(req *http.Request) (future AppsCreateInstanceMSDeployOperationSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateInstanceMSDeployOperationSlotResponder handles the response to the CreateInstanceMSDeployOperationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateInstanceMSDeployOperationSlotResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusConflict),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateMSDeployOperation invoke the MSDeploy web app extension.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// mSDeploy - details of MSDeploy operation
func (client AppsClient) CreateMSDeployOperation(ctx context.Context, resourceGroupName string, name string, mSDeploy MSDeploy) (result AppsCreateMSDeployOperationFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateMSDeployOperation")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateMSDeployOperation", err.Error())
	}

	req, err := client.CreateMSDeployOperationPreparer(ctx, resourceGroupName, name, mSDeploy)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateMSDeployOperation", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateMSDeployOperationSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateMSDeployOperation", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateMSDeployOperationPreparer prepares the CreateMSDeployOperation request.
func (client AppsClient) CreateMSDeployOperationPreparer(ctx context.Context, resourceGroupName string, name string, mSDeploy MSDeploy) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy", pathParameters),
		autorest.WithJSON(mSDeploy),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateMSDeployOperationSender sends the CreateMSDeployOperation request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateMSDeployOperationSender(req *http.Request) (future AppsCreateMSDeployOperationFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateMSDeployOperationResponder handles the response to the CreateMSDeployOperation request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateMSDeployOperationResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusConflict),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateMSDeployOperationSlot invoke the MSDeploy web app extension.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
// mSDeploy - details of MSDeploy operation
func (client AppsClient) CreateMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, mSDeploy MSDeploy) (result AppsCreateMSDeployOperationSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateMSDeployOperationSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateMSDeployOperationSlot", err.Error())
	}

	req, err := client.CreateMSDeployOperationSlotPreparer(ctx, resourceGroupName, name, slot, mSDeploy)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateMSDeployOperationSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateMSDeployOperationSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateMSDeployOperationSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateMSDeployOperationSlotPreparer prepares the CreateMSDeployOperationSlot request.
func (client AppsClient) CreateMSDeployOperationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, mSDeploy MSDeploy) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy", pathParameters),
		autorest.WithJSON(mSDeploy),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateMSDeployOperationSlotSender sends the CreateMSDeployOperationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateMSDeployOperationSlotSender(req *http.Request) (future AppsCreateMSDeployOperationSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateMSDeployOperationSlotResponder handles the response to the CreateMSDeployOperationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateMSDeployOperationSlotResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusConflict),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdate creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - unique name of the app to create or update. To create or update a deployment slot, use the {slot}
// parameter.
// siteEnvelope - a JSON representation of the app properties. See example.
func (client AppsClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site) (result AppsCreateOrUpdateFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdate")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: siteEnvelope,
			Constraints: []validation.Constraint{{Target: "siteEnvelope.SiteProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.Push", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.Push.PushSettingsProperties", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.Push.PushSettingsProperties.IsPushEnabled", Name: validation.Null, Rule: true, Chain: nil}}},
						}},
						{Target: "siteEnvelope.SiteProperties.SiteConfig.ReservedInstanceCount", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMaximum, Rule: int64(10), Chain: nil},
								{Target: "siteEnvelope.SiteProperties.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
							}},
					}},
					{Target: "siteEnvelope.SiteProperties.CloningInfo", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.CloningInfo.SourceWebAppID", Name: validation.Null, Rule: true, Chain: nil}}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdate", err.Error())
	}

	req, err := client.CreateOrUpdatePreparer(ctx, resourceGroupName, name, siteEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdate", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateOrUpdateSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdate", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateOrUpdatePreparer prepares the CreateOrUpdate request.
func (client AppsClient) CreateOrUpdatePreparer(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", pathParameters),
		autorest.WithJSON(siteEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSender sends the CreateOrUpdate request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateSender(req *http.Request) (future AppsCreateOrUpdateFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateOrUpdateResponder handles the response to the CreateOrUpdate request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateResponder(resp *http.Response) (result Site, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateConfiguration updates the configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteConfig - JSON representation of a SiteConfig object. See example.
func (client AppsClient) CreateOrUpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateConfiguration")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: siteConfig,
			Constraints: []validation.Constraint{{Target: "siteConfig.SiteConfig", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.Push", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.Push.PushSettingsProperties", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.Push.PushSettingsProperties.IsPushEnabled", Name: validation.Null, Rule: true, Chain: nil}}},
					}},
					{Target: "siteConfig.SiteConfig.ReservedInstanceCount", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMaximum, Rule: int64(10), Chain: nil},
							{Target: "siteConfig.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateConfiguration", err.Error())
	}

	req, err := client.CreateOrUpdateConfigurationPreparer(ctx, resourceGroupName, name, siteConfig)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateConfiguration", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateConfigurationPreparer prepares the CreateOrUpdateConfiguration request.
func (client AppsClient) CreateOrUpdateConfigurationPreparer(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web", pathParameters),
		autorest.WithJSON(siteConfig),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateConfigurationSender sends the CreateOrUpdateConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateConfigurationResponder handles the response to the CreateOrUpdateConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateConfigurationResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateConfigurationSlot updates the configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteConfig - JSON representation of a SiteConfig object. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will update configuration for the
// production slot.
func (client AppsClient) CreateOrUpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, slot string) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: siteConfig,
			Constraints: []validation.Constraint{{Target: "siteConfig.SiteConfig", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.Push", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.Push.PushSettingsProperties", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.Push.PushSettingsProperties.IsPushEnabled", Name: validation.Null, Rule: true, Chain: nil}}},
					}},
					{Target: "siteConfig.SiteConfig.ReservedInstanceCount", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteConfig.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMaximum, Rule: int64(10), Chain: nil},
							{Target: "siteConfig.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateConfigurationSlot", err.Error())
	}

	req, err := client.CreateOrUpdateConfigurationSlotPreparer(ctx, resourceGroupName, name, siteConfig, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateConfigurationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateConfigurationSlotPreparer prepares the CreateOrUpdateConfigurationSlot request.
func (client AppsClient) CreateOrUpdateConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web", pathParameters),
		autorest.WithJSON(siteConfig),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateConfigurationSlotSender sends the CreateOrUpdateConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateConfigurationSlotResponder handles the response to the CreateOrUpdateConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateConfigurationSlotResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateDomainOwnershipIdentifier creates a domain ownership identifier for web app, or updates an existing
// ownership identifier.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
// domainOwnershipIdentifier - a JSON representation of the domain ownership properties.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier) (result Identifier, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateDomainOwnershipIdentifier")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifier", err.Error())
	}

	req, err := client.CreateOrUpdateDomainOwnershipIdentifierPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifier", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateDomainOwnershipIdentifierSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifier", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateDomainOwnershipIdentifierResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifier", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateDomainOwnershipIdentifierPreparer prepares the CreateOrUpdateDomainOwnershipIdentifier request.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithJSON(domainOwnershipIdentifier),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateDomainOwnershipIdentifierSender sends the CreateOrUpdateDomainOwnershipIdentifier request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateDomainOwnershipIdentifierResponder handles the response to the CreateOrUpdateDomainOwnershipIdentifier request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierResponder(resp *http.Response) (result Identifier, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateDomainOwnershipIdentifierSlot creates a domain ownership identifier for web app, or updates an
// existing ownership identifier.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
// domainOwnershipIdentifier - a JSON representation of the domain ownership properties.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, slot string) (result Identifier, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateDomainOwnershipIdentifierSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifierSlot", err.Error())
	}

	req, err := client.CreateOrUpdateDomainOwnershipIdentifierSlotPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifierSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateDomainOwnershipIdentifierSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifierSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateDomainOwnershipIdentifierSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateDomainOwnershipIdentifierSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateDomainOwnershipIdentifierSlotPreparer prepares the CreateOrUpdateDomainOwnershipIdentifierSlot request.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierSlotPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"slot":                          autorest.Encode("path", slot),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithJSON(domainOwnershipIdentifier),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateDomainOwnershipIdentifierSlotSender sends the CreateOrUpdateDomainOwnershipIdentifierSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateDomainOwnershipIdentifierSlotResponder handles the response to the CreateOrUpdateDomainOwnershipIdentifierSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateDomainOwnershipIdentifierSlotResponder(resp *http.Response) (result Identifier, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateHostNameBinding creates a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// hostName - hostname in the hostname binding.
// hostNameBinding - binding details. This is the JSON representation of a HostNameBinding object.
func (client AppsClient) CreateOrUpdateHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding) (result HostNameBinding, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateHostNameBinding")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateHostNameBinding", err.Error())
	}

	req, err := client.CreateOrUpdateHostNameBindingPreparer(ctx, resourceGroupName, name, hostName, hostNameBinding)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHostNameBinding", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateHostNameBindingSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHostNameBinding", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateHostNameBindingResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHostNameBinding", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateHostNameBindingPreparer prepares the CreateOrUpdateHostNameBinding request.
func (client AppsClient) CreateOrUpdateHostNameBindingPreparer(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"hostName":          autorest.Encode("path", hostName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", pathParameters),
		autorest.WithJSON(hostNameBinding),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateHostNameBindingSender sends the CreateOrUpdateHostNameBinding request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateHostNameBindingSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateHostNameBindingResponder handles the response to the CreateOrUpdateHostNameBinding request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateHostNameBindingResponder(resp *http.Response) (result HostNameBinding, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateHostNameBindingSlot creates a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// hostName - hostname in the hostname binding.
// hostNameBinding - binding details. This is the JSON representation of a HostNameBinding object.
// slot - name of the deployment slot. If a slot is not specified, the API will create a binding for the
// production slot.
func (client AppsClient) CreateOrUpdateHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, slot string) (result HostNameBinding, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateHostNameBindingSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateHostNameBindingSlot", err.Error())
	}

	req, err := client.CreateOrUpdateHostNameBindingSlotPreparer(ctx, resourceGroupName, name, hostName, hostNameBinding, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHostNameBindingSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateHostNameBindingSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHostNameBindingSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateHostNameBindingSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHostNameBindingSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateHostNameBindingSlotPreparer prepares the CreateOrUpdateHostNameBindingSlot request.
func (client AppsClient) CreateOrUpdateHostNameBindingSlotPreparer(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"hostName":          autorest.Encode("path", hostName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", pathParameters),
		autorest.WithJSON(hostNameBinding),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateHostNameBindingSlotSender sends the CreateOrUpdateHostNameBindingSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateHostNameBindingSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateHostNameBindingSlotResponder handles the response to the CreateOrUpdateHostNameBindingSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateHostNameBindingSlotResponder(resp *http.Response) (result HostNameBinding, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateHybridConnection creates a new Hybrid Connection using a Service Bus relay.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// connectionEnvelope - the details of the hybrid connection.
func (client AppsClient) CreateOrUpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateHybridConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateHybridConnection", err.Error())
	}

	req, err := client.CreateOrUpdateHybridConnectionPreparer(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHybridConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateHybridConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHybridConnection", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateHybridConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHybridConnection", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateHybridConnectionPreparer prepares the CreateOrUpdateHybridConnection request.
func (client AppsClient) CreateOrUpdateHybridConnectionPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateHybridConnectionSender sends the CreateOrUpdateHybridConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateHybridConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateHybridConnectionResponder handles the response to the CreateOrUpdateHybridConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateHybridConnectionResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateHybridConnectionSlot creates a new Hybrid Connection using a Service Bus relay.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// connectionEnvelope - the details of the hybrid connection.
// slot - the name of the slot for the web app.
func (client AppsClient) CreateOrUpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, slot string) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateHybridConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateHybridConnectionSlot", err.Error())
	}

	req, err := client.CreateOrUpdateHybridConnectionSlotPreparer(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHybridConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateHybridConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHybridConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateHybridConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateHybridConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateHybridConnectionSlotPreparer prepares the CreateOrUpdateHybridConnectionSlot request.
func (client AppsClient) CreateOrUpdateHybridConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateHybridConnectionSlotSender sends the CreateOrUpdateHybridConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateHybridConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateHybridConnectionSlotResponder handles the response to the CreateOrUpdateHybridConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateHybridConnectionSlotResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdatePublicCertificate creates a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// publicCertificateName - public certificate name.
// publicCertificate - public certificate details. This is the JSON representation of a PublicCertificate
// object.
func (client AppsClient) CreateOrUpdatePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate) (result PublicCertificate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdatePublicCertificate")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdatePublicCertificate", err.Error())
	}

	req, err := client.CreateOrUpdatePublicCertificatePreparer(ctx, resourceGroupName, name, publicCertificateName, publicCertificate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdatePublicCertificate", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdatePublicCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdatePublicCertificate", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdatePublicCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdatePublicCertificate", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdatePublicCertificatePreparer prepares the CreateOrUpdatePublicCertificate request.
func (client AppsClient) CreateOrUpdatePublicCertificatePreparer(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":                  autorest.Encode("path", name),
		"publicCertificateName": autorest.Encode("path", publicCertificateName),
		"resourceGroupName":     autorest.Encode("path", resourceGroupName),
		"subscriptionId":        autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}", pathParameters),
		autorest.WithJSON(publicCertificate),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdatePublicCertificateSender sends the CreateOrUpdatePublicCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdatePublicCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdatePublicCertificateResponder handles the response to the CreateOrUpdatePublicCertificate request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdatePublicCertificateResponder(resp *http.Response) (result PublicCertificate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdatePublicCertificateSlot creates a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// publicCertificateName - public certificate name.
// publicCertificate - public certificate details. This is the JSON representation of a PublicCertificate
// object.
// slot - name of the deployment slot. If a slot is not specified, the API will create a binding for the
// production slot.
func (client AppsClient) CreateOrUpdatePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, slot string) (result PublicCertificate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdatePublicCertificateSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdatePublicCertificateSlot", err.Error())
	}

	req, err := client.CreateOrUpdatePublicCertificateSlotPreparer(ctx, resourceGroupName, name, publicCertificateName, publicCertificate, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdatePublicCertificateSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdatePublicCertificateSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdatePublicCertificateSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdatePublicCertificateSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdatePublicCertificateSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdatePublicCertificateSlotPreparer prepares the CreateOrUpdatePublicCertificateSlot request.
func (client AppsClient) CreateOrUpdatePublicCertificateSlotPreparer(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":                  autorest.Encode("path", name),
		"publicCertificateName": autorest.Encode("path", publicCertificateName),
		"resourceGroupName":     autorest.Encode("path", resourceGroupName),
		"slot":                  autorest.Encode("path", slot),
		"subscriptionId":        autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}", pathParameters),
		autorest.WithJSON(publicCertificate),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdatePublicCertificateSlotSender sends the CreateOrUpdatePublicCertificateSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdatePublicCertificateSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdatePublicCertificateSlotResponder handles the response to the CreateOrUpdatePublicCertificateSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdatePublicCertificateSlotResponder(resp *http.Response) (result PublicCertificate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateRelayServiceConnection creates a new hybrid connection configuration (PUT), or updates an existing one
// (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection configuration.
// connectionEnvelope - details of the hybrid connection configuration.
func (client AppsClient) CreateOrUpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateRelayServiceConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateRelayServiceConnection", err.Error())
	}

	req, err := client.CreateOrUpdateRelayServiceConnectionPreparer(ctx, resourceGroupName, name, entityName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateRelayServiceConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateRelayServiceConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateRelayServiceConnection", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateRelayServiceConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateRelayServiceConnection", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateRelayServiceConnectionPreparer prepares the CreateOrUpdateRelayServiceConnection request.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionPreparer(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateRelayServiceConnectionSender sends the CreateOrUpdateRelayServiceConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateRelayServiceConnectionResponder handles the response to the CreateOrUpdateRelayServiceConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateRelayServiceConnectionSlot creates a new hybrid connection configuration (PUT), or updates an existing
// one (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection configuration.
// connectionEnvelope - details of the hybrid connection configuration.
// slot - name of the deployment slot. If a slot is not specified, the API will create or update a hybrid
// connection for the production slot.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, slot string) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateRelayServiceConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateRelayServiceConnectionSlot", err.Error())
	}

	req, err := client.CreateOrUpdateRelayServiceConnectionSlotPreparer(ctx, resourceGroupName, name, entityName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateRelayServiceConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateRelayServiceConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateRelayServiceConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateRelayServiceConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateRelayServiceConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateRelayServiceConnectionSlotPreparer prepares the CreateOrUpdateRelayServiceConnectionSlot request.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateRelayServiceConnectionSlotSender sends the CreateOrUpdateRelayServiceConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateRelayServiceConnectionSlotResponder handles the response to the CreateOrUpdateRelayServiceConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateRelayServiceConnectionSlotResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateSlot creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - unique name of the app to create or update. To create or update a deployment slot, use the {slot}
// parameter.
// siteEnvelope - a JSON representation of the app properties. See example.
// slot - name of the deployment slot to create or update. By default, this API attempts to create or modify
// the production slot.
func (client AppsClient) CreateOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, slot string) (result AppsCreateOrUpdateSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: siteEnvelope,
			Constraints: []validation.Constraint{{Target: "siteEnvelope.SiteProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.Push", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.Push.PushSettingsProperties", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.Push.PushSettingsProperties.IsPushEnabled", Name: validation.Null, Rule: true, Chain: nil}}},
						}},
						{Target: "siteEnvelope.SiteProperties.SiteConfig.ReservedInstanceCount", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMaximum, Rule: int64(10), Chain: nil},
								{Target: "siteEnvelope.SiteProperties.SiteConfig.ReservedInstanceCount", Name: validation.InclusiveMinimum, Rule: 0, Chain: nil},
							}},
					}},
					{Target: "siteEnvelope.SiteProperties.CloningInfo", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteEnvelope.SiteProperties.CloningInfo.SourceWebAppID", Name: validation.Null, Rule: true, Chain: nil}}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateSlot", err.Error())
	}

	req, err := client.CreateOrUpdateSlotPreparer(ctx, resourceGroupName, name, siteEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateOrUpdateSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateOrUpdateSlotPreparer prepares the CreateOrUpdateSlot request.
func (client AppsClient) CreateOrUpdateSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", pathParameters),
		autorest.WithJSON(siteEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSlotSender sends the CreateOrUpdateSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateSlotSender(req *http.Request) (future AppsCreateOrUpdateSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateOrUpdateSlotResponder handles the response to the CreateOrUpdateSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateSlotResponder(resp *http.Response) (result Site, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateSourceControl updates the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
func (client AppsClient) CreateOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl) (result AppsCreateOrUpdateSourceControlFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateSourceControl")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateSourceControl", err.Error())
	}

	req, err := client.CreateOrUpdateSourceControlPreparer(ctx, resourceGroupName, name, siteSourceControl)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSourceControl", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateOrUpdateSourceControlSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSourceControl", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateOrUpdateSourceControlPreparer prepares the CreateOrUpdateSourceControl request.
func (client AppsClient) CreateOrUpdateSourceControlPreparer(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", pathParameters),
		autorest.WithJSON(siteSourceControl),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSourceControlSender sends the CreateOrUpdateSourceControl request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateSourceControlSender(req *http.Request) (future AppsCreateOrUpdateSourceControlFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateOrUpdateSourceControlResponder handles the response to the CreateOrUpdateSourceControl request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateSourceControlResponder(resp *http.Response) (result SiteSourceControl, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateSourceControlSlot updates the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will update the source control
// configuration for the production slot.
func (client AppsClient) CreateOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, slot string) (result AppsCreateOrUpdateSourceControlSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateSourceControlSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateSourceControlSlot", err.Error())
	}

	req, err := client.CreateOrUpdateSourceControlSlotPreparer(ctx, resourceGroupName, name, siteSourceControl, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSourceControlSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateOrUpdateSourceControlSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSourceControlSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateOrUpdateSourceControlSlotPreparer prepares the CreateOrUpdateSourceControlSlot request.
func (client AppsClient) CreateOrUpdateSourceControlSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", pathParameters),
		autorest.WithJSON(siteSourceControl),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSourceControlSlotSender sends the CreateOrUpdateSourceControlSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateSourceControlSlotSender(req *http.Request) (future AppsCreateOrUpdateSourceControlSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateOrUpdateSourceControlSlotResponder handles the response to the CreateOrUpdateSourceControlSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateSourceControlSlotResponder(resp *http.Response) (result SiteSourceControl, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateSwiftVirtualNetworkConnection integrates this Web App with a Virtual Network. This requires that 1)
// "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not
// in use by another App Service Plan other than the one this App is in.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// connectionEnvelope - properties of the Virtual Network connection. See example.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork) (result SwiftVirtualNetwork, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateSwiftVirtualNetworkConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnection", err.Error())
	}

	req, err := client.CreateOrUpdateSwiftVirtualNetworkConnectionPreparer(ctx, resourceGroupName, name, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateSwiftVirtualNetworkConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnection", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateSwiftVirtualNetworkConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnection", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateSwiftVirtualNetworkConnectionPreparer prepares the CreateOrUpdateSwiftVirtualNetworkConnection request.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionPreparer(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSwiftVirtualNetworkConnectionSender sends the CreateOrUpdateSwiftVirtualNetworkConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateSwiftVirtualNetworkConnectionResponder handles the response to the CreateOrUpdateSwiftVirtualNetworkConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionResponder(resp *http.Response) (result SwiftVirtualNetwork, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateSwiftVirtualNetworkConnectionSlot integrates this Web App with a Virtual Network. This requires that
// 1) "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not
// in use by another App Service Plan other than the one this App is in.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// connectionEnvelope - properties of the Virtual Network connection. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will add or update connections for
// the production slot.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, slot string) (result SwiftVirtualNetwork, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateSwiftVirtualNetworkConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnectionSlot", err.Error())
	}

	req, err := client.CreateOrUpdateSwiftVirtualNetworkConnectionSlotPreparer(ctx, resourceGroupName, name, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateSwiftVirtualNetworkConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateSwiftVirtualNetworkConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateSwiftVirtualNetworkConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateSwiftVirtualNetworkConnectionSlotPreparer prepares the CreateOrUpdateSwiftVirtualNetworkConnectionSlot request.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateSwiftVirtualNetworkConnectionSlotSender sends the CreateOrUpdateSwiftVirtualNetworkConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateSwiftVirtualNetworkConnectionSlotResponder handles the response to the CreateOrUpdateSwiftVirtualNetworkConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionSlotResponder(resp *http.Response) (result SwiftVirtualNetwork, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateVnetConnection adds a Virtual Network connection to an app or slot (PUT) or updates the connection
// properties (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of an existing Virtual Network.
// connectionEnvelope - properties of the Virtual Network connection. See example.
func (client AppsClient) CreateOrUpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo) (result VnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateVnetConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateVnetConnection", err.Error())
	}

	req, err := client.CreateOrUpdateVnetConnectionPreparer(ctx, resourceGroupName, name, vnetName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateVnetConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnection", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateVnetConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnection", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateVnetConnectionPreparer prepares the CreateOrUpdateVnetConnection request.
func (client AppsClient) CreateOrUpdateVnetConnectionPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateVnetConnectionSender sends the CreateOrUpdateVnetConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateVnetConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateVnetConnectionResponder handles the response to the CreateOrUpdateVnetConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateVnetConnectionResponder(resp *http.Response) (result VnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateVnetConnectionGateway adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the Virtual Network.
// gatewayName - name of the gateway. Currently, the only supported string is "primary".
// connectionEnvelope - the properties to update this gateway with.
func (client AppsClient) CreateOrUpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway) (result VnetGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateVnetConnectionGateway")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: connectionEnvelope,
			Constraints: []validation.Constraint{{Target: "connectionEnvelope.VnetGatewayProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "connectionEnvelope.VnetGatewayProperties.VpnPackageURI", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateVnetConnectionGateway", err.Error())
	}

	req, err := client.CreateOrUpdateVnetConnectionGatewayPreparer(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionGateway", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateVnetConnectionGatewaySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionGateway", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateVnetConnectionGatewayResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionGateway", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateVnetConnectionGatewayPreparer prepares the CreateOrUpdateVnetConnectionGateway request.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewayPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayName":       autorest.Encode("path", gatewayName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateVnetConnectionGatewaySender sends the CreateOrUpdateVnetConnectionGateway request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewaySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateVnetConnectionGatewayResponder handles the response to the CreateOrUpdateVnetConnectionGateway request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewayResponder(resp *http.Response) (result VnetGateway, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateVnetConnectionGatewaySlot adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the Virtual Network.
// gatewayName - name of the gateway. Currently, the only supported string is "primary".
// connectionEnvelope - the properties to update this gateway with.
// slot - name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the
// production slot's Virtual Network.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, slot string) (result VnetGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateVnetConnectionGatewaySlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: connectionEnvelope,
			Constraints: []validation.Constraint{{Target: "connectionEnvelope.VnetGatewayProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "connectionEnvelope.VnetGatewayProperties.VpnPackageURI", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateVnetConnectionGatewaySlot", err.Error())
	}

	req, err := client.CreateOrUpdateVnetConnectionGatewaySlotPreparer(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionGatewaySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateVnetConnectionGatewaySlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionGatewaySlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateVnetConnectionGatewaySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionGatewaySlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateVnetConnectionGatewaySlotPreparer prepares the CreateOrUpdateVnetConnectionGatewaySlot request.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewaySlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayName":       autorest.Encode("path", gatewayName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateVnetConnectionGatewaySlotSender sends the CreateOrUpdateVnetConnectionGatewaySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewaySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateVnetConnectionGatewaySlotResponder handles the response to the CreateOrUpdateVnetConnectionGatewaySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateVnetConnectionGatewaySlotResponder(resp *http.Response) (result VnetGateway, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateOrUpdateVnetConnectionSlot adds a Virtual Network connection to an app or slot (PUT) or updates the connection
// properties (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of an existing Virtual Network.
// connectionEnvelope - properties of the Virtual Network connection. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will add or update connections for
// the production slot.
func (client AppsClient) CreateOrUpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, slot string) (result VnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.CreateOrUpdateVnetConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "CreateOrUpdateVnetConnectionSlot", err.Error())
	}

	req, err := client.CreateOrUpdateVnetConnectionSlotPreparer(ctx, resourceGroupName, name, vnetName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateOrUpdateVnetConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.CreateOrUpdateVnetConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "CreateOrUpdateVnetConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// CreateOrUpdateVnetConnectionSlotPreparer prepares the CreateOrUpdateVnetConnectionSlot request.
func (client AppsClient) CreateOrUpdateVnetConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateOrUpdateVnetConnectionSlotSender sends the CreateOrUpdateVnetConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) CreateOrUpdateVnetConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// CreateOrUpdateVnetConnectionSlotResponder handles the response to the CreateOrUpdateVnetConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) CreateOrUpdateVnetConnectionSlotResponder(resp *http.Response) (result VnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete deletes a web, mobile, or API app, or one of the deployment slots.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app to delete.
// deleteMetrics - if true, web app metrics are also deleted.
// deleteEmptyServerFarm - specify true if the App Service plan will be empty after app deletion and you want
// to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
func (client AppsClient) Delete(ctx context.Context, resourceGroupName string, name string, deleteMetrics *bool, deleteEmptyServerFarm *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Delete")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Delete", err.Error())
	}

	req, err := client.DeletePreparer(ctx, resourceGroupName, name, deleteMetrics, deleteEmptyServerFarm)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Delete", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Delete", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Delete", resp, "Failure responding to request")
	}

	return
}

// DeletePreparer prepares the Delete request.
func (client AppsClient) DeletePreparer(ctx context.Context, resourceGroupName string, name string, deleteMetrics *bool, deleteEmptyServerFarm *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if deleteMetrics != nil {
		queryParameters["deleteMetrics"] = autorest.Encode("query", *deleteMetrics)
	}
	if deleteEmptyServerFarm != nil {
		queryParameters["deleteEmptyServerFarm"] = autorest.Encode("query", *deleteEmptyServerFarm)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSender sends the Delete request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteResponder handles the response to the Delete request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteBackup deletes a backup of an app by its ID.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// backupID - ID of the backup.
func (client AppsClient) DeleteBackup(ctx context.Context, resourceGroupName string, name string, backupID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteBackup")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteBackup", err.Error())
	}

	req, err := client.DeleteBackupPreparer(ctx, resourceGroupName, name, backupID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackup", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBackupSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackup", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBackupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackup", resp, "Failure responding to request")
	}

	return
}

// DeleteBackupPreparer prepares the DeleteBackup request.
func (client AppsClient) DeleteBackupPreparer(ctx context.Context, resourceGroupName string, name string, backupID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBackupSender sends the DeleteBackup request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteBackupSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteBackupResponder handles the response to the DeleteBackup request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteBackupResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteBackupConfiguration deletes the backup configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) DeleteBackupConfiguration(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteBackupConfiguration")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteBackupConfiguration", err.Error())
	}

	req, err := client.DeleteBackupConfigurationPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBackupConfigurationSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBackupConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupConfiguration", resp, "Failure responding to request")
	}

	return
}

// DeleteBackupConfigurationPreparer prepares the DeleteBackupConfiguration request.
func (client AppsClient) DeleteBackupConfigurationPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBackupConfigurationSender sends the DeleteBackupConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteBackupConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteBackupConfigurationResponder handles the response to the DeleteBackupConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteBackupConfigurationResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteBackupConfigurationSlot deletes the backup configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the backup configuration
// for the production slot.
func (client AppsClient) DeleteBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteBackupConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteBackupConfigurationSlot", err.Error())
	}

	req, err := client.DeleteBackupConfigurationSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBackupConfigurationSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBackupConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteBackupConfigurationSlotPreparer prepares the DeleteBackupConfigurationSlot request.
func (client AppsClient) DeleteBackupConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBackupConfigurationSlotSender sends the DeleteBackupConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteBackupConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteBackupConfigurationSlotResponder handles the response to the DeleteBackupConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteBackupConfigurationSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteBackupSlot deletes a backup of an app by its ID.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// backupID - ID of the backup.
// slot - name of the deployment slot. If a slot is not specified, the API will delete a backup of the
// production slot.
func (client AppsClient) DeleteBackupSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteBackupSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteBackupSlot", err.Error())
	}

	req, err := client.DeleteBackupSlotPreparer(ctx, resourceGroupName, name, backupID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteBackupSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteBackupSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteBackupSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteBackupSlotPreparer prepares the DeleteBackupSlot request.
func (client AppsClient) DeleteBackupSlotPreparer(ctx context.Context, resourceGroupName string, name string, backupID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteBackupSlotSender sends the DeleteBackupSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteBackupSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteBackupSlotResponder handles the response to the DeleteBackupSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteBackupSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteContinuousWebJob delete a continuous web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) DeleteContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteContinuousWebJob")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteContinuousWebJob", err.Error())
	}

	req, err := client.DeleteContinuousWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteContinuousWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteContinuousWebJobSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteContinuousWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteContinuousWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteContinuousWebJob", resp, "Failure responding to request")
	}

	return
}

// DeleteContinuousWebJobPreparer prepares the DeleteContinuousWebJob request.
func (client AppsClient) DeleteContinuousWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteContinuousWebJobSender sends the DeleteContinuousWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteContinuousWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteContinuousWebJobResponder handles the response to the DeleteContinuousWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteContinuousWebJobResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteContinuousWebJobSlot delete a continuous web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) DeleteContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteContinuousWebJobSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteContinuousWebJobSlot", err.Error())
	}

	req, err := client.DeleteContinuousWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteContinuousWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteContinuousWebJobSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteContinuousWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteContinuousWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteContinuousWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteContinuousWebJobSlotPreparer prepares the DeleteContinuousWebJobSlot request.
func (client AppsClient) DeleteContinuousWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteContinuousWebJobSlotSender sends the DeleteContinuousWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteContinuousWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteContinuousWebJobSlotResponder handles the response to the DeleteContinuousWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteContinuousWebJobSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteDeployment delete a deployment by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - deployment ID.
func (client AppsClient) DeleteDeployment(ctx context.Context, resourceGroupName string, name string, ID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteDeployment")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteDeployment", err.Error())
	}

	req, err := client.DeleteDeploymentPreparer(ctx, resourceGroupName, name, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDeploymentSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDeployment", resp, "Failure responding to request")
	}

	return
}

// DeleteDeploymentPreparer prepares the DeleteDeployment request.
func (client AppsClient) DeleteDeploymentPreparer(ctx context.Context, resourceGroupName string, name string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDeploymentSender sends the DeleteDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteDeploymentResponder handles the response to the DeleteDeployment request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteDeploymentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteDeploymentSlot delete a deployment by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - deployment ID.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) DeleteDeploymentSlot(ctx context.Context, resourceGroupName string, name string, ID string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteDeploymentSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteDeploymentSlot", err.Error())
	}

	req, err := client.DeleteDeploymentSlotPreparer(ctx, resourceGroupName, name, ID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDeploymentSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDeploymentSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDeploymentSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDeploymentSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDeploymentSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteDeploymentSlotPreparer prepares the DeleteDeploymentSlot request.
func (client AppsClient) DeleteDeploymentSlotPreparer(ctx context.Context, resourceGroupName string, name string, ID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDeploymentSlotSender sends the DeleteDeploymentSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteDeploymentSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteDeploymentSlotResponder handles the response to the DeleteDeploymentSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteDeploymentSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteDomainOwnershipIdentifier deletes a domain ownership identifier for a web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
func (client AppsClient) DeleteDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteDomainOwnershipIdentifier")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteDomainOwnershipIdentifier", err.Error())
	}

	req, err := client.DeleteDomainOwnershipIdentifierPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDomainOwnershipIdentifier", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDomainOwnershipIdentifierSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDomainOwnershipIdentifier", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDomainOwnershipIdentifierResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDomainOwnershipIdentifier", resp, "Failure responding to request")
	}

	return
}

// DeleteDomainOwnershipIdentifierPreparer prepares the DeleteDomainOwnershipIdentifier request.
func (client AppsClient) DeleteDomainOwnershipIdentifierPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDomainOwnershipIdentifierSender sends the DeleteDomainOwnershipIdentifier request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteDomainOwnershipIdentifierSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteDomainOwnershipIdentifierResponder handles the response to the DeleteDomainOwnershipIdentifier request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteDomainOwnershipIdentifierResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteDomainOwnershipIdentifierSlot deletes a domain ownership identifier for a web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
func (client AppsClient) DeleteDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteDomainOwnershipIdentifierSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteDomainOwnershipIdentifierSlot", err.Error())
	}

	req, err := client.DeleteDomainOwnershipIdentifierSlotPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDomainOwnershipIdentifierSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDomainOwnershipIdentifierSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDomainOwnershipIdentifierSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDomainOwnershipIdentifierSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteDomainOwnershipIdentifierSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteDomainOwnershipIdentifierSlotPreparer prepares the DeleteDomainOwnershipIdentifierSlot request.
func (client AppsClient) DeleteDomainOwnershipIdentifierSlotPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"slot":                          autorest.Encode("path", slot),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDomainOwnershipIdentifierSlotSender sends the DeleteDomainOwnershipIdentifierSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteDomainOwnershipIdentifierSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteDomainOwnershipIdentifierSlotResponder handles the response to the DeleteDomainOwnershipIdentifierSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteDomainOwnershipIdentifierSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteFunction delete a function for web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
func (client AppsClient) DeleteFunction(ctx context.Context, resourceGroupName string, name string, functionName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteFunction")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteFunction", err.Error())
	}

	req, err := client.DeleteFunctionPreparer(ctx, resourceGroupName, name, functionName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteFunction", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteFunctionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteFunction", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteFunctionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteFunction", resp, "Failure responding to request")
	}

	return
}

// DeleteFunctionPreparer prepares the DeleteFunction request.
func (client AppsClient) DeleteFunctionPreparer(ctx context.Context, resourceGroupName string, name string, functionName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteFunctionSender sends the DeleteFunction request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteFunctionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteFunctionResponder handles the response to the DeleteFunction request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteFunctionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteHostNameBinding deletes a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// hostName - hostname in the hostname binding.
func (client AppsClient) DeleteHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteHostNameBinding")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteHostNameBinding", err.Error())
	}

	req, err := client.DeleteHostNameBindingPreparer(ctx, resourceGroupName, name, hostName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHostNameBinding", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteHostNameBindingSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHostNameBinding", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteHostNameBindingResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHostNameBinding", resp, "Failure responding to request")
	}

	return
}

// DeleteHostNameBindingPreparer prepares the DeleteHostNameBinding request.
func (client AppsClient) DeleteHostNameBindingPreparer(ctx context.Context, resourceGroupName string, name string, hostName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"hostName":          autorest.Encode("path", hostName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteHostNameBindingSender sends the DeleteHostNameBinding request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteHostNameBindingSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteHostNameBindingResponder handles the response to the DeleteHostNameBinding request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteHostNameBindingResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteHostNameBindingSlot deletes a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
// hostName - hostname in the hostname binding.
func (client AppsClient) DeleteHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteHostNameBindingSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteHostNameBindingSlot", err.Error())
	}

	req, err := client.DeleteHostNameBindingSlotPreparer(ctx, resourceGroupName, name, slot, hostName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHostNameBindingSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteHostNameBindingSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHostNameBindingSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteHostNameBindingSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHostNameBindingSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteHostNameBindingSlotPreparer prepares the DeleteHostNameBindingSlot request.
func (client AppsClient) DeleteHostNameBindingSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, hostName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"hostName":          autorest.Encode("path", hostName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteHostNameBindingSlotSender sends the DeleteHostNameBindingSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteHostNameBindingSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteHostNameBindingSlotResponder handles the response to the DeleteHostNameBindingSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteHostNameBindingSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteHybridConnection removes a Hybrid Connection from this site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
func (client AppsClient) DeleteHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteHybridConnection")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteHybridConnection", err.Error())
	}

	req, err := client.DeleteHybridConnectionPreparer(ctx, resourceGroupName, name, namespaceName, relayName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHybridConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteHybridConnectionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHybridConnection", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteHybridConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHybridConnection", resp, "Failure responding to request")
	}

	return
}

// DeleteHybridConnectionPreparer prepares the DeleteHybridConnection request.
func (client AppsClient) DeleteHybridConnectionPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteHybridConnectionSender sends the DeleteHybridConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteHybridConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteHybridConnectionResponder handles the response to the DeleteHybridConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteHybridConnectionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteHybridConnectionSlot removes a Hybrid Connection from this site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// slot - the name of the slot for the web app.
func (client AppsClient) DeleteHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteHybridConnectionSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteHybridConnectionSlot", err.Error())
	}

	req, err := client.DeleteHybridConnectionSlotPreparer(ctx, resourceGroupName, name, namespaceName, relayName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHybridConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteHybridConnectionSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHybridConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteHybridConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteHybridConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteHybridConnectionSlotPreparer prepares the DeleteHybridConnectionSlot request.
func (client AppsClient) DeleteHybridConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteHybridConnectionSlotSender sends the DeleteHybridConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteHybridConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteHybridConnectionSlotResponder handles the response to the DeleteHybridConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteHybridConnectionSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteInstanceFunctionSlot delete a function for web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) DeleteInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteInstanceFunctionSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteInstanceFunctionSlot", err.Error())
	}

	req, err := client.DeleteInstanceFunctionSlotPreparer(ctx, resourceGroupName, name, functionName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceFunctionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteInstanceFunctionSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceFunctionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteInstanceFunctionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceFunctionSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteInstanceFunctionSlotPreparer prepares the DeleteInstanceFunctionSlot request.
func (client AppsClient) DeleteInstanceFunctionSlotPreparer(ctx context.Context, resourceGroupName string, name string, functionName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteInstanceFunctionSlotSender sends the DeleteInstanceFunctionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteInstanceFunctionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteInstanceFunctionSlotResponder handles the response to the DeleteInstanceFunctionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteInstanceFunctionSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteInstanceProcess terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) DeleteInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteInstanceProcess")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteInstanceProcess", err.Error())
	}

	req, err := client.DeleteInstanceProcessPreparer(ctx, resourceGroupName, name, processID, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceProcess", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteInstanceProcessSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceProcess", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteInstanceProcessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceProcess", resp, "Failure responding to request")
	}

	return
}

// DeleteInstanceProcessPreparer prepares the DeleteInstanceProcess request.
func (client AppsClient) DeleteInstanceProcessPreparer(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteInstanceProcessSender sends the DeleteInstanceProcess request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteInstanceProcessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteInstanceProcessResponder handles the response to the DeleteInstanceProcess request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteInstanceProcessResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteInstanceProcessSlot terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) DeleteInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteInstanceProcessSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteInstanceProcessSlot", err.Error())
	}

	req, err := client.DeleteInstanceProcessSlotPreparer(ctx, resourceGroupName, name, processID, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceProcessSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteInstanceProcessSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceProcessSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteInstanceProcessSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteInstanceProcessSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteInstanceProcessSlotPreparer prepares the DeleteInstanceProcessSlot request.
func (client AppsClient) DeleteInstanceProcessSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteInstanceProcessSlotSender sends the DeleteInstanceProcessSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteInstanceProcessSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteInstanceProcessSlotResponder handles the response to the DeleteInstanceProcessSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteInstanceProcessSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeletePremierAddOn delete a premier add-on from an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
func (client AppsClient) DeletePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeletePremierAddOn")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeletePremierAddOn", err.Error())
	}

	req, err := client.DeletePremierAddOnPreparer(ctx, resourceGroupName, name, premierAddOnName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePremierAddOn", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeletePremierAddOnSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePremierAddOn", resp, "Failure sending request")
		return
	}

	result, err = client.DeletePremierAddOnResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePremierAddOn", resp, "Failure responding to request")
	}

	return
}

// DeletePremierAddOnPreparer prepares the DeletePremierAddOn request.
func (client AppsClient) DeletePremierAddOnPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeletePremierAddOnSender sends the DeletePremierAddOn request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeletePremierAddOnSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeletePremierAddOnResponder handles the response to the DeletePremierAddOn request. The method always
// closes the http.Response Body.
func (client AppsClient) DeletePremierAddOnResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeletePremierAddOnSlot delete a premier add-on from an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the named add-on for the
// production slot.
func (client AppsClient) DeletePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeletePremierAddOnSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeletePremierAddOnSlot", err.Error())
	}

	req, err := client.DeletePremierAddOnSlotPreparer(ctx, resourceGroupName, name, premierAddOnName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePremierAddOnSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeletePremierAddOnSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePremierAddOnSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeletePremierAddOnSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePremierAddOnSlot", resp, "Failure responding to request")
	}

	return
}

// DeletePremierAddOnSlotPreparer prepares the DeletePremierAddOnSlot request.
func (client AppsClient) DeletePremierAddOnSlotPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeletePremierAddOnSlotSender sends the DeletePremierAddOnSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeletePremierAddOnSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeletePremierAddOnSlotResponder handles the response to the DeletePremierAddOnSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeletePremierAddOnSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteProcess terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in
// a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
func (client AppsClient) DeleteProcess(ctx context.Context, resourceGroupName string, name string, processID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteProcess")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteProcess", err.Error())
	}

	req, err := client.DeleteProcessPreparer(ctx, resourceGroupName, name, processID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteProcess", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteProcessSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteProcess", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteProcessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteProcess", resp, "Failure responding to request")
	}

	return
}

// DeleteProcessPreparer prepares the DeleteProcess request.
func (client AppsClient) DeleteProcessPreparer(ctx context.Context, resourceGroupName string, name string, processID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteProcessSender sends the DeleteProcess request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteProcessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteProcessResponder handles the response to the DeleteProcess request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteProcessResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteProcessSlot terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) DeleteProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteProcessSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteProcessSlot", err.Error())
	}

	req, err := client.DeleteProcessSlotPreparer(ctx, resourceGroupName, name, processID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteProcessSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteProcessSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteProcessSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteProcessSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteProcessSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteProcessSlotPreparer prepares the DeleteProcessSlot request.
func (client AppsClient) DeleteProcessSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteProcessSlotSender sends the DeleteProcessSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteProcessSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteProcessSlotResponder handles the response to the DeleteProcessSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteProcessSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeletePublicCertificate deletes a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// publicCertificateName - public certificate name.
func (client AppsClient) DeletePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeletePublicCertificate")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeletePublicCertificate", err.Error())
	}

	req, err := client.DeletePublicCertificatePreparer(ctx, resourceGroupName, name, publicCertificateName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePublicCertificate", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeletePublicCertificateSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePublicCertificate", resp, "Failure sending request")
		return
	}

	result, err = client.DeletePublicCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePublicCertificate", resp, "Failure responding to request")
	}

	return
}

// DeletePublicCertificatePreparer prepares the DeletePublicCertificate request.
func (client AppsClient) DeletePublicCertificatePreparer(ctx context.Context, resourceGroupName string, name string, publicCertificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":                  autorest.Encode("path", name),
		"publicCertificateName": autorest.Encode("path", publicCertificateName),
		"resourceGroupName":     autorest.Encode("path", resourceGroupName),
		"subscriptionId":        autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeletePublicCertificateSender sends the DeletePublicCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeletePublicCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeletePublicCertificateResponder handles the response to the DeletePublicCertificate request. The method always
// closes the http.Response Body.
func (client AppsClient) DeletePublicCertificateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeletePublicCertificateSlot deletes a hostname binding for an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
// publicCertificateName - public certificate name.
func (client AppsClient) DeletePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeletePublicCertificateSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeletePublicCertificateSlot", err.Error())
	}

	req, err := client.DeletePublicCertificateSlotPreparer(ctx, resourceGroupName, name, slot, publicCertificateName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePublicCertificateSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeletePublicCertificateSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePublicCertificateSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeletePublicCertificateSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeletePublicCertificateSlot", resp, "Failure responding to request")
	}

	return
}

// DeletePublicCertificateSlotPreparer prepares the DeletePublicCertificateSlot request.
func (client AppsClient) DeletePublicCertificateSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":                  autorest.Encode("path", name),
		"publicCertificateName": autorest.Encode("path", publicCertificateName),
		"resourceGroupName":     autorest.Encode("path", resourceGroupName),
		"slot":                  autorest.Encode("path", slot),
		"subscriptionId":        autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeletePublicCertificateSlotSender sends the DeletePublicCertificateSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeletePublicCertificateSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeletePublicCertificateSlotResponder handles the response to the DeletePublicCertificateSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeletePublicCertificateSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteRelayServiceConnection deletes a relay service connection by its name.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection configuration.
func (client AppsClient) DeleteRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteRelayServiceConnection")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteRelayServiceConnection", err.Error())
	}

	req, err := client.DeleteRelayServiceConnectionPreparer(ctx, resourceGroupName, name, entityName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteRelayServiceConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteRelayServiceConnectionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteRelayServiceConnection", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteRelayServiceConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteRelayServiceConnection", resp, "Failure responding to request")
	}

	return
}

// DeleteRelayServiceConnectionPreparer prepares the DeleteRelayServiceConnection request.
func (client AppsClient) DeleteRelayServiceConnectionPreparer(ctx context.Context, resourceGroupName string, name string, entityName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteRelayServiceConnectionSender sends the DeleteRelayServiceConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteRelayServiceConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteRelayServiceConnectionResponder handles the response to the DeleteRelayServiceConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteRelayServiceConnectionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteRelayServiceConnectionSlot deletes a relay service connection by its name.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection configuration.
// slot - name of the deployment slot. If a slot is not specified, the API will delete a hybrid connection for
// the production slot.
func (client AppsClient) DeleteRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteRelayServiceConnectionSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteRelayServiceConnectionSlot", err.Error())
	}

	req, err := client.DeleteRelayServiceConnectionSlotPreparer(ctx, resourceGroupName, name, entityName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteRelayServiceConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteRelayServiceConnectionSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteRelayServiceConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteRelayServiceConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteRelayServiceConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteRelayServiceConnectionSlotPreparer prepares the DeleteRelayServiceConnectionSlot request.
func (client AppsClient) DeleteRelayServiceConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, entityName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteRelayServiceConnectionSlotSender sends the DeleteRelayServiceConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteRelayServiceConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteRelayServiceConnectionSlotResponder handles the response to the DeleteRelayServiceConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteRelayServiceConnectionSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSiteExtension remove a site extension from a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// siteExtensionID - site extension name.
func (client AppsClient) DeleteSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSiteExtension")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSiteExtension", err.Error())
	}

	req, err := client.DeleteSiteExtensionPreparer(ctx, resourceGroupName, name, siteExtensionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSiteExtension", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSiteExtensionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSiteExtension", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSiteExtensionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSiteExtension", resp, "Failure responding to request")
	}

	return
}

// DeleteSiteExtensionPreparer prepares the DeleteSiteExtension request.
func (client AppsClient) DeleteSiteExtensionPreparer(ctx context.Context, resourceGroupName string, name string, siteExtensionID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"siteExtensionId":   autorest.Encode("path", siteExtensionID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSiteExtensionSender sends the DeleteSiteExtension request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSiteExtensionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSiteExtensionResponder handles the response to the DeleteSiteExtension request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSiteExtensionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSiteExtensionSlot remove a site extension from a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// siteExtensionID - site extension name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) DeleteSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSiteExtensionSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSiteExtensionSlot", err.Error())
	}

	req, err := client.DeleteSiteExtensionSlotPreparer(ctx, resourceGroupName, name, siteExtensionID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSiteExtensionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSiteExtensionSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSiteExtensionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSiteExtensionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSiteExtensionSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteSiteExtensionSlotPreparer prepares the DeleteSiteExtensionSlot request.
func (client AppsClient) DeleteSiteExtensionSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"siteExtensionId":   autorest.Encode("path", siteExtensionID),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSiteExtensionSlotSender sends the DeleteSiteExtensionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSiteExtensionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSiteExtensionSlotResponder handles the response to the DeleteSiteExtensionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSiteExtensionSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSlot deletes a web, mobile, or API app, or one of the deployment slots.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app to delete.
// slot - name of the deployment slot to delete. By default, the API deletes the production slot.
// deleteMetrics - if true, web app metrics are also deleted.
// deleteEmptyServerFarm - specify true if the App Service plan will be empty after app deletion and you want
// to delete the empty App Service plan. By default, the empty App Service plan is not deleted.
func (client AppsClient) DeleteSlot(ctx context.Context, resourceGroupName string, name string, slot string, deleteMetrics *bool, deleteEmptyServerFarm *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSlot", err.Error())
	}

	req, err := client.DeleteSlotPreparer(ctx, resourceGroupName, name, slot, deleteMetrics, deleteEmptyServerFarm)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteSlotPreparer prepares the DeleteSlot request.
func (client AppsClient) DeleteSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, deleteMetrics *bool, deleteEmptyServerFarm *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if deleteMetrics != nil {
		queryParameters["deleteMetrics"] = autorest.Encode("query", *deleteMetrics)
	}
	if deleteEmptyServerFarm != nil {
		queryParameters["deleteEmptyServerFarm"] = autorest.Encode("query", *deleteEmptyServerFarm)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSlotSender sends the DeleteSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSlotResponder handles the response to the DeleteSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSourceControl deletes the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) DeleteSourceControl(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSourceControl")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSourceControl", err.Error())
	}

	req, err := client.DeleteSourceControlPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSourceControl", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSourceControlSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSourceControl", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSourceControlResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSourceControl", resp, "Failure responding to request")
	}

	return
}

// DeleteSourceControlPreparer prepares the DeleteSourceControl request.
func (client AppsClient) DeleteSourceControlPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSourceControlSender sends the DeleteSourceControl request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSourceControlSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSourceControlResponder handles the response to the DeleteSourceControl request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSourceControlResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSourceControlSlot deletes the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the source control
// configuration for the production slot.
func (client AppsClient) DeleteSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSourceControlSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSourceControlSlot", err.Error())
	}

	req, err := client.DeleteSourceControlSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSourceControlSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSourceControlSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSourceControlSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSourceControlSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSourceControlSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteSourceControlSlotPreparer prepares the DeleteSourceControlSlot request.
func (client AppsClient) DeleteSourceControlSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSourceControlSlotSender sends the DeleteSourceControlSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSourceControlSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSourceControlSlotResponder handles the response to the DeleteSourceControlSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSourceControlSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSwiftVirtualNetwork deletes a Swift Virtual Network connection from an app (or deployment slot).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) DeleteSwiftVirtualNetwork(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSwiftVirtualNetwork")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSwiftVirtualNetwork", err.Error())
	}

	req, err := client.DeleteSwiftVirtualNetworkPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSwiftVirtualNetwork", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSwiftVirtualNetworkSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSwiftVirtualNetwork", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSwiftVirtualNetworkResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSwiftVirtualNetwork", resp, "Failure responding to request")
	}

	return
}

// DeleteSwiftVirtualNetworkPreparer prepares the DeleteSwiftVirtualNetwork request.
func (client AppsClient) DeleteSwiftVirtualNetworkPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSwiftVirtualNetworkSender sends the DeleteSwiftVirtualNetwork request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSwiftVirtualNetworkSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSwiftVirtualNetworkResponder handles the response to the DeleteSwiftVirtualNetwork request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSwiftVirtualNetworkResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSwiftVirtualNetworkSlot deletes a Swift Virtual Network connection from an app (or deployment slot).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the connection for the
// production slot.
func (client AppsClient) DeleteSwiftVirtualNetworkSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteSwiftVirtualNetworkSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteSwiftVirtualNetworkSlot", err.Error())
	}

	req, err := client.DeleteSwiftVirtualNetworkSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSwiftVirtualNetworkSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteSwiftVirtualNetworkSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSwiftVirtualNetworkSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteSwiftVirtualNetworkSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteSwiftVirtualNetworkSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteSwiftVirtualNetworkSlotPreparer prepares the DeleteSwiftVirtualNetworkSlot request.
func (client AppsClient) DeleteSwiftVirtualNetworkSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSwiftVirtualNetworkSlotSender sends the DeleteSwiftVirtualNetworkSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteSwiftVirtualNetworkSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteSwiftVirtualNetworkSlotResponder handles the response to the DeleteSwiftVirtualNetworkSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteSwiftVirtualNetworkSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteTriggeredWebJob delete a triggered web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) DeleteTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteTriggeredWebJob")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteTriggeredWebJob", err.Error())
	}

	req, err := client.DeleteTriggeredWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteTriggeredWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteTriggeredWebJobSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteTriggeredWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteTriggeredWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteTriggeredWebJob", resp, "Failure responding to request")
	}

	return
}

// DeleteTriggeredWebJobPreparer prepares the DeleteTriggeredWebJob request.
func (client AppsClient) DeleteTriggeredWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteTriggeredWebJobSender sends the DeleteTriggeredWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteTriggeredWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteTriggeredWebJobResponder handles the response to the DeleteTriggeredWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteTriggeredWebJobResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteTriggeredWebJobSlot delete a triggered web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) DeleteTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteTriggeredWebJobSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteTriggeredWebJobSlot", err.Error())
	}

	req, err := client.DeleteTriggeredWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteTriggeredWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteTriggeredWebJobSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteTriggeredWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteTriggeredWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteTriggeredWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteTriggeredWebJobSlotPreparer prepares the DeleteTriggeredWebJobSlot request.
func (client AppsClient) DeleteTriggeredWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteTriggeredWebJobSlotSender sends the DeleteTriggeredWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteTriggeredWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteTriggeredWebJobSlotResponder handles the response to the DeleteTriggeredWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteTriggeredWebJobSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteVnetConnection deletes a connection from an app (or deployment slot to a named virtual network.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the virtual network.
func (client AppsClient) DeleteVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteVnetConnection")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteVnetConnection", err.Error())
	}

	req, err := client.DeleteVnetConnectionPreparer(ctx, resourceGroupName, name, vnetName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteVnetConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteVnetConnectionSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteVnetConnection", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteVnetConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteVnetConnection", resp, "Failure responding to request")
	}

	return
}

// DeleteVnetConnectionPreparer prepares the DeleteVnetConnection request.
func (client AppsClient) DeleteVnetConnectionPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteVnetConnectionSender sends the DeleteVnetConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteVnetConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteVnetConnectionResponder handles the response to the DeleteVnetConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteVnetConnectionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteVnetConnectionSlot deletes a connection from an app (or deployment slot to a named virtual network.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the virtual network.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the connection for the
// production slot.
func (client AppsClient) DeleteVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DeleteVnetConnectionSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DeleteVnetConnectionSlot", err.Error())
	}

	req, err := client.DeleteVnetConnectionSlotPreparer(ctx, resourceGroupName, name, vnetName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteVnetConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteVnetConnectionSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteVnetConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteVnetConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DeleteVnetConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// DeleteVnetConnectionSlotPreparer prepares the DeleteVnetConnectionSlot request.
func (client AppsClient) DeleteVnetConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteVnetConnectionSlotSender sends the DeleteVnetConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DeleteVnetConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DeleteVnetConnectionSlotResponder handles the response to the DeleteVnetConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DeleteVnetConnectionSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DiscoverBackup discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get
// information about the databases stored in a backup.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - a RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
func (client AppsClient) DiscoverBackup(ctx context.Context, resourceGroupName string, name string, request RestoreRequest) (result RestoreRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DiscoverBackup")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.RestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.RestoreRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.RestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DiscoverBackup", err.Error())
	}

	req, err := client.DiscoverBackupPreparer(ctx, resourceGroupName, name, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DiscoverBackup", nil, "Failure preparing request")
		return
	}

	resp, err := client.DiscoverBackupSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DiscoverBackup", resp, "Failure sending request")
		return
	}

	result, err = client.DiscoverBackupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DiscoverBackup", resp, "Failure responding to request")
	}

	return
}

// DiscoverBackupPreparer prepares the DiscoverBackup request.
func (client AppsClient) DiscoverBackupPreparer(ctx context.Context, resourceGroupName string, name string, request RestoreRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DiscoverBackupSender sends the DiscoverBackup request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DiscoverBackupSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DiscoverBackupResponder handles the response to the DiscoverBackup request. The method always
// closes the http.Response Body.
func (client AppsClient) DiscoverBackupResponder(resp *http.Response) (result RestoreRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DiscoverBackupSlot discovers an existing app backup that can be restored from a blob in Azure storage. Use this to
// get information about the databases stored in a backup.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - a RestoreRequest object that includes Azure storage URL and blog name for discovery of backup.
// slot - name of the deployment slot. If a slot is not specified, the API will perform discovery for the
// production slot.
func (client AppsClient) DiscoverBackupSlot(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, slot string) (result RestoreRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.DiscoverBackupSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.RestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.RestoreRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.RestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "DiscoverBackupSlot", err.Error())
	}

	req, err := client.DiscoverBackupSlotPreparer(ctx, resourceGroupName, name, request, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DiscoverBackupSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.DiscoverBackupSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DiscoverBackupSlot", resp, "Failure sending request")
		return
	}

	result, err = client.DiscoverBackupSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "DiscoverBackupSlot", resp, "Failure responding to request")
	}

	return
}

// DiscoverBackupSlotPreparer prepares the DiscoverBackupSlot request.
func (client AppsClient) DiscoverBackupSlotPreparer(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DiscoverBackupSlotSender sends the DiscoverBackupSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) DiscoverBackupSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// DiscoverBackupSlotResponder handles the response to the DiscoverBackupSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) DiscoverBackupSlotResponder(resp *http.Response) (result RestoreRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GenerateNewSitePublishingPassword generates a new publishing password for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GenerateNewSitePublishingPassword(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GenerateNewSitePublishingPassword")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GenerateNewSitePublishingPassword", err.Error())
	}

	req, err := client.GenerateNewSitePublishingPasswordPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GenerateNewSitePublishingPassword", nil, "Failure preparing request")
		return
	}

	resp, err := client.GenerateNewSitePublishingPasswordSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GenerateNewSitePublishingPassword", resp, "Failure sending request")
		return
	}

	result, err = client.GenerateNewSitePublishingPasswordResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GenerateNewSitePublishingPassword", resp, "Failure responding to request")
	}

	return
}

// GenerateNewSitePublishingPasswordPreparer prepares the GenerateNewSitePublishingPassword request.
func (client AppsClient) GenerateNewSitePublishingPasswordPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GenerateNewSitePublishingPasswordSender sends the GenerateNewSitePublishingPassword request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GenerateNewSitePublishingPasswordSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GenerateNewSitePublishingPasswordResponder handles the response to the GenerateNewSitePublishingPassword request. The method always
// closes the http.Response Body.
func (client AppsClient) GenerateNewSitePublishingPasswordResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GenerateNewSitePublishingPasswordSlot generates a new publishing password for an app (or deployment slot, if
// specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API generate a new publishing password
// for the production slot.
func (client AppsClient) GenerateNewSitePublishingPasswordSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GenerateNewSitePublishingPasswordSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GenerateNewSitePublishingPasswordSlot", err.Error())
	}

	req, err := client.GenerateNewSitePublishingPasswordSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GenerateNewSitePublishingPasswordSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GenerateNewSitePublishingPasswordSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GenerateNewSitePublishingPasswordSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GenerateNewSitePublishingPasswordSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GenerateNewSitePublishingPasswordSlot", resp, "Failure responding to request")
	}

	return
}

// GenerateNewSitePublishingPasswordSlotPreparer prepares the GenerateNewSitePublishingPasswordSlot request.
func (client AppsClient) GenerateNewSitePublishingPasswordSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GenerateNewSitePublishingPasswordSlotSender sends the GenerateNewSitePublishingPasswordSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GenerateNewSitePublishingPasswordSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GenerateNewSitePublishingPasswordSlotResponder handles the response to the GenerateNewSitePublishingPasswordSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GenerateNewSitePublishingPasswordSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Get gets the details of a web, mobile, or API app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) Get(ctx context.Context, resourceGroupName string, name string) (result Site, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Get")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Get", err.Error())
	}

	req, err := client.GetPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Get", resp, "Failure responding to request")
	}

	return
}

// GetPreparer prepares the Get request.
func (client AppsClient) GetPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client AppsClient) GetResponder(resp *http.Response) (result Site, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAuthSettings gets the Authentication/Authorization settings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GetAuthSettings(ctx context.Context, resourceGroupName string, name string) (result SiteAuthSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetAuthSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetAuthSettings", err.Error())
	}

	req, err := client.GetAuthSettingsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetAuthSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAuthSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetAuthSettings", resp, "Failure sending request")
		return
	}

	result, err = client.GetAuthSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetAuthSettings", resp, "Failure responding to request")
	}

	return
}

// GetAuthSettingsPreparer prepares the GetAuthSettings request.
func (client AppsClient) GetAuthSettingsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAuthSettingsSender sends the GetAuthSettings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetAuthSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetAuthSettingsResponder handles the response to the GetAuthSettings request. The method always
// closes the http.Response Body.
func (client AppsClient) GetAuthSettingsResponder(resp *http.Response) (result SiteAuthSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAuthSettingsSlot gets the Authentication/Authorization settings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the settings for the
// production slot.
func (client AppsClient) GetAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteAuthSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetAuthSettingsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetAuthSettingsSlot", err.Error())
	}

	req, err := client.GetAuthSettingsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetAuthSettingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAuthSettingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetAuthSettingsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetAuthSettingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetAuthSettingsSlot", resp, "Failure responding to request")
	}

	return
}

// GetAuthSettingsSlotPreparer prepares the GetAuthSettingsSlot request.
func (client AppsClient) GetAuthSettingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAuthSettingsSlotSender sends the GetAuthSettingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetAuthSettingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetAuthSettingsSlotResponder handles the response to the GetAuthSettingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetAuthSettingsSlotResponder(resp *http.Response) (result SiteAuthSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBackupConfiguration gets the backup configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GetBackupConfiguration(ctx context.Context, resourceGroupName string, name string) (result BackupRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetBackupConfiguration")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetBackupConfiguration", err.Error())
	}

	req, err := client.GetBackupConfigurationPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBackupConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.GetBackupConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupConfiguration", resp, "Failure responding to request")
	}

	return
}

// GetBackupConfigurationPreparer prepares the GetBackupConfiguration request.
func (client AppsClient) GetBackupConfigurationPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBackupConfigurationSender sends the GetBackupConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetBackupConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetBackupConfigurationResponder handles the response to the GetBackupConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) GetBackupConfigurationResponder(resp *http.Response) (result BackupRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBackupConfigurationSlot gets the backup configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the backup configuration
// for the production slot.
func (client AppsClient) GetBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result BackupRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetBackupConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetBackupConfigurationSlot", err.Error())
	}

	req, err := client.GetBackupConfigurationSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBackupConfigurationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetBackupConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// GetBackupConfigurationSlotPreparer prepares the GetBackupConfigurationSlot request.
func (client AppsClient) GetBackupConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBackupConfigurationSlotSender sends the GetBackupConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetBackupConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetBackupConfigurationSlotResponder handles the response to the GetBackupConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetBackupConfigurationSlotResponder(resp *http.Response) (result BackupRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBackupStatus gets a backup of an app by its ID.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// backupID - ID of the backup.
func (client AppsClient) GetBackupStatus(ctx context.Context, resourceGroupName string, name string, backupID string) (result BackupItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetBackupStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetBackupStatus", err.Error())
	}

	req, err := client.GetBackupStatusPreparer(ctx, resourceGroupName, name, backupID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBackupStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetBackupStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupStatus", resp, "Failure responding to request")
	}

	return
}

// GetBackupStatusPreparer prepares the GetBackupStatus request.
func (client AppsClient) GetBackupStatusPreparer(ctx context.Context, resourceGroupName string, name string, backupID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBackupStatusSender sends the GetBackupStatus request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetBackupStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetBackupStatusResponder handles the response to the GetBackupStatus request. The method always
// closes the http.Response Body.
func (client AppsClient) GetBackupStatusResponder(resp *http.Response) (result BackupItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetBackupStatusSlot gets a backup of an app by its ID.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// backupID - ID of the backup.
// slot - name of the deployment slot. If a slot is not specified, the API will get a backup of the production
// slot.
func (client AppsClient) GetBackupStatusSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string) (result BackupItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetBackupStatusSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetBackupStatusSlot", err.Error())
	}

	req, err := client.GetBackupStatusSlotPreparer(ctx, resourceGroupName, name, backupID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupStatusSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetBackupStatusSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupStatusSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetBackupStatusSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetBackupStatusSlot", resp, "Failure responding to request")
	}

	return
}

// GetBackupStatusSlotPreparer prepares the GetBackupStatusSlot request.
func (client AppsClient) GetBackupStatusSlotPreparer(ctx context.Context, resourceGroupName string, name string, backupID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetBackupStatusSlotSender sends the GetBackupStatusSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetBackupStatusSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetBackupStatusSlotResponder handles the response to the GetBackupStatusSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetBackupStatusSlotResponder(resp *http.Response) (result BackupItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetConfiguration gets the configuration of an app, such as platform version and bitness, default documents, virtual
// applications, Always On, etc.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GetConfiguration(ctx context.Context, resourceGroupName string, name string) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetConfiguration")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetConfiguration", err.Error())
	}

	req, err := client.GetConfigurationPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.GetConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfiguration", resp, "Failure responding to request")
	}

	return
}

// GetConfigurationPreparer prepares the GetConfiguration request.
func (client AppsClient) GetConfigurationPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetConfigurationSender sends the GetConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetConfigurationResponder handles the response to the GetConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) GetConfigurationResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetConfigurationSlot gets the configuration of an app, such as platform version and bitness, default documents,
// virtual applications, Always On, etc.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will return configuration for the
// production slot.
func (client AppsClient) GetConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetConfigurationSlot", err.Error())
	}

	req, err := client.GetConfigurationSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetConfigurationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// GetConfigurationSlotPreparer prepares the GetConfigurationSlot request.
func (client AppsClient) GetConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetConfigurationSlotSender sends the GetConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetConfigurationSlotResponder handles the response to the GetConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetConfigurationSlotResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetConfigurationSnapshot gets a snapshot of the configuration of an app at a previous point in time.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// snapshotID - the ID of the snapshot to read.
func (client AppsClient) GetConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetConfigurationSnapshot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetConfigurationSnapshot", err.Error())
	}

	req, err := client.GetConfigurationSnapshotPreparer(ctx, resourceGroupName, name, snapshotID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSnapshot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetConfigurationSnapshotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSnapshot", resp, "Failure sending request")
		return
	}

	result, err = client.GetConfigurationSnapshotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSnapshot", resp, "Failure responding to request")
	}

	return
}

// GetConfigurationSnapshotPreparer prepares the GetConfigurationSnapshot request.
func (client AppsClient) GetConfigurationSnapshotPreparer(ctx context.Context, resourceGroupName string, name string, snapshotID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"snapshotId":        autorest.Encode("path", snapshotID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetConfigurationSnapshotSender sends the GetConfigurationSnapshot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetConfigurationSnapshotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetConfigurationSnapshotResponder handles the response to the GetConfigurationSnapshot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetConfigurationSnapshotResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetConfigurationSnapshotSlot gets a snapshot of the configuration of an app at a previous point in time.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// snapshotID - the ID of the snapshot to read.
// slot - name of the deployment slot. If a slot is not specified, the API will return configuration for the
// production slot.
func (client AppsClient) GetConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetConfigurationSnapshotSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetConfigurationSnapshotSlot", err.Error())
	}

	req, err := client.GetConfigurationSnapshotSlotPreparer(ctx, resourceGroupName, name, snapshotID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSnapshotSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetConfigurationSnapshotSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSnapshotSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetConfigurationSnapshotSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetConfigurationSnapshotSlot", resp, "Failure responding to request")
	}

	return
}

// GetConfigurationSnapshotSlotPreparer prepares the GetConfigurationSnapshotSlot request.
func (client AppsClient) GetConfigurationSnapshotSlotPreparer(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"snapshotId":        autorest.Encode("path", snapshotID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetConfigurationSnapshotSlotSender sends the GetConfigurationSnapshotSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetConfigurationSnapshotSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetConfigurationSnapshotSlotResponder handles the response to the GetConfigurationSnapshotSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetConfigurationSnapshotSlotResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContainerLogsZip gets the ZIP archived docker log files for the given site
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetContainerLogsZip(ctx context.Context, resourceGroupName string, name string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetContainerLogsZip")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetContainerLogsZip", err.Error())
	}

	req, err := client.GetContainerLogsZipPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContainerLogsZip", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContainerLogsZipSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContainerLogsZip", resp, "Failure sending request")
		return
	}

	result, err = client.GetContainerLogsZipResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContainerLogsZip", resp, "Failure responding to request")
	}

	return
}

// GetContainerLogsZipPreparer prepares the GetContainerLogsZip request.
func (client AppsClient) GetContainerLogsZipPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetContainerLogsZipSender sends the GetContainerLogsZip request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetContainerLogsZipSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetContainerLogsZipResponder handles the response to the GetContainerLogsZip request. The method always
// closes the http.Response Body.
func (client AppsClient) GetContainerLogsZipResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContainerLogsZipSlot gets the ZIP archived docker log files for the given site
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) GetContainerLogsZipSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetContainerLogsZipSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetContainerLogsZipSlot", err.Error())
	}

	req, err := client.GetContainerLogsZipSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContainerLogsZipSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContainerLogsZipSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContainerLogsZipSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetContainerLogsZipSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContainerLogsZipSlot", resp, "Failure responding to request")
	}

	return
}

// GetContainerLogsZipSlotPreparer prepares the GetContainerLogsZipSlot request.
func (client AppsClient) GetContainerLogsZipSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetContainerLogsZipSlotSender sends the GetContainerLogsZipSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetContainerLogsZipSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetContainerLogsZipSlotResponder handles the response to the GetContainerLogsZipSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetContainerLogsZipSlotResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContinuousWebJob gets a continuous web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) GetContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result ContinuousWebJob, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetContinuousWebJob")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetContinuousWebJob", err.Error())
	}

	req, err := client.GetContinuousWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContinuousWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContinuousWebJobSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContinuousWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.GetContinuousWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContinuousWebJob", resp, "Failure responding to request")
	}

	return
}

// GetContinuousWebJobPreparer prepares the GetContinuousWebJob request.
func (client AppsClient) GetContinuousWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetContinuousWebJobSender sends the GetContinuousWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetContinuousWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetContinuousWebJobResponder handles the response to the GetContinuousWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) GetContinuousWebJobResponder(resp *http.Response) (result ContinuousWebJob, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContinuousWebJobSlot gets a continuous web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) GetContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result ContinuousWebJob, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetContinuousWebJobSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetContinuousWebJobSlot", err.Error())
	}

	req, err := client.GetContinuousWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContinuousWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetContinuousWebJobSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContinuousWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetContinuousWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetContinuousWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// GetContinuousWebJobSlotPreparer prepares the GetContinuousWebJobSlot request.
func (client AppsClient) GetContinuousWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetContinuousWebJobSlotSender sends the GetContinuousWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetContinuousWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetContinuousWebJobSlotResponder handles the response to the GetContinuousWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetContinuousWebJobSlotResponder(resp *http.Response) (result ContinuousWebJob, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeployment get a deployment by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - deployment ID.
func (client AppsClient) GetDeployment(ctx context.Context, resourceGroupName string, name string, ID string) (result Deployment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetDeployment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetDeployment", err.Error())
	}

	req, err := client.GetDeploymentPreparer(ctx, resourceGroupName, name, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeploymentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDeployment", resp, "Failure responding to request")
	}

	return
}

// GetDeploymentPreparer prepares the GetDeployment request.
func (client AppsClient) GetDeploymentPreparer(ctx context.Context, resourceGroupName string, name string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeploymentSender sends the GetDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetDeploymentResponder handles the response to the GetDeployment request. The method always
// closes the http.Response Body.
func (client AppsClient) GetDeploymentResponder(resp *http.Response) (result Deployment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDeploymentSlot get a deployment by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - deployment ID.
// slot - name of the deployment slot. If a slot is not specified, the API gets a deployment for the production
// slot.
func (client AppsClient) GetDeploymentSlot(ctx context.Context, resourceGroupName string, name string, ID string, slot string) (result Deployment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetDeploymentSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetDeploymentSlot", err.Error())
	}

	req, err := client.GetDeploymentSlotPreparer(ctx, resourceGroupName, name, ID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDeploymentSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDeploymentSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDeploymentSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetDeploymentSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDeploymentSlot", resp, "Failure responding to request")
	}

	return
}

// GetDeploymentSlotPreparer prepares the GetDeploymentSlot request.
func (client AppsClient) GetDeploymentSlotPreparer(ctx context.Context, resourceGroupName string, name string, ID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDeploymentSlotSender sends the GetDeploymentSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetDeploymentSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetDeploymentSlotResponder handles the response to the GetDeploymentSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetDeploymentSlotResponder(resp *http.Response) (result Deployment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDiagnosticLogsConfiguration gets the logging configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GetDiagnosticLogsConfiguration(ctx context.Context, resourceGroupName string, name string) (result SiteLogsConfig, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetDiagnosticLogsConfiguration")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetDiagnosticLogsConfiguration", err.Error())
	}

	req, err := client.GetDiagnosticLogsConfigurationPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDiagnosticLogsConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDiagnosticLogsConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDiagnosticLogsConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.GetDiagnosticLogsConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDiagnosticLogsConfiguration", resp, "Failure responding to request")
	}

	return
}

// GetDiagnosticLogsConfigurationPreparer prepares the GetDiagnosticLogsConfiguration request.
func (client AppsClient) GetDiagnosticLogsConfigurationPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDiagnosticLogsConfigurationSender sends the GetDiagnosticLogsConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetDiagnosticLogsConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetDiagnosticLogsConfigurationResponder handles the response to the GetDiagnosticLogsConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) GetDiagnosticLogsConfigurationResponder(resp *http.Response) (result SiteLogsConfig, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDiagnosticLogsConfigurationSlot gets the logging configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the logging configuration
// for the production slot.
func (client AppsClient) GetDiagnosticLogsConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteLogsConfig, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetDiagnosticLogsConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetDiagnosticLogsConfigurationSlot", err.Error())
	}

	req, err := client.GetDiagnosticLogsConfigurationSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDiagnosticLogsConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDiagnosticLogsConfigurationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDiagnosticLogsConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetDiagnosticLogsConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDiagnosticLogsConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// GetDiagnosticLogsConfigurationSlotPreparer prepares the GetDiagnosticLogsConfigurationSlot request.
func (client AppsClient) GetDiagnosticLogsConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDiagnosticLogsConfigurationSlotSender sends the GetDiagnosticLogsConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetDiagnosticLogsConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetDiagnosticLogsConfigurationSlotResponder handles the response to the GetDiagnosticLogsConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetDiagnosticLogsConfigurationSlotResponder(resp *http.Response) (result SiteLogsConfig, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDomainOwnershipIdentifier get domain ownership identifier for web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
func (client AppsClient) GetDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string) (result Identifier, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetDomainOwnershipIdentifier")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetDomainOwnershipIdentifier", err.Error())
	}

	req, err := client.GetDomainOwnershipIdentifierPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDomainOwnershipIdentifier", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDomainOwnershipIdentifierSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDomainOwnershipIdentifier", resp, "Failure sending request")
		return
	}

	result, err = client.GetDomainOwnershipIdentifierResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDomainOwnershipIdentifier", resp, "Failure responding to request")
	}

	return
}

// GetDomainOwnershipIdentifierPreparer prepares the GetDomainOwnershipIdentifier request.
func (client AppsClient) GetDomainOwnershipIdentifierPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDomainOwnershipIdentifierSender sends the GetDomainOwnershipIdentifier request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetDomainOwnershipIdentifierSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetDomainOwnershipIdentifierResponder handles the response to the GetDomainOwnershipIdentifier request. The method always
// closes the http.Response Body.
func (client AppsClient) GetDomainOwnershipIdentifierResponder(resp *http.Response) (result Identifier, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDomainOwnershipIdentifierSlot get domain ownership identifier for web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
func (client AppsClient) GetDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string) (result Identifier, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetDomainOwnershipIdentifierSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetDomainOwnershipIdentifierSlot", err.Error())
	}

	req, err := client.GetDomainOwnershipIdentifierSlotPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDomainOwnershipIdentifierSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDomainOwnershipIdentifierSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDomainOwnershipIdentifierSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetDomainOwnershipIdentifierSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetDomainOwnershipIdentifierSlot", resp, "Failure responding to request")
	}

	return
}

// GetDomainOwnershipIdentifierSlotPreparer prepares the GetDomainOwnershipIdentifierSlot request.
func (client AppsClient) GetDomainOwnershipIdentifierSlotPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"slot":                          autorest.Encode("path", slot),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDomainOwnershipIdentifierSlotSender sends the GetDomainOwnershipIdentifierSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetDomainOwnershipIdentifierSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetDomainOwnershipIdentifierSlotResponder handles the response to the GetDomainOwnershipIdentifierSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetDomainOwnershipIdentifierSlotResponder(resp *http.Response) (result Identifier, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFunction get function information by its ID for web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
func (client AppsClient) GetFunction(ctx context.Context, resourceGroupName string, name string, functionName string) (result FunctionEnvelope, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetFunction")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetFunction", err.Error())
	}

	req, err := client.GetFunctionPreparer(ctx, resourceGroupName, name, functionName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunction", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFunctionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunction", resp, "Failure sending request")
		return
	}

	result, err = client.GetFunctionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunction", resp, "Failure responding to request")
	}

	return
}

// GetFunctionPreparer prepares the GetFunction request.
func (client AppsClient) GetFunctionPreparer(ctx context.Context, resourceGroupName string, name string, functionName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFunctionSender sends the GetFunction request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetFunctionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetFunctionResponder handles the response to the GetFunction request. The method always
// closes the http.Response Body.
func (client AppsClient) GetFunctionResponder(resp *http.Response) (result FunctionEnvelope, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFunctionsAdminToken fetch a short lived token that can be exchanged for a master key.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetFunctionsAdminToken(ctx context.Context, resourceGroupName string, name string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetFunctionsAdminToken")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetFunctionsAdminToken", err.Error())
	}

	req, err := client.GetFunctionsAdminTokenPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunctionsAdminToken", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFunctionsAdminTokenSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunctionsAdminToken", resp, "Failure sending request")
		return
	}

	result, err = client.GetFunctionsAdminTokenResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunctionsAdminToken", resp, "Failure responding to request")
	}

	return
}

// GetFunctionsAdminTokenPreparer prepares the GetFunctionsAdminToken request.
func (client AppsClient) GetFunctionsAdminTokenPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFunctionsAdminTokenSender sends the GetFunctionsAdminToken request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetFunctionsAdminTokenSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetFunctionsAdminTokenResponder handles the response to the GetFunctionsAdminToken request. The method always
// closes the http.Response Body.
func (client AppsClient) GetFunctionsAdminTokenResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFunctionsAdminTokenSlot fetch a short lived token that can be exchanged for a master key.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) GetFunctionsAdminTokenSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetFunctionsAdminTokenSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetFunctionsAdminTokenSlot", err.Error())
	}

	req, err := client.GetFunctionsAdminTokenSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunctionsAdminTokenSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetFunctionsAdminTokenSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunctionsAdminTokenSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetFunctionsAdminTokenSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetFunctionsAdminTokenSlot", resp, "Failure responding to request")
	}

	return
}

// GetFunctionsAdminTokenSlotPreparer prepares the GetFunctionsAdminTokenSlot request.
func (client AppsClient) GetFunctionsAdminTokenSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetFunctionsAdminTokenSlotSender sends the GetFunctionsAdminTokenSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetFunctionsAdminTokenSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetFunctionsAdminTokenSlotResponder handles the response to the GetFunctionsAdminTokenSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetFunctionsAdminTokenSlotResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetHostNameBinding get the named hostname binding for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// hostName - hostname in the hostname binding.
func (client AppsClient) GetHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string) (result HostNameBinding, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetHostNameBinding")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetHostNameBinding", err.Error())
	}

	req, err := client.GetHostNameBindingPreparer(ctx, resourceGroupName, name, hostName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHostNameBinding", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetHostNameBindingSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHostNameBinding", resp, "Failure sending request")
		return
	}

	result, err = client.GetHostNameBindingResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHostNameBinding", resp, "Failure responding to request")
	}

	return
}

// GetHostNameBindingPreparer prepares the GetHostNameBinding request.
func (client AppsClient) GetHostNameBindingPreparer(ctx context.Context, resourceGroupName string, name string, hostName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"hostName":          autorest.Encode("path", hostName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetHostNameBindingSender sends the GetHostNameBinding request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetHostNameBindingSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetHostNameBindingResponder handles the response to the GetHostNameBinding request. The method always
// closes the http.Response Body.
func (client AppsClient) GetHostNameBindingResponder(resp *http.Response) (result HostNameBinding, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetHostNameBindingSlot get the named hostname binding for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API the named binding for the production
// slot.
// hostName - hostname in the hostname binding.
func (client AppsClient) GetHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string) (result HostNameBinding, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetHostNameBindingSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetHostNameBindingSlot", err.Error())
	}

	req, err := client.GetHostNameBindingSlotPreparer(ctx, resourceGroupName, name, slot, hostName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHostNameBindingSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetHostNameBindingSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHostNameBindingSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetHostNameBindingSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHostNameBindingSlot", resp, "Failure responding to request")
	}

	return
}

// GetHostNameBindingSlotPreparer prepares the GetHostNameBindingSlot request.
func (client AppsClient) GetHostNameBindingSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, hostName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"hostName":          autorest.Encode("path", hostName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetHostNameBindingSlotSender sends the GetHostNameBindingSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetHostNameBindingSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetHostNameBindingSlotResponder handles the response to the GetHostNameBindingSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetHostNameBindingSlotResponder(resp *http.Response) (result HostNameBinding, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetHybridConnection retrieves a specific Service Bus Hybrid Connection used by this Web App.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
func (client AppsClient) GetHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetHybridConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetHybridConnection", err.Error())
	}

	req, err := client.GetHybridConnectionPreparer(ctx, resourceGroupName, name, namespaceName, relayName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHybridConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetHybridConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHybridConnection", resp, "Failure sending request")
		return
	}

	result, err = client.GetHybridConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHybridConnection", resp, "Failure responding to request")
	}

	return
}

// GetHybridConnectionPreparer prepares the GetHybridConnection request.
func (client AppsClient) GetHybridConnectionPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetHybridConnectionSender sends the GetHybridConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetHybridConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetHybridConnectionResponder handles the response to the GetHybridConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) GetHybridConnectionResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetHybridConnectionSlot retrieves a specific Service Bus Hybrid Connection used by this Web App.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// slot - the name of the slot for the web app.
func (client AppsClient) GetHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetHybridConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetHybridConnectionSlot", err.Error())
	}

	req, err := client.GetHybridConnectionSlotPreparer(ctx, resourceGroupName, name, namespaceName, relayName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHybridConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetHybridConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHybridConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetHybridConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetHybridConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// GetHybridConnectionSlotPreparer prepares the GetHybridConnectionSlot request.
func (client AppsClient) GetHybridConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetHybridConnectionSlotSender sends the GetHybridConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetHybridConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetHybridConnectionSlotResponder handles the response to the GetHybridConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetHybridConnectionSlotResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceFunctionSlot get function information by its ID for web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) GetInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string) (result FunctionEnvelope, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceFunctionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceFunctionSlot", err.Error())
	}

	req, err := client.GetInstanceFunctionSlotPreparer(ctx, resourceGroupName, name, functionName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceFunctionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceFunctionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceFunctionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceFunctionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceFunctionSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceFunctionSlotPreparer prepares the GetInstanceFunctionSlot request.
func (client AppsClient) GetInstanceFunctionSlotPreparer(ctx context.Context, resourceGroupName string, name string, functionName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceFunctionSlotSender sends the GetInstanceFunctionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceFunctionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceFunctionSlotResponder handles the response to the GetInstanceFunctionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceFunctionSlotResponder(resp *http.Response) (result FunctionEnvelope, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceMSDeployLog get the MSDeploy Log for the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// instanceID - ID of web app instance.
func (client AppsClient) GetInstanceMSDeployLog(ctx context.Context, resourceGroupName string, name string, instanceID string) (result MSDeployLog, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceMSDeployLog")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceMSDeployLog", err.Error())
	}

	req, err := client.GetInstanceMSDeployLogPreparer(ctx, resourceGroupName, name, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMSDeployLog", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceMSDeployLogSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMSDeployLog", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceMSDeployLogResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMSDeployLog", resp, "Failure responding to request")
	}

	return
}

// GetInstanceMSDeployLogPreparer prepares the GetInstanceMSDeployLog request.
func (client AppsClient) GetInstanceMSDeployLogPreparer(ctx context.Context, resourceGroupName string, name string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceMSDeployLogSender sends the GetInstanceMSDeployLog request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceMSDeployLogSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceMSDeployLogResponder handles the response to the GetInstanceMSDeployLog request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceMSDeployLogResponder(resp *http.Response) (result MSDeployLog, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceMSDeployLogSlot get the MSDeploy Log for the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
// instanceID - ID of web app instance.
func (client AppsClient) GetInstanceMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (result MSDeployLog, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceMSDeployLogSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceMSDeployLogSlot", err.Error())
	}

	req, err := client.GetInstanceMSDeployLogSlotPreparer(ctx, resourceGroupName, name, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMSDeployLogSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceMSDeployLogSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMSDeployLogSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceMSDeployLogSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMSDeployLogSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceMSDeployLogSlotPreparer prepares the GetInstanceMSDeployLogSlot request.
func (client AppsClient) GetInstanceMSDeployLogSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceMSDeployLogSlotSender sends the GetInstanceMSDeployLogSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceMSDeployLogSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceMSDeployLogSlotResponder handles the response to the GetInstanceMSDeployLogSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceMSDeployLogSlotResponder(resp *http.Response) (result MSDeployLog, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceMsDeployStatus get the status of the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// instanceID - ID of web app instance.
func (client AppsClient) GetInstanceMsDeployStatus(ctx context.Context, resourceGroupName string, name string, instanceID string) (result MSDeployStatus, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceMsDeployStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceMsDeployStatus", err.Error())
	}

	req, err := client.GetInstanceMsDeployStatusPreparer(ctx, resourceGroupName, name, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMsDeployStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceMsDeployStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMsDeployStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceMsDeployStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMsDeployStatus", resp, "Failure responding to request")
	}

	return
}

// GetInstanceMsDeployStatusPreparer prepares the GetInstanceMsDeployStatus request.
func (client AppsClient) GetInstanceMsDeployStatusPreparer(ctx context.Context, resourceGroupName string, name string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceMsDeployStatusSender sends the GetInstanceMsDeployStatus request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceMsDeployStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceMsDeployStatusResponder handles the response to the GetInstanceMsDeployStatus request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceMsDeployStatusResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceMsDeployStatusSlot get the status of the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
// instanceID - ID of web app instance.
func (client AppsClient) GetInstanceMsDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (result MSDeployStatus, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceMsDeployStatusSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceMsDeployStatusSlot", err.Error())
	}

	req, err := client.GetInstanceMsDeployStatusSlotPreparer(ctx, resourceGroupName, name, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMsDeployStatusSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceMsDeployStatusSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMsDeployStatusSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceMsDeployStatusSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceMsDeployStatusSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceMsDeployStatusSlotPreparer prepares the GetInstanceMsDeployStatusSlot request.
func (client AppsClient) GetInstanceMsDeployStatusSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceMsDeployStatusSlotSender sends the GetInstanceMsDeployStatusSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceMsDeployStatusSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceMsDeployStatusSlotResponder handles the response to the GetInstanceMsDeployStatusSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceMsDeployStatusSlotResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcess get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result ProcessInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcess")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcess", err.Error())
	}

	req, err := client.GetInstanceProcessPreparer(ctx, resourceGroupName, name, processID, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcess", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcess", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcess", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessPreparer prepares the GetInstanceProcess request.
func (client AppsClient) GetInstanceProcessPreparer(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessSender sends the GetInstanceProcess request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessResponder handles the response to the GetInstanceProcess request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessResponder(resp *http.Response) (result ProcessInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessDump get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessDump")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessDump", err.Error())
	}

	req, err := client.GetInstanceProcessDumpPreparer(ctx, resourceGroupName, name, processID, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessDump", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessDumpSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessDump", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessDumpResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessDump", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessDumpPreparer prepares the GetInstanceProcessDump request.
func (client AppsClient) GetInstanceProcessDumpPreparer(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessDumpSender sends the GetInstanceProcessDump request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessDumpSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessDumpResponder handles the response to the GetInstanceProcessDump request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessDumpResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessDumpSlot get a memory dump of a process by its ID for a specific scaled-out instance in a web
// site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessDumpSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessDumpSlot", err.Error())
	}

	req, err := client.GetInstanceProcessDumpSlotPreparer(ctx, resourceGroupName, name, processID, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessDumpSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessDumpSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessDumpSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessDumpSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessDumpSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessDumpSlotPreparer prepares the GetInstanceProcessDumpSlot request.
func (client AppsClient) GetInstanceProcessDumpSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessDumpSlotSender sends the GetInstanceProcessDumpSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessDumpSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessDumpSlotResponder handles the response to the GetInstanceProcessDumpSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessDumpSlotResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessModule get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// baseAddress - module base address.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string) (result ProcessModuleInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessModule")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessModule", err.Error())
	}

	req, err := client.GetInstanceProcessModulePreparer(ctx, resourceGroupName, name, processID, baseAddress, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessModule", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessModuleSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessModule", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessModuleResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessModule", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessModulePreparer prepares the GetInstanceProcessModule request.
func (client AppsClient) GetInstanceProcessModulePreparer(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"baseAddress":       autorest.Encode("path", baseAddress),
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessModuleSender sends the GetInstanceProcessModule request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessModuleSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessModuleResponder handles the response to the GetInstanceProcessModule request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessModuleResponder(resp *http.Response) (result ProcessModuleInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessModuleSlot get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// baseAddress - module base address.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string) (result ProcessModuleInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessModuleSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessModuleSlot", err.Error())
	}

	req, err := client.GetInstanceProcessModuleSlotPreparer(ctx, resourceGroupName, name, processID, baseAddress, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessModuleSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessModuleSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessModuleSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessModuleSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessModuleSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessModuleSlotPreparer prepares the GetInstanceProcessModuleSlot request.
func (client AppsClient) GetInstanceProcessModuleSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"baseAddress":       autorest.Encode("path", baseAddress),
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessModuleSlotSender sends the GetInstanceProcessModuleSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessModuleSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessModuleSlotResponder handles the response to the GetInstanceProcessModuleSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessModuleSlotResponder(resp *http.Response) (result ProcessModuleInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessSlot get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result ProcessInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessSlot", err.Error())
	}

	req, err := client.GetInstanceProcessSlotPreparer(ctx, resourceGroupName, name, processID, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessSlotPreparer prepares the GetInstanceProcessSlot request.
func (client AppsClient) GetInstanceProcessSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessSlotSender sends the GetInstanceProcessSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessSlotResponder handles the response to the GetInstanceProcessSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessSlotResponder(resp *http.Response) (result ProcessInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessThread get thread information by Thread ID for a specific process, in a specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// threadID - tID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessThread(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, instanceID string) (result ProcessThreadInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessThread")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessThread", err.Error())
	}

	req, err := client.GetInstanceProcessThreadPreparer(ctx, resourceGroupName, name, processID, threadID, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessThread", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessThreadSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessThread", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessThreadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessThread", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessThreadPreparer prepares the GetInstanceProcessThread request.
func (client AppsClient) GetInstanceProcessThreadPreparer(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"threadId":          autorest.Encode("path", threadID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads/{threadId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessThreadSender sends the GetInstanceProcessThread request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessThreadSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessThreadResponder handles the response to the GetInstanceProcessThread request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessThreadResponder(resp *http.Response) (result ProcessThreadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetInstanceProcessThreadSlot get thread information by Thread ID for a specific process, in a specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// threadID - tID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) GetInstanceProcessThreadSlot(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string, instanceID string) (result ProcessThreadInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetInstanceProcessThreadSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetInstanceProcessThreadSlot", err.Error())
	}

	req, err := client.GetInstanceProcessThreadSlotPreparer(ctx, resourceGroupName, name, processID, threadID, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessThreadSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetInstanceProcessThreadSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessThreadSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetInstanceProcessThreadSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetInstanceProcessThreadSlot", resp, "Failure responding to request")
	}

	return
}

// GetInstanceProcessThreadSlotPreparer prepares the GetInstanceProcessThreadSlot request.
func (client AppsClient) GetInstanceProcessThreadSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"threadId":          autorest.Encode("path", threadID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads/{threadId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetInstanceProcessThreadSlotSender sends the GetInstanceProcessThreadSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetInstanceProcessThreadSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetInstanceProcessThreadSlotResponder handles the response to the GetInstanceProcessThreadSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetInstanceProcessThreadSlotResponder(resp *http.Response) (result ProcessThreadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMigrateMySQLStatus returns the status of MySql in app migration, if one is active, and whether or not MySql in
// app is enabled
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetMigrateMySQLStatus(ctx context.Context, resourceGroupName string, name string) (result MigrateMySQLStatus, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetMigrateMySQLStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetMigrateMySQLStatus", err.Error())
	}

	req, err := client.GetMigrateMySQLStatusPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMigrateMySQLStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMigrateMySQLStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMigrateMySQLStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetMigrateMySQLStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMigrateMySQLStatus", resp, "Failure responding to request")
	}

	return
}

// GetMigrateMySQLStatusPreparer prepares the GetMigrateMySQLStatus request.
func (client AppsClient) GetMigrateMySQLStatusPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMigrateMySQLStatusSender sends the GetMigrateMySQLStatus request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetMigrateMySQLStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetMigrateMySQLStatusResponder handles the response to the GetMigrateMySQLStatus request. The method always
// closes the http.Response Body.
func (client AppsClient) GetMigrateMySQLStatusResponder(resp *http.Response) (result MigrateMySQLStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMigrateMySQLStatusSlot returns the status of MySql in app migration, if one is active, and whether or not MySql
// in app is enabled
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of the deployment slot.
func (client AppsClient) GetMigrateMySQLStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result MigrateMySQLStatus, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetMigrateMySQLStatusSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetMigrateMySQLStatusSlot", err.Error())
	}

	req, err := client.GetMigrateMySQLStatusSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMigrateMySQLStatusSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMigrateMySQLStatusSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMigrateMySQLStatusSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetMigrateMySQLStatusSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMigrateMySQLStatusSlot", resp, "Failure responding to request")
	}

	return
}

// GetMigrateMySQLStatusSlotPreparer prepares the GetMigrateMySQLStatusSlot request.
func (client AppsClient) GetMigrateMySQLStatusSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMigrateMySQLStatusSlotSender sends the GetMigrateMySQLStatusSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetMigrateMySQLStatusSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetMigrateMySQLStatusSlotResponder handles the response to the GetMigrateMySQLStatusSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetMigrateMySQLStatusSlotResponder(resp *http.Response) (result MigrateMySQLStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMSDeployLog get the MSDeploy Log for the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetMSDeployLog(ctx context.Context, resourceGroupName string, name string) (result MSDeployLog, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetMSDeployLog")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetMSDeployLog", err.Error())
	}

	req, err := client.GetMSDeployLogPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployLog", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMSDeployLogSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployLog", resp, "Failure sending request")
		return
	}

	result, err = client.GetMSDeployLogResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployLog", resp, "Failure responding to request")
	}

	return
}

// GetMSDeployLogPreparer prepares the GetMSDeployLog request.
func (client AppsClient) GetMSDeployLogPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMSDeployLogSender sends the GetMSDeployLog request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetMSDeployLogSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetMSDeployLogResponder handles the response to the GetMSDeployLog request. The method always
// closes the http.Response Body.
func (client AppsClient) GetMSDeployLogResponder(resp *http.Response) (result MSDeployLog, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMSDeployLogSlot get the MSDeploy Log for the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) GetMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result MSDeployLog, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetMSDeployLogSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetMSDeployLogSlot", err.Error())
	}

	req, err := client.GetMSDeployLogSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployLogSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMSDeployLogSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployLogSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetMSDeployLogSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployLogSlot", resp, "Failure responding to request")
	}

	return
}

// GetMSDeployLogSlotPreparer prepares the GetMSDeployLogSlot request.
func (client AppsClient) GetMSDeployLogSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMSDeployLogSlotSender sends the GetMSDeployLogSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetMSDeployLogSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetMSDeployLogSlotResponder handles the response to the GetMSDeployLogSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetMSDeployLogSlotResponder(resp *http.Response) (result MSDeployLog, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMSDeployStatus get the status of the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetMSDeployStatus(ctx context.Context, resourceGroupName string, name string) (result MSDeployStatus, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetMSDeployStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetMSDeployStatus", err.Error())
	}

	req, err := client.GetMSDeployStatusPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMSDeployStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetMSDeployStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployStatus", resp, "Failure responding to request")
	}

	return
}

// GetMSDeployStatusPreparer prepares the GetMSDeployStatus request.
func (client AppsClient) GetMSDeployStatusPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMSDeployStatusSender sends the GetMSDeployStatus request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetMSDeployStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetMSDeployStatusResponder handles the response to the GetMSDeployStatus request. The method always
// closes the http.Response Body.
func (client AppsClient) GetMSDeployStatusResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetMSDeployStatusSlot get the status of the last MSDeploy operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) GetMSDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result MSDeployStatus, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetMSDeployStatusSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetMSDeployStatusSlot", err.Error())
	}

	req, err := client.GetMSDeployStatusSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployStatusSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetMSDeployStatusSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployStatusSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetMSDeployStatusSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetMSDeployStatusSlot", resp, "Failure responding to request")
	}

	return
}

// GetMSDeployStatusSlotPreparer prepares the GetMSDeployStatusSlot request.
func (client AppsClient) GetMSDeployStatusSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetMSDeployStatusSlotSender sends the GetMSDeployStatusSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetMSDeployStatusSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetMSDeployStatusSlotResponder handles the response to the GetMSDeployStatusSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetMSDeployStatusSlotResponder(resp *http.Response) (result MSDeployStatus, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTraceOperation gets a named operation for a network trace capturing (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
func (client AppsClient) GetNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, operationID string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTraceOperation")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTraceOperation", err.Error())
	}

	req, err := client.GetNetworkTraceOperationPreparer(ctx, resourceGroupName, name, operationID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperation", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTraceOperationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperation", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTraceOperationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperation", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTraceOperationPreparer prepares the GetNetworkTraceOperation request.
func (client AppsClient) GetNetworkTraceOperationPreparer(ctx context.Context, resourceGroupName string, name string, operationID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTraceOperationSender sends the GetNetworkTraceOperation request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTraceOperationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTraceOperationResponder handles the response to the GetNetworkTraceOperation request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTraceOperationResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTraceOperationSlot gets a named operation for a network trace capturing (or deployment slot, if
// specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
// slot - name of the deployment slot. If a slot is not specified, the API will get an operation for the
// production slot.
func (client AppsClient) GetNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTraceOperationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTraceOperationSlot", err.Error())
	}

	req, err := client.GetNetworkTraceOperationSlotPreparer(ctx, resourceGroupName, name, operationID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTraceOperationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTraceOperationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationSlot", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTraceOperationSlotPreparer prepares the GetNetworkTraceOperationSlot request.
func (client AppsClient) GetNetworkTraceOperationSlotPreparer(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTraceOperationSlotSender sends the GetNetworkTraceOperationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTraceOperationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTraceOperationSlotResponder handles the response to the GetNetworkTraceOperationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTraceOperationSlotResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTraceOperationSlotV2 gets a named operation for a network trace capturing (or deployment slot, if
// specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
// slot - name of the deployment slot. If a slot is not specified, the API will get an operation for the
// production slot.
func (client AppsClient) GetNetworkTraceOperationSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTraceOperationSlotV2")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTraceOperationSlotV2", err.Error())
	}

	req, err := client.GetNetworkTraceOperationSlotV2Preparer(ctx, resourceGroupName, name, operationID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationSlotV2", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTraceOperationSlotV2Sender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationSlotV2", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTraceOperationSlotV2Responder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationSlotV2", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTraceOperationSlotV2Preparer prepares the GetNetworkTraceOperationSlotV2 request.
func (client AppsClient) GetNetworkTraceOperationSlotV2Preparer(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTraceOperationSlotV2Sender sends the GetNetworkTraceOperationSlotV2 request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTraceOperationSlotV2Sender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTraceOperationSlotV2Responder handles the response to the GetNetworkTraceOperationSlotV2 request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTraceOperationSlotV2Responder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTraceOperationV2 gets a named operation for a network trace capturing (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
func (client AppsClient) GetNetworkTraceOperationV2(ctx context.Context, resourceGroupName string, name string, operationID string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTraceOperationV2")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTraceOperationV2", err.Error())
	}

	req, err := client.GetNetworkTraceOperationV2Preparer(ctx, resourceGroupName, name, operationID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationV2", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTraceOperationV2Sender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationV2", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTraceOperationV2Responder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraceOperationV2", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTraceOperationV2Preparer prepares the GetNetworkTraceOperationV2 request.
func (client AppsClient) GetNetworkTraceOperationV2Preparer(ctx context.Context, resourceGroupName string, name string, operationID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTraceOperationV2Sender sends the GetNetworkTraceOperationV2 request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTraceOperationV2Sender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTraceOperationV2Responder handles the response to the GetNetworkTraceOperationV2 request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTraceOperationV2Responder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTraces gets a named operation for a network trace capturing (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
func (client AppsClient) GetNetworkTraces(ctx context.Context, resourceGroupName string, name string, operationID string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTraces")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTraces", err.Error())
	}

	req, err := client.GetNetworkTracesPreparer(ctx, resourceGroupName, name, operationID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraces", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTracesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraces", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTracesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTraces", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTracesPreparer prepares the GetNetworkTraces request.
func (client AppsClient) GetNetworkTracesPreparer(ctx context.Context, resourceGroupName string, name string, operationID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTracesSender sends the GetNetworkTraces request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTracesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTracesResponder handles the response to the GetNetworkTraces request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTracesResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTracesSlot gets a named operation for a network trace capturing (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
// slot - name of the deployment slot. If a slot is not specified, the API will get an operation for the
// production slot.
func (client AppsClient) GetNetworkTracesSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTracesSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTracesSlot", err.Error())
	}

	req, err := client.GetNetworkTracesSlotPreparer(ctx, resourceGroupName, name, operationID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTracesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTracesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesSlot", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTracesSlotPreparer prepares the GetNetworkTracesSlot request.
func (client AppsClient) GetNetworkTracesSlotPreparer(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTracesSlotSender sends the GetNetworkTracesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTracesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTracesSlotResponder handles the response to the GetNetworkTracesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTracesSlotResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTracesSlotV2 gets a named operation for a network trace capturing (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
// slot - name of the deployment slot. If a slot is not specified, the API will get an operation for the
// production slot.
func (client AppsClient) GetNetworkTracesSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTracesSlotV2")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTracesSlotV2", err.Error())
	}

	req, err := client.GetNetworkTracesSlotV2Preparer(ctx, resourceGroupName, name, operationID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesSlotV2", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTracesSlotV2Sender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesSlotV2", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTracesSlotV2Responder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesSlotV2", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTracesSlotV2Preparer prepares the GetNetworkTracesSlotV2 request.
func (client AppsClient) GetNetworkTracesSlotV2Preparer(ctx context.Context, resourceGroupName string, name string, operationID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTracesSlotV2Sender sends the GetNetworkTracesSlotV2 request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTracesSlotV2Sender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTracesSlotV2Responder handles the response to the GetNetworkTracesSlotV2 request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTracesSlotV2Responder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetNetworkTracesV2 gets a named operation for a network trace capturing (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// operationID - GUID of the operation.
func (client AppsClient) GetNetworkTracesV2(ctx context.Context, resourceGroupName string, name string, operationID string) (result ListNetworkTrace, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetNetworkTracesV2")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetNetworkTracesV2", err.Error())
	}

	req, err := client.GetNetworkTracesV2Preparer(ctx, resourceGroupName, name, operationID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesV2", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetNetworkTracesV2Sender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesV2", resp, "Failure sending request")
		return
	}

	result, err = client.GetNetworkTracesV2Responder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetNetworkTracesV2", resp, "Failure responding to request")
	}

	return
}

// GetNetworkTracesV2Preparer prepares the GetNetworkTracesV2 request.
func (client AppsClient) GetNetworkTracesV2Preparer(ctx context.Context, resourceGroupName string, name string, operationID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"operationId":       autorest.Encode("path", operationID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetNetworkTracesV2Sender sends the GetNetworkTracesV2 request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetNetworkTracesV2Sender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetNetworkTracesV2Responder handles the response to the GetNetworkTracesV2 request. The method always
// closes the http.Response Body.
func (client AppsClient) GetNetworkTracesV2Responder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPremierAddOn gets a named add-on of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
func (client AppsClient) GetPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetPremierAddOn")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetPremierAddOn", err.Error())
	}

	req, err := client.GetPremierAddOnPreparer(ctx, resourceGroupName, name, premierAddOnName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPremierAddOn", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPremierAddOnSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPremierAddOn", resp, "Failure sending request")
		return
	}

	result, err = client.GetPremierAddOnResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPremierAddOn", resp, "Failure responding to request")
	}

	return
}

// GetPremierAddOnPreparer prepares the GetPremierAddOn request.
func (client AppsClient) GetPremierAddOnPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPremierAddOnSender sends the GetPremierAddOn request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetPremierAddOnSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetPremierAddOnResponder handles the response to the GetPremierAddOn request. The method always
// closes the http.Response Body.
func (client AppsClient) GetPremierAddOnResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPremierAddOnSlot gets a named add-on of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
// slot - name of the deployment slot. If a slot is not specified, the API will get the named add-on for the
// production slot.
func (client AppsClient) GetPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetPremierAddOnSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetPremierAddOnSlot", err.Error())
	}

	req, err := client.GetPremierAddOnSlotPreparer(ctx, resourceGroupName, name, premierAddOnName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPremierAddOnSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPremierAddOnSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPremierAddOnSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetPremierAddOnSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPremierAddOnSlot", resp, "Failure responding to request")
	}

	return
}

// GetPremierAddOnSlotPreparer prepares the GetPremierAddOnSlot request.
func (client AppsClient) GetPremierAddOnSlotPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPremierAddOnSlotSender sends the GetPremierAddOnSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetPremierAddOnSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetPremierAddOnSlotResponder handles the response to the GetPremierAddOnSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetPremierAddOnSlotResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPrivateAccess gets data around private site access enablement and authorized Virtual Networks that can access the
// site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
func (client AppsClient) GetPrivateAccess(ctx context.Context, resourceGroupName string, name string) (result PrivateAccess, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetPrivateAccess")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetPrivateAccess", err.Error())
	}

	req, err := client.GetPrivateAccessPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPrivateAccess", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPrivateAccessSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPrivateAccess", resp, "Failure sending request")
		return
	}

	result, err = client.GetPrivateAccessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPrivateAccess", resp, "Failure responding to request")
	}

	return
}

// GetPrivateAccessPreparer prepares the GetPrivateAccess request.
func (client AppsClient) GetPrivateAccessPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPrivateAccessSender sends the GetPrivateAccess request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetPrivateAccessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetPrivateAccessResponder handles the response to the GetPrivateAccess request. The method always
// closes the http.Response Body.
func (client AppsClient) GetPrivateAccessResponder(resp *http.Response) (result PrivateAccess, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPrivateAccessSlot gets data around private site access enablement and authorized Virtual Networks that can access
// the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for the web app.
func (client AppsClient) GetPrivateAccessSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result PrivateAccess, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetPrivateAccessSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetPrivateAccessSlot", err.Error())
	}

	req, err := client.GetPrivateAccessSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPrivateAccessSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPrivateAccessSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPrivateAccessSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetPrivateAccessSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPrivateAccessSlot", resp, "Failure responding to request")
	}

	return
}

// GetPrivateAccessSlotPreparer prepares the GetPrivateAccessSlot request.
func (client AppsClient) GetPrivateAccessSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPrivateAccessSlotSender sends the GetPrivateAccessSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetPrivateAccessSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetPrivateAccessSlotResponder handles the response to the GetPrivateAccessSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetPrivateAccessSlotResponder(resp *http.Response) (result PrivateAccess, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcess get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
func (client AppsClient) GetProcess(ctx context.Context, resourceGroupName string, name string, processID string) (result ProcessInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcess")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcess", err.Error())
	}

	req, err := client.GetProcessPreparer(ctx, resourceGroupName, name, processID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcess", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcess", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcess", resp, "Failure responding to request")
	}

	return
}

// GetProcessPreparer prepares the GetProcess request.
func (client AppsClient) GetProcessPreparer(ctx context.Context, resourceGroupName string, name string, processID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessSender sends the GetProcess request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessResponder handles the response to the GetProcess request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessResponder(resp *http.Response) (result ProcessInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessDump get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
func (client AppsClient) GetProcessDump(ctx context.Context, resourceGroupName string, name string, processID string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessDump")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessDump", err.Error())
	}

	req, err := client.GetProcessDumpPreparer(ctx, resourceGroupName, name, processID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessDump", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessDumpSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessDump", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessDumpResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessDump", resp, "Failure responding to request")
	}

	return
}

// GetProcessDumpPreparer prepares the GetProcessDump request.
func (client AppsClient) GetProcessDumpPreparer(ctx context.Context, resourceGroupName string, name string, processID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessDumpSender sends the GetProcessDump request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessDumpSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessDumpResponder handles the response to the GetProcessDump request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessDumpResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessDumpSlot get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) GetProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessDumpSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessDumpSlot", err.Error())
	}

	req, err := client.GetProcessDumpSlotPreparer(ctx, resourceGroupName, name, processID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessDumpSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessDumpSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessDumpSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessDumpSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessDumpSlot", resp, "Failure responding to request")
	}

	return
}

// GetProcessDumpSlotPreparer prepares the GetProcessDumpSlot request.
func (client AppsClient) GetProcessDumpSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessDumpSlotSender sends the GetProcessDumpSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessDumpSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessDumpSlotResponder handles the response to the GetProcessDumpSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessDumpSlotResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessModule get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// baseAddress - module base address.
func (client AppsClient) GetProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string) (result ProcessModuleInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessModule")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessModule", err.Error())
	}

	req, err := client.GetProcessModulePreparer(ctx, resourceGroupName, name, processID, baseAddress)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessModule", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessModuleSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessModule", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessModuleResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessModule", resp, "Failure responding to request")
	}

	return
}

// GetProcessModulePreparer prepares the GetProcessModule request.
func (client AppsClient) GetProcessModulePreparer(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"baseAddress":       autorest.Encode("path", baseAddress),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessModuleSender sends the GetProcessModule request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessModuleSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessModuleResponder handles the response to the GetProcessModule request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessModuleResponder(resp *http.Response) (result ProcessModuleInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessModuleSlot get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// baseAddress - module base address.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) GetProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string) (result ProcessModuleInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessModuleSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessModuleSlot", err.Error())
	}

	req, err := client.GetProcessModuleSlotPreparer(ctx, resourceGroupName, name, processID, baseAddress, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessModuleSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessModuleSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessModuleSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessModuleSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessModuleSlot", resp, "Failure responding to request")
	}

	return
}

// GetProcessModuleSlotPreparer prepares the GetProcessModuleSlot request.
func (client AppsClient) GetProcessModuleSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"baseAddress":       autorest.Encode("path", baseAddress),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessModuleSlotSender sends the GetProcessModuleSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessModuleSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessModuleSlotResponder handles the response to the GetProcessModuleSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessModuleSlotResponder(resp *http.Response) (result ProcessModuleInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessSlot get process information by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) GetProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result ProcessInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessSlot", err.Error())
	}

	req, err := client.GetProcessSlotPreparer(ctx, resourceGroupName, name, processID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessSlot", resp, "Failure responding to request")
	}

	return
}

// GetProcessSlotPreparer prepares the GetProcessSlot request.
func (client AppsClient) GetProcessSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessSlotSender sends the GetProcessSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessSlotResponder handles the response to the GetProcessSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessSlotResponder(resp *http.Response) (result ProcessInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessThread get thread information by Thread ID for a specific process, in a specific scaled-out instance in a
// web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// threadID - tID.
func (client AppsClient) GetProcessThread(ctx context.Context, resourceGroupName string, name string, processID string, threadID string) (result ProcessThreadInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessThread")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessThread", err.Error())
	}

	req, err := client.GetProcessThreadPreparer(ctx, resourceGroupName, name, processID, threadID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessThread", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessThreadSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessThread", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessThreadResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessThread", resp, "Failure responding to request")
	}

	return
}

// GetProcessThreadPreparer prepares the GetProcessThread request.
func (client AppsClient) GetProcessThreadPreparer(ctx context.Context, resourceGroupName string, name string, processID string, threadID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"threadId":          autorest.Encode("path", threadID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads/{threadId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessThreadSender sends the GetProcessThread request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessThreadSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessThreadResponder handles the response to the GetProcessThread request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessThreadResponder(resp *http.Response) (result ProcessThreadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetProcessThreadSlot get thread information by Thread ID for a specific process, in a specific scaled-out instance
// in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// threadID - tID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) GetProcessThreadSlot(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string) (result ProcessThreadInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetProcessThreadSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetProcessThreadSlot", err.Error())
	}

	req, err := client.GetProcessThreadSlotPreparer(ctx, resourceGroupName, name, processID, threadID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessThreadSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetProcessThreadSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessThreadSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetProcessThreadSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetProcessThreadSlot", resp, "Failure responding to request")
	}

	return
}

// GetProcessThreadSlotPreparer prepares the GetProcessThreadSlot request.
func (client AppsClient) GetProcessThreadSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, threadID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"threadId":          autorest.Encode("path", threadID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads/{threadId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetProcessThreadSlotSender sends the GetProcessThreadSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetProcessThreadSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetProcessThreadSlotResponder handles the response to the GetProcessThreadSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetProcessThreadSlotResponder(resp *http.Response) (result ProcessThreadInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPublicCertificate get the named public certificate for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// publicCertificateName - public certificate name.
func (client AppsClient) GetPublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string) (result PublicCertificate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetPublicCertificate")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetPublicCertificate", err.Error())
	}

	req, err := client.GetPublicCertificatePreparer(ctx, resourceGroupName, name, publicCertificateName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPublicCertificate", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPublicCertificateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPublicCertificate", resp, "Failure sending request")
		return
	}

	result, err = client.GetPublicCertificateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPublicCertificate", resp, "Failure responding to request")
	}

	return
}

// GetPublicCertificatePreparer prepares the GetPublicCertificate request.
func (client AppsClient) GetPublicCertificatePreparer(ctx context.Context, resourceGroupName string, name string, publicCertificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":                  autorest.Encode("path", name),
		"publicCertificateName": autorest.Encode("path", publicCertificateName),
		"resourceGroupName":     autorest.Encode("path", resourceGroupName),
		"subscriptionId":        autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPublicCertificateSender sends the GetPublicCertificate request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetPublicCertificateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetPublicCertificateResponder handles the response to the GetPublicCertificate request. The method always
// closes the http.Response Body.
func (client AppsClient) GetPublicCertificateResponder(resp *http.Response) (result PublicCertificate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPublicCertificateSlot get the named public certificate for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API the named binding for the production
// slot.
// publicCertificateName - public certificate name.
func (client AppsClient) GetPublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string) (result PublicCertificate, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetPublicCertificateSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetPublicCertificateSlot", err.Error())
	}

	req, err := client.GetPublicCertificateSlotPreparer(ctx, resourceGroupName, name, slot, publicCertificateName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPublicCertificateSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPublicCertificateSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPublicCertificateSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetPublicCertificateSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetPublicCertificateSlot", resp, "Failure responding to request")
	}

	return
}

// GetPublicCertificateSlotPreparer prepares the GetPublicCertificateSlot request.
func (client AppsClient) GetPublicCertificateSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":                  autorest.Encode("path", name),
		"publicCertificateName": autorest.Encode("path", publicCertificateName),
		"resourceGroupName":     autorest.Encode("path", resourceGroupName),
		"slot":                  autorest.Encode("path", slot),
		"subscriptionId":        autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPublicCertificateSlotSender sends the GetPublicCertificateSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetPublicCertificateSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetPublicCertificateSlotResponder handles the response to the GetPublicCertificateSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetPublicCertificateSlotResponder(resp *http.Response) (result PublicCertificate, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetRelayServiceConnection gets a hybrid connection configuration by its name.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection.
func (client AppsClient) GetRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetRelayServiceConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetRelayServiceConnection", err.Error())
	}

	req, err := client.GetRelayServiceConnectionPreparer(ctx, resourceGroupName, name, entityName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetRelayServiceConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetRelayServiceConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetRelayServiceConnection", resp, "Failure sending request")
		return
	}

	result, err = client.GetRelayServiceConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetRelayServiceConnection", resp, "Failure responding to request")
	}

	return
}

// GetRelayServiceConnectionPreparer prepares the GetRelayServiceConnection request.
func (client AppsClient) GetRelayServiceConnectionPreparer(ctx context.Context, resourceGroupName string, name string, entityName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetRelayServiceConnectionSender sends the GetRelayServiceConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetRelayServiceConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetRelayServiceConnectionResponder handles the response to the GetRelayServiceConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) GetRelayServiceConnectionResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetRelayServiceConnectionSlot gets a hybrid connection configuration by its name.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection.
// slot - name of the deployment slot. If a slot is not specified, the API will get a hybrid connection for the
// production slot.
func (client AppsClient) GetRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetRelayServiceConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetRelayServiceConnectionSlot", err.Error())
	}

	req, err := client.GetRelayServiceConnectionSlotPreparer(ctx, resourceGroupName, name, entityName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetRelayServiceConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetRelayServiceConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetRelayServiceConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetRelayServiceConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetRelayServiceConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// GetRelayServiceConnectionSlotPreparer prepares the GetRelayServiceConnectionSlot request.
func (client AppsClient) GetRelayServiceConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, entityName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetRelayServiceConnectionSlotSender sends the GetRelayServiceConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetRelayServiceConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetRelayServiceConnectionSlotResponder handles the response to the GetRelayServiceConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetRelayServiceConnectionSlotResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSiteExtension get site extension information by its ID for a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// siteExtensionID - site extension name.
func (client AppsClient) GetSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string) (result SiteExtensionInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSiteExtension")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSiteExtension", err.Error())
	}

	req, err := client.GetSiteExtensionPreparer(ctx, resourceGroupName, name, siteExtensionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSiteExtension", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSiteExtensionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSiteExtension", resp, "Failure sending request")
		return
	}

	result, err = client.GetSiteExtensionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSiteExtension", resp, "Failure responding to request")
	}

	return
}

// GetSiteExtensionPreparer prepares the GetSiteExtension request.
func (client AppsClient) GetSiteExtensionPreparer(ctx context.Context, resourceGroupName string, name string, siteExtensionID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"siteExtensionId":   autorest.Encode("path", siteExtensionID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSiteExtensionSender sends the GetSiteExtension request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSiteExtensionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSiteExtensionResponder handles the response to the GetSiteExtension request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSiteExtensionResponder(resp *http.Response) (result SiteExtensionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSiteExtensionSlot get site extension information by its ID for a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// siteExtensionID - site extension name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) GetSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string) (result SiteExtensionInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSiteExtensionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSiteExtensionSlot", err.Error())
	}

	req, err := client.GetSiteExtensionSlotPreparer(ctx, resourceGroupName, name, siteExtensionID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSiteExtensionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSiteExtensionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSiteExtensionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetSiteExtensionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSiteExtensionSlot", resp, "Failure responding to request")
	}

	return
}

// GetSiteExtensionSlotPreparer prepares the GetSiteExtensionSlot request.
func (client AppsClient) GetSiteExtensionSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"siteExtensionId":   autorest.Encode("path", siteExtensionID),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSiteExtensionSlotSender sends the GetSiteExtensionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSiteExtensionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSiteExtensionSlotResponder handles the response to the GetSiteExtensionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSiteExtensionSlotResponder(resp *http.Response) (result SiteExtensionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSitePhpErrorLogFlag gets web app's event logs.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetSitePhpErrorLogFlag(ctx context.Context, resourceGroupName string, name string) (result SitePhpErrorLogFlag, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSitePhpErrorLogFlag")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSitePhpErrorLogFlag", err.Error())
	}

	req, err := client.GetSitePhpErrorLogFlagPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSitePhpErrorLogFlag", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSitePhpErrorLogFlagSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSitePhpErrorLogFlag", resp, "Failure sending request")
		return
	}

	result, err = client.GetSitePhpErrorLogFlagResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSitePhpErrorLogFlag", resp, "Failure responding to request")
	}

	return
}

// GetSitePhpErrorLogFlagPreparer prepares the GetSitePhpErrorLogFlag request.
func (client AppsClient) GetSitePhpErrorLogFlagPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSitePhpErrorLogFlagSender sends the GetSitePhpErrorLogFlag request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSitePhpErrorLogFlagSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSitePhpErrorLogFlagResponder handles the response to the GetSitePhpErrorLogFlag request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSitePhpErrorLogFlagResponder(resp *http.Response) (result SitePhpErrorLogFlag, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSitePhpErrorLogFlagSlot gets web app's event logs.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) GetSitePhpErrorLogFlagSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SitePhpErrorLogFlag, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSitePhpErrorLogFlagSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSitePhpErrorLogFlagSlot", err.Error())
	}

	req, err := client.GetSitePhpErrorLogFlagSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSitePhpErrorLogFlagSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSitePhpErrorLogFlagSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSitePhpErrorLogFlagSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetSitePhpErrorLogFlagSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSitePhpErrorLogFlagSlot", resp, "Failure responding to request")
	}

	return
}

// GetSitePhpErrorLogFlagSlotPreparer prepares the GetSitePhpErrorLogFlagSlot request.
func (client AppsClient) GetSitePhpErrorLogFlagSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSitePhpErrorLogFlagSlotSender sends the GetSitePhpErrorLogFlagSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSitePhpErrorLogFlagSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSitePhpErrorLogFlagSlotResponder handles the response to the GetSitePhpErrorLogFlagSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSitePhpErrorLogFlagSlotResponder(resp *http.Response) (result SitePhpErrorLogFlag, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSlot gets the details of a web, mobile, or API app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. By default, this API returns the production slot.
func (client AppsClient) GetSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result Site, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSlot", err.Error())
	}

	req, err := client.GetSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSlot", resp, "Failure responding to request")
	}

	return
}

// GetSlotPreparer prepares the GetSlot request.
func (client AppsClient) GetSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSlotSender sends the GetSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSlotResponder handles the response to the GetSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSlotResponder(resp *http.Response) (result Site, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSourceControl gets the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GetSourceControl(ctx context.Context, resourceGroupName string, name string) (result SiteSourceControl, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSourceControl")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSourceControl", err.Error())
	}

	req, err := client.GetSourceControlPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSourceControl", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSourceControlSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSourceControl", resp, "Failure sending request")
		return
	}

	result, err = client.GetSourceControlResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSourceControl", resp, "Failure responding to request")
	}

	return
}

// GetSourceControlPreparer prepares the GetSourceControl request.
func (client AppsClient) GetSourceControlPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSourceControlSender sends the GetSourceControl request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSourceControlSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSourceControlResponder handles the response to the GetSourceControl request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSourceControlResponder(resp *http.Response) (result SiteSourceControl, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSourceControlSlot gets the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the source control
// configuration for the production slot.
func (client AppsClient) GetSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteSourceControl, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSourceControlSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSourceControlSlot", err.Error())
	}

	req, err := client.GetSourceControlSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSourceControlSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSourceControlSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSourceControlSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetSourceControlSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSourceControlSlot", resp, "Failure responding to request")
	}

	return
}

// GetSourceControlSlotPreparer prepares the GetSourceControlSlot request.
func (client AppsClient) GetSourceControlSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSourceControlSlotSender sends the GetSourceControlSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSourceControlSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSourceControlSlotResponder handles the response to the GetSourceControlSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSourceControlSlotResponder(resp *http.Response) (result SiteSourceControl, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSwiftVirtualNetworkConnection gets a Swift Virtual Network connection.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) GetSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string) (result SwiftVirtualNetwork, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSwiftVirtualNetworkConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSwiftVirtualNetworkConnection", err.Error())
	}

	req, err := client.GetSwiftVirtualNetworkConnectionPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSwiftVirtualNetworkConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSwiftVirtualNetworkConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSwiftVirtualNetworkConnection", resp, "Failure sending request")
		return
	}

	result, err = client.GetSwiftVirtualNetworkConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSwiftVirtualNetworkConnection", resp, "Failure responding to request")
	}

	return
}

// GetSwiftVirtualNetworkConnectionPreparer prepares the GetSwiftVirtualNetworkConnection request.
func (client AppsClient) GetSwiftVirtualNetworkConnectionPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSwiftVirtualNetworkConnectionSender sends the GetSwiftVirtualNetworkConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSwiftVirtualNetworkConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSwiftVirtualNetworkConnectionResponder handles the response to the GetSwiftVirtualNetworkConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSwiftVirtualNetworkConnectionResponder(resp *http.Response) (result SwiftVirtualNetwork, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSwiftVirtualNetworkConnectionSlot gets a Swift Virtual Network connection.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get a gateway for the
// production slot's Virtual Network.
func (client AppsClient) GetSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SwiftVirtualNetwork, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetSwiftVirtualNetworkConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetSwiftVirtualNetworkConnectionSlot", err.Error())
	}

	req, err := client.GetSwiftVirtualNetworkConnectionSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSwiftVirtualNetworkConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSwiftVirtualNetworkConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSwiftVirtualNetworkConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetSwiftVirtualNetworkConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetSwiftVirtualNetworkConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// GetSwiftVirtualNetworkConnectionSlotPreparer prepares the GetSwiftVirtualNetworkConnectionSlot request.
func (client AppsClient) GetSwiftVirtualNetworkConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSwiftVirtualNetworkConnectionSlotSender sends the GetSwiftVirtualNetworkConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetSwiftVirtualNetworkConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetSwiftVirtualNetworkConnectionSlotResponder handles the response to the GetSwiftVirtualNetworkConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetSwiftVirtualNetworkConnectionSlotResponder(resp *http.Response) (result SwiftVirtualNetwork, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTriggeredWebJob gets a triggered web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) GetTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result TriggeredWebJob, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetTriggeredWebJob")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetTriggeredWebJob", err.Error())
	}

	req, err := client.GetTriggeredWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTriggeredWebJobSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.GetTriggeredWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJob", resp, "Failure responding to request")
	}

	return
}

// GetTriggeredWebJobPreparer prepares the GetTriggeredWebJob request.
func (client AppsClient) GetTriggeredWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTriggeredWebJobSender sends the GetTriggeredWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetTriggeredWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetTriggeredWebJobResponder handles the response to the GetTriggeredWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) GetTriggeredWebJobResponder(resp *http.Response) (result TriggeredWebJob, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTriggeredWebJobHistory gets a triggered web job's history by its ID for an app, , or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// ID - history ID.
func (client AppsClient) GetTriggeredWebJobHistory(ctx context.Context, resourceGroupName string, name string, webJobName string, ID string) (result TriggeredJobHistory, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetTriggeredWebJobHistory")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetTriggeredWebJobHistory", err.Error())
	}

	req, err := client.GetTriggeredWebJobHistoryPreparer(ctx, resourceGroupName, name, webJobName, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobHistory", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTriggeredWebJobHistorySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobHistory", resp, "Failure sending request")
		return
	}

	result, err = client.GetTriggeredWebJobHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobHistory", resp, "Failure responding to request")
	}

	return
}

// GetTriggeredWebJobHistoryPreparer prepares the GetTriggeredWebJobHistory request.
func (client AppsClient) GetTriggeredWebJobHistoryPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTriggeredWebJobHistorySender sends the GetTriggeredWebJobHistory request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetTriggeredWebJobHistorySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetTriggeredWebJobHistoryResponder handles the response to the GetTriggeredWebJobHistory request. The method always
// closes the http.Response Body.
func (client AppsClient) GetTriggeredWebJobHistoryResponder(resp *http.Response) (result TriggeredJobHistory, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTriggeredWebJobHistorySlot gets a triggered web job's history by its ID for an app, , or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// ID - history ID.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) GetTriggeredWebJobHistorySlot(ctx context.Context, resourceGroupName string, name string, webJobName string, ID string, slot string) (result TriggeredJobHistory, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetTriggeredWebJobHistorySlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetTriggeredWebJobHistorySlot", err.Error())
	}

	req, err := client.GetTriggeredWebJobHistorySlotPreparer(ctx, resourceGroupName, name, webJobName, ID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobHistorySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTriggeredWebJobHistorySlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobHistorySlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetTriggeredWebJobHistorySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobHistorySlot", resp, "Failure responding to request")
	}

	return
}

// GetTriggeredWebJobHistorySlotPreparer prepares the GetTriggeredWebJobHistorySlot request.
func (client AppsClient) GetTriggeredWebJobHistorySlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, ID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTriggeredWebJobHistorySlotSender sends the GetTriggeredWebJobHistorySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetTriggeredWebJobHistorySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetTriggeredWebJobHistorySlotResponder handles the response to the GetTriggeredWebJobHistorySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetTriggeredWebJobHistorySlotResponder(resp *http.Response) (result TriggeredJobHistory, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTriggeredWebJobSlot gets a triggered web job by its ID for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) GetTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result TriggeredWebJob, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetTriggeredWebJobSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetTriggeredWebJobSlot", err.Error())
	}

	req, err := client.GetTriggeredWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTriggeredWebJobSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetTriggeredWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetTriggeredWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// GetTriggeredWebJobSlotPreparer prepares the GetTriggeredWebJobSlot request.
func (client AppsClient) GetTriggeredWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTriggeredWebJobSlotSender sends the GetTriggeredWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetTriggeredWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetTriggeredWebJobSlotResponder handles the response to the GetTriggeredWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetTriggeredWebJobSlotResponder(resp *http.Response) (result TriggeredWebJob, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVnetConnection gets a virtual network the app (or deployment slot) is connected to by name.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the virtual network.
func (client AppsClient) GetVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string) (result VnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetVnetConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetVnetConnection", err.Error())
	}

	req, err := client.GetVnetConnectionPreparer(ctx, resourceGroupName, name, vnetName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVnetConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnection", resp, "Failure sending request")
		return
	}

	result, err = client.GetVnetConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnection", resp, "Failure responding to request")
	}

	return
}

// GetVnetConnectionPreparer prepares the GetVnetConnection request.
func (client AppsClient) GetVnetConnectionPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVnetConnectionSender sends the GetVnetConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetVnetConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetVnetConnectionResponder handles the response to the GetVnetConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) GetVnetConnectionResponder(resp *http.Response) (result VnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVnetConnectionGateway gets an app's Virtual Network gateway.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the Virtual Network.
// gatewayName - name of the gateway. Currently, the only supported string is "primary".
func (client AppsClient) GetVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string) (result VnetGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetVnetConnectionGateway")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetVnetConnectionGateway", err.Error())
	}

	req, err := client.GetVnetConnectionGatewayPreparer(ctx, resourceGroupName, name, vnetName, gatewayName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionGateway", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVnetConnectionGatewaySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionGateway", resp, "Failure sending request")
		return
	}

	result, err = client.GetVnetConnectionGatewayResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionGateway", resp, "Failure responding to request")
	}

	return
}

// GetVnetConnectionGatewayPreparer prepares the GetVnetConnectionGateway request.
func (client AppsClient) GetVnetConnectionGatewayPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayName":       autorest.Encode("path", gatewayName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVnetConnectionGatewaySender sends the GetVnetConnectionGateway request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetVnetConnectionGatewaySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetVnetConnectionGatewayResponder handles the response to the GetVnetConnectionGateway request. The method always
// closes the http.Response Body.
func (client AppsClient) GetVnetConnectionGatewayResponder(resp *http.Response) (result VnetGateway, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVnetConnectionGatewaySlot gets an app's Virtual Network gateway.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the Virtual Network.
// gatewayName - name of the gateway. Currently, the only supported string is "primary".
// slot - name of the deployment slot. If a slot is not specified, the API will get a gateway for the
// production slot's Virtual Network.
func (client AppsClient) GetVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string) (result VnetGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetVnetConnectionGatewaySlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetVnetConnectionGatewaySlot", err.Error())
	}

	req, err := client.GetVnetConnectionGatewaySlotPreparer(ctx, resourceGroupName, name, vnetName, gatewayName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionGatewaySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVnetConnectionGatewaySlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionGatewaySlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetVnetConnectionGatewaySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionGatewaySlot", resp, "Failure responding to request")
	}

	return
}

// GetVnetConnectionGatewaySlotPreparer prepares the GetVnetConnectionGatewaySlot request.
func (client AppsClient) GetVnetConnectionGatewaySlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayName":       autorest.Encode("path", gatewayName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVnetConnectionGatewaySlotSender sends the GetVnetConnectionGatewaySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetVnetConnectionGatewaySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetVnetConnectionGatewaySlotResponder handles the response to the GetVnetConnectionGatewaySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetVnetConnectionGatewaySlotResponder(resp *http.Response) (result VnetGateway, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVnetConnectionSlot gets a virtual network the app (or deployment slot) is connected to by name.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the virtual network.
// slot - name of the deployment slot. If a slot is not specified, the API will get the named virtual network
// for the production slot.
func (client AppsClient) GetVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string) (result VnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetVnetConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetVnetConnectionSlot", err.Error())
	}

	req, err := client.GetVnetConnectionSlotPreparer(ctx, resourceGroupName, name, vnetName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVnetConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetVnetConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetVnetConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// GetVnetConnectionSlotPreparer prepares the GetVnetConnectionSlot request.
func (client AppsClient) GetVnetConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVnetConnectionSlotSender sends the GetVnetConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetVnetConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetVnetConnectionSlotResponder handles the response to the GetVnetConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetVnetConnectionSlotResponder(resp *http.Response) (result VnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetWebJob get webjob information for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of the web job.
func (client AppsClient) GetWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result Job, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetWebJob")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetWebJob", err.Error())
	}

	req, err := client.GetWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetWebJobSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.GetWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebJob", resp, "Failure responding to request")
	}

	return
}

// GetWebJobPreparer prepares the GetWebJob request.
func (client AppsClient) GetWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetWebJobSender sends the GetWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetWebJobResponder handles the response to the GetWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) GetWebJobResponder(resp *http.Response) (result Job, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetWebJobSlot get webjob information for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of the web job.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) GetWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result Job, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetWebJobSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetWebJobSlot", err.Error())
	}

	req, err := client.GetWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetWebJobSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// GetWebJobSlotPreparer prepares the GetWebJobSlot request.
func (client AppsClient) GetWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetWebJobSlotSender sends the GetWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetWebJobSlotResponder handles the response to the GetWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetWebJobSlotResponder(resp *http.Response) (result Job, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetWebSiteContainerLogs gets the last lines of docker logs for the given site
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) GetWebSiteContainerLogs(ctx context.Context, resourceGroupName string, name string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetWebSiteContainerLogs")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetWebSiteContainerLogs", err.Error())
	}

	req, err := client.GetWebSiteContainerLogsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebSiteContainerLogs", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetWebSiteContainerLogsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebSiteContainerLogs", resp, "Failure sending request")
		return
	}

	result, err = client.GetWebSiteContainerLogsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebSiteContainerLogs", resp, "Failure responding to request")
	}

	return
}

// GetWebSiteContainerLogsPreparer prepares the GetWebSiteContainerLogs request.
func (client AppsClient) GetWebSiteContainerLogsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetWebSiteContainerLogsSender sends the GetWebSiteContainerLogs request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetWebSiteContainerLogsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetWebSiteContainerLogsResponder handles the response to the GetWebSiteContainerLogs request. The method always
// closes the http.Response Body.
func (client AppsClient) GetWebSiteContainerLogsResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent))
	result.Response = autorest.Response{Response: resp}
	return
}

// GetWebSiteContainerLogsSlot gets the last lines of docker logs for the given site
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) GetWebSiteContainerLogsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.GetWebSiteContainerLogsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "GetWebSiteContainerLogsSlot", err.Error())
	}

	req, err := client.GetWebSiteContainerLogsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebSiteContainerLogsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetWebSiteContainerLogsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebSiteContainerLogsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.GetWebSiteContainerLogsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "GetWebSiteContainerLogsSlot", resp, "Failure responding to request")
	}

	return
}

// GetWebSiteContainerLogsSlotPreparer prepares the GetWebSiteContainerLogsSlot request.
func (client AppsClient) GetWebSiteContainerLogsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetWebSiteContainerLogsSlotSender sends the GetWebSiteContainerLogsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) GetWebSiteContainerLogsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// GetWebSiteContainerLogsSlotResponder handles the response to the GetWebSiteContainerLogsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) GetWebSiteContainerLogsSlotResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent))
	result.Response = autorest.Response{Response: resp}
	return
}

// InstallSiteExtension install site extension on a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// siteExtensionID - site extension name.
func (client AppsClient) InstallSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string) (result AppsInstallSiteExtensionFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.InstallSiteExtension")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "InstallSiteExtension", err.Error())
	}

	req, err := client.InstallSiteExtensionPreparer(ctx, resourceGroupName, name, siteExtensionID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "InstallSiteExtension", nil, "Failure preparing request")
		return
	}

	result, err = client.InstallSiteExtensionSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "InstallSiteExtension", result.Response(), "Failure sending request")
		return
	}

	return
}

// InstallSiteExtensionPreparer prepares the InstallSiteExtension request.
func (client AppsClient) InstallSiteExtensionPreparer(ctx context.Context, resourceGroupName string, name string, siteExtensionID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"siteExtensionId":   autorest.Encode("path", siteExtensionID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// InstallSiteExtensionSender sends the InstallSiteExtension request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) InstallSiteExtensionSender(req *http.Request) (future AppsInstallSiteExtensionFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// InstallSiteExtensionResponder handles the response to the InstallSiteExtension request. The method always
// closes the http.Response Body.
func (client AppsClient) InstallSiteExtensionResponder(resp *http.Response) (result SiteExtensionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// InstallSiteExtensionSlot install site extension on a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// siteExtensionID - site extension name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) InstallSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string) (result AppsInstallSiteExtensionSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.InstallSiteExtensionSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "InstallSiteExtensionSlot", err.Error())
	}

	req, err := client.InstallSiteExtensionSlotPreparer(ctx, resourceGroupName, name, siteExtensionID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "InstallSiteExtensionSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.InstallSiteExtensionSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "InstallSiteExtensionSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// InstallSiteExtensionSlotPreparer prepares the InstallSiteExtensionSlot request.
func (client AppsClient) InstallSiteExtensionSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"siteExtensionId":   autorest.Encode("path", siteExtensionID),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// InstallSiteExtensionSlotSender sends the InstallSiteExtensionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) InstallSiteExtensionSlotSender(req *http.Request) (future AppsInstallSiteExtensionSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// InstallSiteExtensionSlotResponder handles the response to the InstallSiteExtensionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) InstallSiteExtensionSlotResponder(resp *http.Response) (result SiteExtensionInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// IsCloneable shows whether an app can be cloned to another resource group or subscription.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) IsCloneable(ctx context.Context, resourceGroupName string, name string) (result SiteCloneability, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.IsCloneable")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "IsCloneable", err.Error())
	}

	req, err := client.IsCloneablePreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "IsCloneable", nil, "Failure preparing request")
		return
	}

	resp, err := client.IsCloneableSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "IsCloneable", resp, "Failure sending request")
		return
	}

	result, err = client.IsCloneableResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "IsCloneable", resp, "Failure responding to request")
	}

	return
}

// IsCloneablePreparer prepares the IsCloneable request.
func (client AppsClient) IsCloneablePreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// IsCloneableSender sends the IsCloneable request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) IsCloneableSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// IsCloneableResponder handles the response to the IsCloneable request. The method always
// closes the http.Response Body.
func (client AppsClient) IsCloneableResponder(resp *http.Response) (result SiteCloneability, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// IsCloneableSlot shows whether an app can be cloned to another resource group or subscription.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. By default, this API returns information on the production slot.
func (client AppsClient) IsCloneableSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteCloneability, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.IsCloneableSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "IsCloneableSlot", err.Error())
	}

	req, err := client.IsCloneableSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "IsCloneableSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.IsCloneableSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "IsCloneableSlot", resp, "Failure sending request")
		return
	}

	result, err = client.IsCloneableSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "IsCloneableSlot", resp, "Failure responding to request")
	}

	return
}

// IsCloneableSlotPreparer prepares the IsCloneableSlot request.
func (client AppsClient) IsCloneableSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// IsCloneableSlotSender sends the IsCloneableSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) IsCloneableSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// IsCloneableSlotResponder handles the response to the IsCloneableSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) IsCloneableSlotResponder(resp *http.Response) (result SiteCloneability, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// List get all apps for a subscription.
func (client AppsClient) List(ctx context.Context) (result AppCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.List")
		defer func() {
			sc := -1
			if result.ac.Response.Response != nil {
				sc = result.ac.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listNextResults
	req, err := client.ListPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "List", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSender(req)
	if err != nil {
		result.ac.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "List", resp, "Failure sending request")
		return
	}

	result.ac, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "List", resp, "Failure responding to request")
	}

	return
}

// ListPreparer prepares the List request.
func (client AppsClient) ListPreparer(ctx context.Context) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSender sends the List request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListResponder handles the response to the List request. The method always
// closes the http.Response Body.
func (client AppsClient) ListResponder(resp *http.Response) (result AppCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listNextResults retrieves the next set of results, if any.
func (client AppsClient) listNextResults(ctx context.Context, lastResults AppCollection) (result AppCollection, err error) {
	req, err := lastResults.appCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListComplete(ctx context.Context) (result AppCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.List")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.List(ctx)
	return
}

// ListApplicationSettings gets the application settings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListApplicationSettings(ctx context.Context, resourceGroupName string, name string) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListApplicationSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListApplicationSettings", err.Error())
	}

	req, err := client.ListApplicationSettingsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListApplicationSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListApplicationSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListApplicationSettings", resp, "Failure sending request")
		return
	}

	result, err = client.ListApplicationSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListApplicationSettings", resp, "Failure responding to request")
	}

	return
}

// ListApplicationSettingsPreparer prepares the ListApplicationSettings request.
func (client AppsClient) ListApplicationSettingsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListApplicationSettingsSender sends the ListApplicationSettings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListApplicationSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListApplicationSettingsResponder handles the response to the ListApplicationSettings request. The method always
// closes the http.Response Body.
func (client AppsClient) ListApplicationSettingsResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListApplicationSettingsSlot gets the application settings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the application settings
// for the production slot.
func (client AppsClient) ListApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListApplicationSettingsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListApplicationSettingsSlot", err.Error())
	}

	req, err := client.ListApplicationSettingsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListApplicationSettingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListApplicationSettingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListApplicationSettingsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListApplicationSettingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListApplicationSettingsSlot", resp, "Failure responding to request")
	}

	return
}

// ListApplicationSettingsSlotPreparer prepares the ListApplicationSettingsSlot request.
func (client AppsClient) ListApplicationSettingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListApplicationSettingsSlotSender sends the ListApplicationSettingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListApplicationSettingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListApplicationSettingsSlotResponder handles the response to the ListApplicationSettingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListApplicationSettingsSlotResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListAzureStorageAccounts gets the Azure storage account configurations of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string) (result AzureStoragePropertyDictionaryResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListAzureStorageAccounts")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListAzureStorageAccounts", err.Error())
	}

	req, err := client.ListAzureStorageAccountsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListAzureStorageAccounts", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListAzureStorageAccountsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListAzureStorageAccounts", resp, "Failure sending request")
		return
	}

	result, err = client.ListAzureStorageAccountsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListAzureStorageAccounts", resp, "Failure responding to request")
	}

	return
}

// ListAzureStorageAccountsPreparer prepares the ListAzureStorageAccounts request.
func (client AppsClient) ListAzureStorageAccountsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListAzureStorageAccountsSender sends the ListAzureStorageAccounts request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListAzureStorageAccountsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListAzureStorageAccountsResponder handles the response to the ListAzureStorageAccounts request. The method always
// closes the http.Response Body.
func (client AppsClient) ListAzureStorageAccountsResponder(resp *http.Response) (result AzureStoragePropertyDictionaryResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListAzureStorageAccountsSlot gets the Azure storage account configurations of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will update the Azure storage
// account configurations for the production slot.
func (client AppsClient) ListAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result AzureStoragePropertyDictionaryResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListAzureStorageAccountsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListAzureStorageAccountsSlot", err.Error())
	}

	req, err := client.ListAzureStorageAccountsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListAzureStorageAccountsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListAzureStorageAccountsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListAzureStorageAccountsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListAzureStorageAccountsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListAzureStorageAccountsSlot", resp, "Failure responding to request")
	}

	return
}

// ListAzureStorageAccountsSlotPreparer prepares the ListAzureStorageAccountsSlot request.
func (client AppsClient) ListAzureStorageAccountsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListAzureStorageAccountsSlotSender sends the ListAzureStorageAccountsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListAzureStorageAccountsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListAzureStorageAccountsSlotResponder handles the response to the ListAzureStorageAccountsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListAzureStorageAccountsSlotResponder(resp *http.Response) (result AzureStoragePropertyDictionaryResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListBackups gets existing backups of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListBackups(ctx context.Context, resourceGroupName string, name string) (result BackupItemCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListBackups")
		defer func() {
			sc := -1
			if result.bic.Response.Response != nil {
				sc = result.bic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListBackups", err.Error())
	}

	result.fn = client.listBackupsNextResults
	req, err := client.ListBackupsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackups", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListBackupsSender(req)
	if err != nil {
		result.bic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackups", resp, "Failure sending request")
		return
	}

	result.bic, err = client.ListBackupsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackups", resp, "Failure responding to request")
	}

	return
}

// ListBackupsPreparer prepares the ListBackups request.
func (client AppsClient) ListBackupsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListBackupsSender sends the ListBackups request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListBackupsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListBackupsResponder handles the response to the ListBackups request. The method always
// closes the http.Response Body.
func (client AppsClient) ListBackupsResponder(resp *http.Response) (result BackupItemCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listBackupsNextResults retrieves the next set of results, if any.
func (client AppsClient) listBackupsNextResults(ctx context.Context, lastResults BackupItemCollection) (result BackupItemCollection, err error) {
	req, err := lastResults.backupItemCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listBackupsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListBackupsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listBackupsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListBackupsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listBackupsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListBackupsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListBackupsComplete(ctx context.Context, resourceGroupName string, name string) (result BackupItemCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListBackups")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListBackups(ctx, resourceGroupName, name)
	return
}

// ListBackupsSlot gets existing backups of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get backups of the production
// slot.
func (client AppsClient) ListBackupsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result BackupItemCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListBackupsSlot")
		defer func() {
			sc := -1
			if result.bic.Response.Response != nil {
				sc = result.bic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListBackupsSlot", err.Error())
	}

	result.fn = client.listBackupsSlotNextResults
	req, err := client.ListBackupsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListBackupsSlotSender(req)
	if err != nil {
		result.bic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupsSlot", resp, "Failure sending request")
		return
	}

	result.bic, err = client.ListBackupsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupsSlot", resp, "Failure responding to request")
	}

	return
}

// ListBackupsSlotPreparer prepares the ListBackupsSlot request.
func (client AppsClient) ListBackupsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListBackupsSlotSender sends the ListBackupsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListBackupsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListBackupsSlotResponder handles the response to the ListBackupsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListBackupsSlotResponder(resp *http.Response) (result BackupItemCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listBackupsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listBackupsSlotNextResults(ctx context.Context, lastResults BackupItemCollection) (result BackupItemCollection, err error) {
	req, err := lastResults.backupItemCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listBackupsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListBackupsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listBackupsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListBackupsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listBackupsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListBackupsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListBackupsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result BackupItemCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListBackupsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListBackupsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListBackupStatusSecrets gets status of a web app backup that may be in progress, including secrets associated with
// the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new URL is
// passed in the request body.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// backupID - ID of backup.
// request - information on backup request.
func (client AppsClient) ListBackupStatusSecrets(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest) (result BackupItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListBackupStatusSecrets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.BackupRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.BackupRequestProperties.BackupSchedule", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.BackupSchedule.FrequencyInterval", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.KeepAtLeastOneBackup", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.RetentionPeriodInDays", Name: validation.Null, Rule: true, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListBackupStatusSecrets", err.Error())
	}

	req, err := client.ListBackupStatusSecretsPreparer(ctx, resourceGroupName, name, backupID, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupStatusSecrets", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListBackupStatusSecretsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupStatusSecrets", resp, "Failure sending request")
		return
	}

	result, err = client.ListBackupStatusSecretsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupStatusSecrets", resp, "Failure responding to request")
	}

	return
}

// ListBackupStatusSecretsPreparer prepares the ListBackupStatusSecrets request.
func (client AppsClient) ListBackupStatusSecretsPreparer(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListBackupStatusSecretsSender sends the ListBackupStatusSecrets request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListBackupStatusSecretsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListBackupStatusSecretsResponder handles the response to the ListBackupStatusSecrets request. The method always
// closes the http.Response Body.
func (client AppsClient) ListBackupStatusSecretsResponder(resp *http.Response) (result BackupItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListBackupStatusSecretsSlot gets status of a web app backup that may be in progress, including secrets associated
// with the backup, such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the backup if a new
// URL is passed in the request body.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// backupID - ID of backup.
// request - information on backup request.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) ListBackupStatusSecretsSlot(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, slot string) (result BackupItem, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListBackupStatusSecretsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.BackupRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.BackupRequestProperties.BackupSchedule", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.BackupSchedule.FrequencyInterval", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.KeepAtLeastOneBackup", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.RetentionPeriodInDays", Name: validation.Null, Rule: true, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListBackupStatusSecretsSlot", err.Error())
	}

	req, err := client.ListBackupStatusSecretsSlotPreparer(ctx, resourceGroupName, name, backupID, request, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupStatusSecretsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListBackupStatusSecretsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupStatusSecretsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListBackupStatusSecretsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListBackupStatusSecretsSlot", resp, "Failure responding to request")
	}

	return
}

// ListBackupStatusSecretsSlotPreparer prepares the ListBackupStatusSecretsSlot request.
func (client AppsClient) ListBackupStatusSecretsSlotPreparer(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListBackupStatusSecretsSlotSender sends the ListBackupStatusSecretsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListBackupStatusSecretsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListBackupStatusSecretsSlotResponder handles the response to the ListBackupStatusSecretsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListBackupStatusSecretsSlotResponder(resp *http.Response) (result BackupItem, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListByResourceGroup gets all web, mobile, and API apps in the specified resource group.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// includeSlots - specify <strong>true</strong> to include deployment slots in results. The default is false,
// which only gives you the production slot of all apps.
func (client AppsClient) ListByResourceGroup(ctx context.Context, resourceGroupName string, includeSlots *bool) (result AppCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListByResourceGroup")
		defer func() {
			sc := -1
			if result.ac.Response.Response != nil {
				sc = result.ac.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListByResourceGroup", err.Error())
	}

	result.fn = client.listByResourceGroupNextResults
	req, err := client.ListByResourceGroupPreparer(ctx, resourceGroupName, includeSlots)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListByResourceGroup", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListByResourceGroupSender(req)
	if err != nil {
		result.ac.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListByResourceGroup", resp, "Failure sending request")
		return
	}

	result.ac, err = client.ListByResourceGroupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListByResourceGroup", resp, "Failure responding to request")
	}

	return
}

// ListByResourceGroupPreparer prepares the ListByResourceGroup request.
func (client AppsClient) ListByResourceGroupPreparer(ctx context.Context, resourceGroupName string, includeSlots *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if includeSlots != nil {
		queryParameters["includeSlots"] = autorest.Encode("query", *includeSlots)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListByResourceGroupSender sends the ListByResourceGroup request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListByResourceGroupSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListByResourceGroupResponder handles the response to the ListByResourceGroup request. The method always
// closes the http.Response Body.
func (client AppsClient) ListByResourceGroupResponder(resp *http.Response) (result AppCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listByResourceGroupNextResults retrieves the next set of results, if any.
func (client AppsClient) listByResourceGroupNextResults(ctx context.Context, lastResults AppCollection) (result AppCollection, err error) {
	req, err := lastResults.appCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listByResourceGroupNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListByResourceGroupSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listByResourceGroupNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListByResourceGroupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listByResourceGroupNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListByResourceGroupComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListByResourceGroupComplete(ctx context.Context, resourceGroupName string, includeSlots *bool) (result AppCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListByResourceGroup")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListByResourceGroup(ctx, resourceGroupName, includeSlots)
	return
}

// ListConfigurations list the configurations of an app
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListConfigurations(ctx context.Context, resourceGroupName string, name string) (result SiteConfigResourceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurations")
		defer func() {
			sc := -1
			if result.scrc.Response.Response != nil {
				sc = result.scrc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListConfigurations", err.Error())
	}

	result.fn = client.listConfigurationsNextResults
	req, err := client.ListConfigurationsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurations", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConfigurationsSender(req)
	if err != nil {
		result.scrc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurations", resp, "Failure sending request")
		return
	}

	result.scrc, err = client.ListConfigurationsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurations", resp, "Failure responding to request")
	}

	return
}

// ListConfigurationsPreparer prepares the ListConfigurations request.
func (client AppsClient) ListConfigurationsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConfigurationsSender sends the ListConfigurations request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListConfigurationsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListConfigurationsResponder handles the response to the ListConfigurations request. The method always
// closes the http.Response Body.
func (client AppsClient) ListConfigurationsResponder(resp *http.Response) (result SiteConfigResourceCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listConfigurationsNextResults retrieves the next set of results, if any.
func (client AppsClient) listConfigurationsNextResults(ctx context.Context, lastResults SiteConfigResourceCollection) (result SiteConfigResourceCollection, err error) {
	req, err := lastResults.siteConfigResourceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListConfigurationsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListConfigurationsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListConfigurationsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListConfigurationsComplete(ctx context.Context, resourceGroupName string, name string) (result SiteConfigResourceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurations")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListConfigurations(ctx, resourceGroupName, name)
	return
}

// ListConfigurationSnapshotInfo gets a list of web app configuration snapshots identifiers. Each element of the list
// contains a timestamp and the ID of the snapshot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListConfigurationSnapshotInfo(ctx context.Context, resourceGroupName string, name string) (result SiteConfigurationSnapshotInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurationSnapshotInfo")
		defer func() {
			sc := -1
			if result.scsic.Response.Response != nil {
				sc = result.scsic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListConfigurationSnapshotInfo", err.Error())
	}

	result.fn = client.listConfigurationSnapshotInfoNextResults
	req, err := client.ListConfigurationSnapshotInfoPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationSnapshotInfo", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConfigurationSnapshotInfoSender(req)
	if err != nil {
		result.scsic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationSnapshotInfo", resp, "Failure sending request")
		return
	}

	result.scsic, err = client.ListConfigurationSnapshotInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationSnapshotInfo", resp, "Failure responding to request")
	}

	return
}

// ListConfigurationSnapshotInfoPreparer prepares the ListConfigurationSnapshotInfo request.
func (client AppsClient) ListConfigurationSnapshotInfoPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConfigurationSnapshotInfoSender sends the ListConfigurationSnapshotInfo request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListConfigurationSnapshotInfoSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListConfigurationSnapshotInfoResponder handles the response to the ListConfigurationSnapshotInfo request. The method always
// closes the http.Response Body.
func (client AppsClient) ListConfigurationSnapshotInfoResponder(resp *http.Response) (result SiteConfigurationSnapshotInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listConfigurationSnapshotInfoNextResults retrieves the next set of results, if any.
func (client AppsClient) listConfigurationSnapshotInfoNextResults(ctx context.Context, lastResults SiteConfigurationSnapshotInfoCollection) (result SiteConfigurationSnapshotInfoCollection, err error) {
	req, err := lastResults.siteConfigurationSnapshotInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationSnapshotInfoNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListConfigurationSnapshotInfoSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationSnapshotInfoNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListConfigurationSnapshotInfoResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationSnapshotInfoNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListConfigurationSnapshotInfoComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListConfigurationSnapshotInfoComplete(ctx context.Context, resourceGroupName string, name string) (result SiteConfigurationSnapshotInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurationSnapshotInfo")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListConfigurationSnapshotInfo(ctx, resourceGroupName, name)
	return
}

// ListConfigurationSnapshotInfoSlot gets a list of web app configuration snapshots identifiers. Each element of the
// list contains a timestamp and the ID of the snapshot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will return configuration for the
// production slot.
func (client AppsClient) ListConfigurationSnapshotInfoSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteConfigurationSnapshotInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurationSnapshotInfoSlot")
		defer func() {
			sc := -1
			if result.scsic.Response.Response != nil {
				sc = result.scsic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListConfigurationSnapshotInfoSlot", err.Error())
	}

	result.fn = client.listConfigurationSnapshotInfoSlotNextResults
	req, err := client.ListConfigurationSnapshotInfoSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationSnapshotInfoSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConfigurationSnapshotInfoSlotSender(req)
	if err != nil {
		result.scsic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationSnapshotInfoSlot", resp, "Failure sending request")
		return
	}

	result.scsic, err = client.ListConfigurationSnapshotInfoSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationSnapshotInfoSlot", resp, "Failure responding to request")
	}

	return
}

// ListConfigurationSnapshotInfoSlotPreparer prepares the ListConfigurationSnapshotInfoSlot request.
func (client AppsClient) ListConfigurationSnapshotInfoSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConfigurationSnapshotInfoSlotSender sends the ListConfigurationSnapshotInfoSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListConfigurationSnapshotInfoSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListConfigurationSnapshotInfoSlotResponder handles the response to the ListConfigurationSnapshotInfoSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListConfigurationSnapshotInfoSlotResponder(resp *http.Response) (result SiteConfigurationSnapshotInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listConfigurationSnapshotInfoSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listConfigurationSnapshotInfoSlotNextResults(ctx context.Context, lastResults SiteConfigurationSnapshotInfoCollection) (result SiteConfigurationSnapshotInfoCollection, err error) {
	req, err := lastResults.siteConfigurationSnapshotInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationSnapshotInfoSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListConfigurationSnapshotInfoSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationSnapshotInfoSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListConfigurationSnapshotInfoSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationSnapshotInfoSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListConfigurationSnapshotInfoSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListConfigurationSnapshotInfoSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteConfigurationSnapshotInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurationSnapshotInfoSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListConfigurationSnapshotInfoSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListConfigurationsSlot list the configurations of an app
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will return configuration for the
// production slot.
func (client AppsClient) ListConfigurationsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteConfigResourceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurationsSlot")
		defer func() {
			sc := -1
			if result.scrc.Response.Response != nil {
				sc = result.scrc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListConfigurationsSlot", err.Error())
	}

	result.fn = client.listConfigurationsSlotNextResults
	req, err := client.ListConfigurationsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConfigurationsSlotSender(req)
	if err != nil {
		result.scrc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationsSlot", resp, "Failure sending request")
		return
	}

	result.scrc, err = client.ListConfigurationsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConfigurationsSlot", resp, "Failure responding to request")
	}

	return
}

// ListConfigurationsSlotPreparer prepares the ListConfigurationsSlot request.
func (client AppsClient) ListConfigurationsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConfigurationsSlotSender sends the ListConfigurationsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListConfigurationsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListConfigurationsSlotResponder handles the response to the ListConfigurationsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListConfigurationsSlotResponder(resp *http.Response) (result SiteConfigResourceCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listConfigurationsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listConfigurationsSlotNextResults(ctx context.Context, lastResults SiteConfigResourceCollection) (result SiteConfigResourceCollection, err error) {
	req, err := lastResults.siteConfigResourceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListConfigurationsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListConfigurationsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listConfigurationsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListConfigurationsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListConfigurationsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteConfigResourceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConfigurationsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListConfigurationsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListConnectionStrings gets the connection strings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListConnectionStrings(ctx context.Context, resourceGroupName string, name string) (result ConnectionStringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConnectionStrings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListConnectionStrings", err.Error())
	}

	req, err := client.ListConnectionStringsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConnectionStrings", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConnectionStringsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConnectionStrings", resp, "Failure sending request")
		return
	}

	result, err = client.ListConnectionStringsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConnectionStrings", resp, "Failure responding to request")
	}

	return
}

// ListConnectionStringsPreparer prepares the ListConnectionStrings request.
func (client AppsClient) ListConnectionStringsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConnectionStringsSender sends the ListConnectionStrings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListConnectionStringsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListConnectionStringsResponder handles the response to the ListConnectionStrings request. The method always
// closes the http.Response Body.
func (client AppsClient) ListConnectionStringsResponder(resp *http.Response) (result ConnectionStringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListConnectionStringsSlot gets the connection strings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the connection settings for
// the production slot.
func (client AppsClient) ListConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ConnectionStringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListConnectionStringsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListConnectionStringsSlot", err.Error())
	}

	req, err := client.ListConnectionStringsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConnectionStringsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConnectionStringsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConnectionStringsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListConnectionStringsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListConnectionStringsSlot", resp, "Failure responding to request")
	}

	return
}

// ListConnectionStringsSlotPreparer prepares the ListConnectionStringsSlot request.
func (client AppsClient) ListConnectionStringsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConnectionStringsSlotSender sends the ListConnectionStringsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListConnectionStringsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListConnectionStringsSlotResponder handles the response to the ListConnectionStringsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListConnectionStringsSlotResponder(resp *http.Response) (result ConnectionStringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListContinuousWebJobs list continuous web jobs for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
func (client AppsClient) ListContinuousWebJobs(ctx context.Context, resourceGroupName string, name string) (result ContinuousWebJobCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListContinuousWebJobs")
		defer func() {
			sc := -1
			if result.cwjc.Response.Response != nil {
				sc = result.cwjc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListContinuousWebJobs", err.Error())
	}

	result.fn = client.listContinuousWebJobsNextResults
	req, err := client.ListContinuousWebJobsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListContinuousWebJobs", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListContinuousWebJobsSender(req)
	if err != nil {
		result.cwjc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListContinuousWebJobs", resp, "Failure sending request")
		return
	}

	result.cwjc, err = client.ListContinuousWebJobsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListContinuousWebJobs", resp, "Failure responding to request")
	}

	return
}

// ListContinuousWebJobsPreparer prepares the ListContinuousWebJobs request.
func (client AppsClient) ListContinuousWebJobsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListContinuousWebJobsSender sends the ListContinuousWebJobs request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListContinuousWebJobsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListContinuousWebJobsResponder handles the response to the ListContinuousWebJobs request. The method always
// closes the http.Response Body.
func (client AppsClient) ListContinuousWebJobsResponder(resp *http.Response) (result ContinuousWebJobCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listContinuousWebJobsNextResults retrieves the next set of results, if any.
func (client AppsClient) listContinuousWebJobsNextResults(ctx context.Context, lastResults ContinuousWebJobCollection) (result ContinuousWebJobCollection, err error) {
	req, err := lastResults.continuousWebJobCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listContinuousWebJobsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListContinuousWebJobsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listContinuousWebJobsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListContinuousWebJobsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listContinuousWebJobsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListContinuousWebJobsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListContinuousWebJobsComplete(ctx context.Context, resourceGroupName string, name string) (result ContinuousWebJobCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListContinuousWebJobs")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListContinuousWebJobs(ctx, resourceGroupName, name)
	return
}

// ListContinuousWebJobsSlot list continuous web jobs for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) ListContinuousWebJobsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ContinuousWebJobCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListContinuousWebJobsSlot")
		defer func() {
			sc := -1
			if result.cwjc.Response.Response != nil {
				sc = result.cwjc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListContinuousWebJobsSlot", err.Error())
	}

	result.fn = client.listContinuousWebJobsSlotNextResults
	req, err := client.ListContinuousWebJobsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListContinuousWebJobsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListContinuousWebJobsSlotSender(req)
	if err != nil {
		result.cwjc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListContinuousWebJobsSlot", resp, "Failure sending request")
		return
	}

	result.cwjc, err = client.ListContinuousWebJobsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListContinuousWebJobsSlot", resp, "Failure responding to request")
	}

	return
}

// ListContinuousWebJobsSlotPreparer prepares the ListContinuousWebJobsSlot request.
func (client AppsClient) ListContinuousWebJobsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListContinuousWebJobsSlotSender sends the ListContinuousWebJobsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListContinuousWebJobsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListContinuousWebJobsSlotResponder handles the response to the ListContinuousWebJobsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListContinuousWebJobsSlotResponder(resp *http.Response) (result ContinuousWebJobCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listContinuousWebJobsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listContinuousWebJobsSlotNextResults(ctx context.Context, lastResults ContinuousWebJobCollection) (result ContinuousWebJobCollection, err error) {
	req, err := lastResults.continuousWebJobCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listContinuousWebJobsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListContinuousWebJobsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listContinuousWebJobsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListContinuousWebJobsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listContinuousWebJobsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListContinuousWebJobsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListContinuousWebJobsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result ContinuousWebJobCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListContinuousWebJobsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListContinuousWebJobsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListDeploymentLog list deployment log for specific deployment for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - the ID of a specific deployment. This is the value of the name property in the JSON response from "GET
// /api/sites/{siteName}/deployments".
func (client AppsClient) ListDeploymentLog(ctx context.Context, resourceGroupName string, name string, ID string) (result Deployment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDeploymentLog")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListDeploymentLog", err.Error())
	}

	req, err := client.ListDeploymentLogPreparer(ctx, resourceGroupName, name, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentLog", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDeploymentLogSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentLog", resp, "Failure sending request")
		return
	}

	result, err = client.ListDeploymentLogResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentLog", resp, "Failure responding to request")
	}

	return
}

// ListDeploymentLogPreparer prepares the ListDeploymentLog request.
func (client AppsClient) ListDeploymentLogPreparer(ctx context.Context, resourceGroupName string, name string, ID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDeploymentLogSender sends the ListDeploymentLog request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListDeploymentLogSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListDeploymentLogResponder handles the response to the ListDeploymentLog request. The method always
// closes the http.Response Body.
func (client AppsClient) ListDeploymentLogResponder(resp *http.Response) (result Deployment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListDeploymentLogSlot list deployment log for specific deployment for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// ID - the ID of a specific deployment. This is the value of the name property in the JSON response from "GET
// /api/sites/{siteName}/deployments".
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) ListDeploymentLogSlot(ctx context.Context, resourceGroupName string, name string, ID string, slot string) (result Deployment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDeploymentLogSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListDeploymentLogSlot", err.Error())
	}

	req, err := client.ListDeploymentLogSlotPreparer(ctx, resourceGroupName, name, ID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentLogSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDeploymentLogSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentLogSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListDeploymentLogSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentLogSlot", resp, "Failure responding to request")
	}

	return
}

// ListDeploymentLogSlotPreparer prepares the ListDeploymentLogSlot request.
func (client AppsClient) ListDeploymentLogSlotPreparer(ctx context.Context, resourceGroupName string, name string, ID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id":                autorest.Encode("path", ID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDeploymentLogSlotSender sends the ListDeploymentLogSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListDeploymentLogSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListDeploymentLogSlotResponder handles the response to the ListDeploymentLogSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListDeploymentLogSlotResponder(resp *http.Response) (result Deployment, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListDeployments list deployments for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListDeployments(ctx context.Context, resourceGroupName string, name string) (result DeploymentCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDeployments")
		defer func() {
			sc := -1
			if result.dc.Response.Response != nil {
				sc = result.dc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListDeployments", err.Error())
	}

	result.fn = client.listDeploymentsNextResults
	req, err := client.ListDeploymentsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeployments", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDeploymentsSender(req)
	if err != nil {
		result.dc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeployments", resp, "Failure sending request")
		return
	}

	result.dc, err = client.ListDeploymentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeployments", resp, "Failure responding to request")
	}

	return
}

// ListDeploymentsPreparer prepares the ListDeployments request.
func (client AppsClient) ListDeploymentsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDeploymentsSender sends the ListDeployments request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListDeploymentsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListDeploymentsResponder handles the response to the ListDeployments request. The method always
// closes the http.Response Body.
func (client AppsClient) ListDeploymentsResponder(resp *http.Response) (result DeploymentCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listDeploymentsNextResults retrieves the next set of results, if any.
func (client AppsClient) listDeploymentsNextResults(ctx context.Context, lastResults DeploymentCollection) (result DeploymentCollection, err error) {
	req, err := lastResults.deploymentCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDeploymentsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListDeploymentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDeploymentsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListDeploymentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listDeploymentsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListDeploymentsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListDeploymentsComplete(ctx context.Context, resourceGroupName string, name string) (result DeploymentCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDeployments")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListDeployments(ctx, resourceGroupName, name)
	return
}

// ListDeploymentsSlot list deployments for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) ListDeploymentsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result DeploymentCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDeploymentsSlot")
		defer func() {
			sc := -1
			if result.dc.Response.Response != nil {
				sc = result.dc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListDeploymentsSlot", err.Error())
	}

	result.fn = client.listDeploymentsSlotNextResults
	req, err := client.ListDeploymentsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDeploymentsSlotSender(req)
	if err != nil {
		result.dc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentsSlot", resp, "Failure sending request")
		return
	}

	result.dc, err = client.ListDeploymentsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDeploymentsSlot", resp, "Failure responding to request")
	}

	return
}

// ListDeploymentsSlotPreparer prepares the ListDeploymentsSlot request.
func (client AppsClient) ListDeploymentsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDeploymentsSlotSender sends the ListDeploymentsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListDeploymentsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListDeploymentsSlotResponder handles the response to the ListDeploymentsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListDeploymentsSlotResponder(resp *http.Response) (result DeploymentCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listDeploymentsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listDeploymentsSlotNextResults(ctx context.Context, lastResults DeploymentCollection) (result DeploymentCollection, err error) {
	req, err := lastResults.deploymentCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDeploymentsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListDeploymentsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDeploymentsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListDeploymentsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listDeploymentsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListDeploymentsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListDeploymentsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result DeploymentCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDeploymentsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListDeploymentsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListDomainOwnershipIdentifiers lists ownership identifiers for domain associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListDomainOwnershipIdentifiers(ctx context.Context, resourceGroupName string, name string) (result IdentifierCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDomainOwnershipIdentifiers")
		defer func() {
			sc := -1
			if result.ic.Response.Response != nil {
				sc = result.ic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListDomainOwnershipIdentifiers", err.Error())
	}

	result.fn = client.listDomainOwnershipIdentifiersNextResults
	req, err := client.ListDomainOwnershipIdentifiersPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDomainOwnershipIdentifiers", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDomainOwnershipIdentifiersSender(req)
	if err != nil {
		result.ic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDomainOwnershipIdentifiers", resp, "Failure sending request")
		return
	}

	result.ic, err = client.ListDomainOwnershipIdentifiersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDomainOwnershipIdentifiers", resp, "Failure responding to request")
	}

	return
}

// ListDomainOwnershipIdentifiersPreparer prepares the ListDomainOwnershipIdentifiers request.
func (client AppsClient) ListDomainOwnershipIdentifiersPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDomainOwnershipIdentifiersSender sends the ListDomainOwnershipIdentifiers request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListDomainOwnershipIdentifiersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListDomainOwnershipIdentifiersResponder handles the response to the ListDomainOwnershipIdentifiers request. The method always
// closes the http.Response Body.
func (client AppsClient) ListDomainOwnershipIdentifiersResponder(resp *http.Response) (result IdentifierCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listDomainOwnershipIdentifiersNextResults retrieves the next set of results, if any.
func (client AppsClient) listDomainOwnershipIdentifiersNextResults(ctx context.Context, lastResults IdentifierCollection) (result IdentifierCollection, err error) {
	req, err := lastResults.identifierCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDomainOwnershipIdentifiersNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListDomainOwnershipIdentifiersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDomainOwnershipIdentifiersNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListDomainOwnershipIdentifiersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listDomainOwnershipIdentifiersNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListDomainOwnershipIdentifiersComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListDomainOwnershipIdentifiersComplete(ctx context.Context, resourceGroupName string, name string) (result IdentifierCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDomainOwnershipIdentifiers")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListDomainOwnershipIdentifiers(ctx, resourceGroupName, name)
	return
}

// ListDomainOwnershipIdentifiersSlot lists ownership identifiers for domain associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
func (client AppsClient) ListDomainOwnershipIdentifiersSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result IdentifierCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDomainOwnershipIdentifiersSlot")
		defer func() {
			sc := -1
			if result.ic.Response.Response != nil {
				sc = result.ic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListDomainOwnershipIdentifiersSlot", err.Error())
	}

	result.fn = client.listDomainOwnershipIdentifiersSlotNextResults
	req, err := client.ListDomainOwnershipIdentifiersSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDomainOwnershipIdentifiersSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDomainOwnershipIdentifiersSlotSender(req)
	if err != nil {
		result.ic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDomainOwnershipIdentifiersSlot", resp, "Failure sending request")
		return
	}

	result.ic, err = client.ListDomainOwnershipIdentifiersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListDomainOwnershipIdentifiersSlot", resp, "Failure responding to request")
	}

	return
}

// ListDomainOwnershipIdentifiersSlotPreparer prepares the ListDomainOwnershipIdentifiersSlot request.
func (client AppsClient) ListDomainOwnershipIdentifiersSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDomainOwnershipIdentifiersSlotSender sends the ListDomainOwnershipIdentifiersSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListDomainOwnershipIdentifiersSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListDomainOwnershipIdentifiersSlotResponder handles the response to the ListDomainOwnershipIdentifiersSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListDomainOwnershipIdentifiersSlotResponder(resp *http.Response) (result IdentifierCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listDomainOwnershipIdentifiersSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listDomainOwnershipIdentifiersSlotNextResults(ctx context.Context, lastResults IdentifierCollection) (result IdentifierCollection, err error) {
	req, err := lastResults.identifierCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDomainOwnershipIdentifiersSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListDomainOwnershipIdentifiersSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listDomainOwnershipIdentifiersSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListDomainOwnershipIdentifiersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listDomainOwnershipIdentifiersSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListDomainOwnershipIdentifiersSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListDomainOwnershipIdentifiersSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result IdentifierCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListDomainOwnershipIdentifiersSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListDomainOwnershipIdentifiersSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListFunctions list the functions for a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
func (client AppsClient) ListFunctions(ctx context.Context, resourceGroupName string, name string) (result FunctionEnvelopeCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListFunctions")
		defer func() {
			sc := -1
			if result.fec.Response.Response != nil {
				sc = result.fec.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListFunctions", err.Error())
	}

	result.fn = client.listFunctionsNextResults
	req, err := client.ListFunctionsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctions", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListFunctionsSender(req)
	if err != nil {
		result.fec.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctions", resp, "Failure sending request")
		return
	}

	result.fec, err = client.ListFunctionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctions", resp, "Failure responding to request")
	}

	return
}

// ListFunctionsPreparer prepares the ListFunctions request.
func (client AppsClient) ListFunctionsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListFunctionsSender sends the ListFunctions request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListFunctionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListFunctionsResponder handles the response to the ListFunctions request. The method always
// closes the http.Response Body.
func (client AppsClient) ListFunctionsResponder(resp *http.Response) (result FunctionEnvelopeCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listFunctionsNextResults retrieves the next set of results, if any.
func (client AppsClient) listFunctionsNextResults(ctx context.Context, lastResults FunctionEnvelopeCollection) (result FunctionEnvelopeCollection, err error) {
	req, err := lastResults.functionEnvelopeCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listFunctionsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListFunctionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listFunctionsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListFunctionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listFunctionsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListFunctionsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListFunctionsComplete(ctx context.Context, resourceGroupName string, name string) (result FunctionEnvelopeCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListFunctions")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListFunctions(ctx, resourceGroupName, name)
	return
}

// ListFunctionSecrets get function secrets for a function in a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
func (client AppsClient) ListFunctionSecrets(ctx context.Context, resourceGroupName string, name string, functionName string) (result FunctionSecrets, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListFunctionSecrets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListFunctionSecrets", err.Error())
	}

	req, err := client.ListFunctionSecretsPreparer(ctx, resourceGroupName, name, functionName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctionSecrets", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListFunctionSecretsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctionSecrets", resp, "Failure sending request")
		return
	}

	result, err = client.ListFunctionSecretsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctionSecrets", resp, "Failure responding to request")
	}

	return
}

// ListFunctionSecretsPreparer prepares the ListFunctionSecrets request.
func (client AppsClient) ListFunctionSecretsPreparer(ctx context.Context, resourceGroupName string, name string, functionName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListFunctionSecretsSender sends the ListFunctionSecrets request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListFunctionSecretsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListFunctionSecretsResponder handles the response to the ListFunctionSecrets request. The method always
// closes the http.Response Body.
func (client AppsClient) ListFunctionSecretsResponder(resp *http.Response) (result FunctionSecrets, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListFunctionSecretsSlot get function secrets for a function in a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// functionName - function name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) ListFunctionSecretsSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string) (result FunctionSecrets, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListFunctionSecretsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListFunctionSecretsSlot", err.Error())
	}

	req, err := client.ListFunctionSecretsSlotPreparer(ctx, resourceGroupName, name, functionName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctionSecretsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListFunctionSecretsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctionSecretsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListFunctionSecretsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListFunctionSecretsSlot", resp, "Failure responding to request")
	}

	return
}

// ListFunctionSecretsSlotPreparer prepares the ListFunctionSecretsSlot request.
func (client AppsClient) ListFunctionSecretsSlotPreparer(ctx context.Context, resourceGroupName string, name string, functionName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"functionName":      autorest.Encode("path", functionName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListFunctionSecretsSlotSender sends the ListFunctionSecretsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListFunctionSecretsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListFunctionSecretsSlotResponder handles the response to the ListFunctionSecretsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListFunctionSecretsSlotResponder(resp *http.Response) (result FunctionSecrets, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListHostNameBindings get hostname bindings for an app or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListHostNameBindings(ctx context.Context, resourceGroupName string, name string) (result HostNameBindingCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHostNameBindings")
		defer func() {
			sc := -1
			if result.hnbc.Response.Response != nil {
				sc = result.hnbc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListHostNameBindings", err.Error())
	}

	result.fn = client.listHostNameBindingsNextResults
	req, err := client.ListHostNameBindingsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHostNameBindings", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListHostNameBindingsSender(req)
	if err != nil {
		result.hnbc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHostNameBindings", resp, "Failure sending request")
		return
	}

	result.hnbc, err = client.ListHostNameBindingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHostNameBindings", resp, "Failure responding to request")
	}

	return
}

// ListHostNameBindingsPreparer prepares the ListHostNameBindings request.
func (client AppsClient) ListHostNameBindingsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListHostNameBindingsSender sends the ListHostNameBindings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListHostNameBindingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListHostNameBindingsResponder handles the response to the ListHostNameBindings request. The method always
// closes the http.Response Body.
func (client AppsClient) ListHostNameBindingsResponder(resp *http.Response) (result HostNameBindingCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listHostNameBindingsNextResults retrieves the next set of results, if any.
func (client AppsClient) listHostNameBindingsNextResults(ctx context.Context, lastResults HostNameBindingCollection) (result HostNameBindingCollection, err error) {
	req, err := lastResults.hostNameBindingCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listHostNameBindingsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListHostNameBindingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listHostNameBindingsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListHostNameBindingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listHostNameBindingsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListHostNameBindingsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListHostNameBindingsComplete(ctx context.Context, resourceGroupName string, name string) (result HostNameBindingCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHostNameBindings")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListHostNameBindings(ctx, resourceGroupName, name)
	return
}

// ListHostNameBindingsSlot get hostname bindings for an app or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the
// production slot.
func (client AppsClient) ListHostNameBindingsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result HostNameBindingCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHostNameBindingsSlot")
		defer func() {
			sc := -1
			if result.hnbc.Response.Response != nil {
				sc = result.hnbc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListHostNameBindingsSlot", err.Error())
	}

	result.fn = client.listHostNameBindingsSlotNextResults
	req, err := client.ListHostNameBindingsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHostNameBindingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListHostNameBindingsSlotSender(req)
	if err != nil {
		result.hnbc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHostNameBindingsSlot", resp, "Failure sending request")
		return
	}

	result.hnbc, err = client.ListHostNameBindingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHostNameBindingsSlot", resp, "Failure responding to request")
	}

	return
}

// ListHostNameBindingsSlotPreparer prepares the ListHostNameBindingsSlot request.
func (client AppsClient) ListHostNameBindingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListHostNameBindingsSlotSender sends the ListHostNameBindingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListHostNameBindingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListHostNameBindingsSlotResponder handles the response to the ListHostNameBindingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListHostNameBindingsSlotResponder(resp *http.Response) (result HostNameBindingCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listHostNameBindingsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listHostNameBindingsSlotNextResults(ctx context.Context, lastResults HostNameBindingCollection) (result HostNameBindingCollection, err error) {
	req, err := lastResults.hostNameBindingCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listHostNameBindingsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListHostNameBindingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listHostNameBindingsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListHostNameBindingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listHostNameBindingsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListHostNameBindingsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListHostNameBindingsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result HostNameBindingCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHostNameBindingsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListHostNameBindingsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListHybridConnectionKeys gets the send key name and value for a Hybrid Connection.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
func (client AppsClient) ListHybridConnectionKeys(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string) (result HybridConnectionKey, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHybridConnectionKeys")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListHybridConnectionKeys", err.Error())
	}

	req, err := client.ListHybridConnectionKeysPreparer(ctx, resourceGroupName, name, namespaceName, relayName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionKeys", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListHybridConnectionKeysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionKeys", resp, "Failure sending request")
		return
	}

	result, err = client.ListHybridConnectionKeysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionKeys", resp, "Failure responding to request")
	}

	return
}

// ListHybridConnectionKeysPreparer prepares the ListHybridConnectionKeys request.
func (client AppsClient) ListHybridConnectionKeysPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListHybridConnectionKeysSender sends the ListHybridConnectionKeys request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListHybridConnectionKeysSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListHybridConnectionKeysResponder handles the response to the ListHybridConnectionKeys request. The method always
// closes the http.Response Body.
func (client AppsClient) ListHybridConnectionKeysResponder(resp *http.Response) (result HybridConnectionKey, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListHybridConnectionKeysSlot gets the send key name and value for a Hybrid Connection.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// slot - the name of the slot for the web app.
func (client AppsClient) ListHybridConnectionKeysSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string) (result HybridConnectionKey, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHybridConnectionKeysSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListHybridConnectionKeysSlot", err.Error())
	}

	req, err := client.ListHybridConnectionKeysSlotPreparer(ctx, resourceGroupName, name, namespaceName, relayName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionKeysSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListHybridConnectionKeysSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionKeysSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListHybridConnectionKeysSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionKeysSlot", resp, "Failure responding to request")
	}

	return
}

// ListHybridConnectionKeysSlotPreparer prepares the ListHybridConnectionKeysSlot request.
func (client AppsClient) ListHybridConnectionKeysSlotPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}/listKeys", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListHybridConnectionKeysSlotSender sends the ListHybridConnectionKeysSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListHybridConnectionKeysSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListHybridConnectionKeysSlotResponder handles the response to the ListHybridConnectionKeysSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListHybridConnectionKeysSlotResponder(resp *http.Response) (result HybridConnectionKey, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListHybridConnections retrieves all Service Bus Hybrid Connections used by this Web App.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
func (client AppsClient) ListHybridConnections(ctx context.Context, resourceGroupName string, name string) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHybridConnections")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListHybridConnections", err.Error())
	}

	req, err := client.ListHybridConnectionsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnections", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListHybridConnectionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnections", resp, "Failure sending request")
		return
	}

	result, err = client.ListHybridConnectionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnections", resp, "Failure responding to request")
	}

	return
}

// ListHybridConnectionsPreparer prepares the ListHybridConnections request.
func (client AppsClient) ListHybridConnectionsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListHybridConnectionsSender sends the ListHybridConnections request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListHybridConnectionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListHybridConnectionsResponder handles the response to the ListHybridConnections request. The method always
// closes the http.Response Body.
func (client AppsClient) ListHybridConnectionsResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListHybridConnectionsSlot retrieves all Service Bus Hybrid Connections used by this Web App.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for the web app.
func (client AppsClient) ListHybridConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListHybridConnectionsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListHybridConnectionsSlot", err.Error())
	}

	req, err := client.ListHybridConnectionsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListHybridConnectionsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListHybridConnectionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListHybridConnectionsSlot", resp, "Failure responding to request")
	}

	return
}

// ListHybridConnectionsSlotPreparer prepares the ListHybridConnectionsSlot request.
func (client AppsClient) ListHybridConnectionsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListHybridConnectionsSlotSender sends the ListHybridConnectionsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListHybridConnectionsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListHybridConnectionsSlotResponder handles the response to the ListHybridConnectionsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListHybridConnectionsSlotResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListInstanceFunctionsSlot list the functions for a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) ListInstanceFunctionsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result FunctionEnvelopeCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceFunctionsSlot")
		defer func() {
			sc := -1
			if result.fec.Response.Response != nil {
				sc = result.fec.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceFunctionsSlot", err.Error())
	}

	result.fn = client.listInstanceFunctionsSlotNextResults
	req, err := client.ListInstanceFunctionsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceFunctionsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceFunctionsSlotSender(req)
	if err != nil {
		result.fec.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceFunctionsSlot", resp, "Failure sending request")
		return
	}

	result.fec, err = client.ListInstanceFunctionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceFunctionsSlot", resp, "Failure responding to request")
	}

	return
}

// ListInstanceFunctionsSlotPreparer prepares the ListInstanceFunctionsSlot request.
func (client AppsClient) ListInstanceFunctionsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceFunctionsSlotSender sends the ListInstanceFunctionsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceFunctionsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceFunctionsSlotResponder handles the response to the ListInstanceFunctionsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceFunctionsSlotResponder(resp *http.Response) (result FunctionEnvelopeCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceFunctionsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceFunctionsSlotNextResults(ctx context.Context, lastResults FunctionEnvelopeCollection) (result FunctionEnvelopeCollection, err error) {
	req, err := lastResults.functionEnvelopeCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceFunctionsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceFunctionsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceFunctionsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceFunctionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceFunctionsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceFunctionsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceFunctionsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result FunctionEnvelopeCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceFunctionsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceFunctionsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListInstanceIdentifiers gets all scale-out instances of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListInstanceIdentifiers(ctx context.Context, resourceGroupName string, name string) (result AppInstanceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceIdentifiers")
		defer func() {
			sc := -1
			if result.aic.Response.Response != nil {
				sc = result.aic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceIdentifiers", err.Error())
	}

	result.fn = client.listInstanceIdentifiersNextResults
	req, err := client.ListInstanceIdentifiersPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceIdentifiers", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceIdentifiersSender(req)
	if err != nil {
		result.aic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceIdentifiers", resp, "Failure sending request")
		return
	}

	result.aic, err = client.ListInstanceIdentifiersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceIdentifiers", resp, "Failure responding to request")
	}

	return
}

// ListInstanceIdentifiersPreparer prepares the ListInstanceIdentifiers request.
func (client AppsClient) ListInstanceIdentifiersPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceIdentifiersSender sends the ListInstanceIdentifiers request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceIdentifiersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceIdentifiersResponder handles the response to the ListInstanceIdentifiers request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceIdentifiersResponder(resp *http.Response) (result AppInstanceCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceIdentifiersNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceIdentifiersNextResults(ctx context.Context, lastResults AppInstanceCollection) (result AppInstanceCollection, err error) {
	req, err := lastResults.appInstanceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceIdentifiersNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceIdentifiersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceIdentifiersNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceIdentifiersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceIdentifiersNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceIdentifiersComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceIdentifiersComplete(ctx context.Context, resourceGroupName string, name string) (result AppInstanceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceIdentifiers")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceIdentifiers(ctx, resourceGroupName, name)
	return
}

// ListInstanceIdentifiersSlot gets all scale-out instances of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API gets the production slot instances.
func (client AppsClient) ListInstanceIdentifiersSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result AppInstanceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceIdentifiersSlot")
		defer func() {
			sc := -1
			if result.aic.Response.Response != nil {
				sc = result.aic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceIdentifiersSlot", err.Error())
	}

	result.fn = client.listInstanceIdentifiersSlotNextResults
	req, err := client.ListInstanceIdentifiersSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceIdentifiersSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceIdentifiersSlotSender(req)
	if err != nil {
		result.aic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceIdentifiersSlot", resp, "Failure sending request")
		return
	}

	result.aic, err = client.ListInstanceIdentifiersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceIdentifiersSlot", resp, "Failure responding to request")
	}

	return
}

// ListInstanceIdentifiersSlotPreparer prepares the ListInstanceIdentifiersSlot request.
func (client AppsClient) ListInstanceIdentifiersSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceIdentifiersSlotSender sends the ListInstanceIdentifiersSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceIdentifiersSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceIdentifiersSlotResponder handles the response to the ListInstanceIdentifiersSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceIdentifiersSlotResponder(resp *http.Response) (result AppInstanceCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceIdentifiersSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceIdentifiersSlotNextResults(ctx context.Context, lastResults AppInstanceCollection) (result AppInstanceCollection, err error) {
	req, err := lastResults.appInstanceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceIdentifiersSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceIdentifiersSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceIdentifiersSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceIdentifiersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceIdentifiersSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceIdentifiersSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceIdentifiersSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result AppInstanceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceIdentifiersSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceIdentifiersSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListInstanceProcesses get list of processes for a web site, or a deployment slot, or for a specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) ListInstanceProcesses(ctx context.Context, resourceGroupName string, name string, instanceID string) (result ProcessInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcesses")
		defer func() {
			sc := -1
			if result.pic.Response.Response != nil {
				sc = result.pic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceProcesses", err.Error())
	}

	result.fn = client.listInstanceProcessesNextResults
	req, err := client.ListInstanceProcessesPreparer(ctx, resourceGroupName, name, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcesses", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceProcessesSender(req)
	if err != nil {
		result.pic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcesses", resp, "Failure sending request")
		return
	}

	result.pic, err = client.ListInstanceProcessesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcesses", resp, "Failure responding to request")
	}

	return
}

// ListInstanceProcessesPreparer prepares the ListInstanceProcesses request.
func (client AppsClient) ListInstanceProcessesPreparer(ctx context.Context, resourceGroupName string, name string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceProcessesSender sends the ListInstanceProcesses request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceProcessesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceProcessesResponder handles the response to the ListInstanceProcesses request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceProcessesResponder(resp *http.Response) (result ProcessInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceProcessesNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceProcessesNextResults(ctx context.Context, lastResults ProcessInfoCollection) (result ProcessInfoCollection, err error) {
	req, err := lastResults.processInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceProcessesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceProcessesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceProcessesComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceProcessesComplete(ctx context.Context, resourceGroupName string, name string, instanceID string) (result ProcessInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcesses")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceProcesses(ctx, resourceGroupName, name, instanceID)
	return
}

// ListInstanceProcessesSlot get list of processes for a web site, or a deployment slot, or for a specific scaled-out
// instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) ListInstanceProcessesSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (result ProcessInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessesSlot")
		defer func() {
			sc := -1
			if result.pic.Response.Response != nil {
				sc = result.pic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceProcessesSlot", err.Error())
	}

	result.fn = client.listInstanceProcessesSlotNextResults
	req, err := client.ListInstanceProcessesSlotPreparer(ctx, resourceGroupName, name, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceProcessesSlotSender(req)
	if err != nil {
		result.pic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessesSlot", resp, "Failure sending request")
		return
	}

	result.pic, err = client.ListInstanceProcessesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessesSlot", resp, "Failure responding to request")
	}

	return
}

// ListInstanceProcessesSlotPreparer prepares the ListInstanceProcessesSlot request.
func (client AppsClient) ListInstanceProcessesSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceProcessesSlotSender sends the ListInstanceProcessesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceProcessesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceProcessesSlotResponder handles the response to the ListInstanceProcessesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceProcessesSlotResponder(resp *http.Response) (result ProcessInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceProcessesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceProcessesSlotNextResults(ctx context.Context, lastResults ProcessInfoCollection) (result ProcessInfoCollection, err error) {
	req, err := lastResults.processInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceProcessesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceProcessesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceProcessesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceProcessesSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string) (result ProcessInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceProcessesSlot(ctx, resourceGroupName, name, slot, instanceID)
	return
}

// ListInstanceProcessModules list module information for a process by its ID for a specific scaled-out instance in a
// web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) ListInstanceProcessModules(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result ProcessModuleInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessModules")
		defer func() {
			sc := -1
			if result.pmic.Response.Response != nil {
				sc = result.pmic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceProcessModules", err.Error())
	}

	result.fn = client.listInstanceProcessModulesNextResults
	req, err := client.ListInstanceProcessModulesPreparer(ctx, resourceGroupName, name, processID, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessModules", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceProcessModulesSender(req)
	if err != nil {
		result.pmic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessModules", resp, "Failure sending request")
		return
	}

	result.pmic, err = client.ListInstanceProcessModulesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessModules", resp, "Failure responding to request")
	}

	return
}

// ListInstanceProcessModulesPreparer prepares the ListInstanceProcessModules request.
func (client AppsClient) ListInstanceProcessModulesPreparer(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceProcessModulesSender sends the ListInstanceProcessModules request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceProcessModulesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceProcessModulesResponder handles the response to the ListInstanceProcessModules request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceProcessModulesResponder(resp *http.Response) (result ProcessModuleInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceProcessModulesNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceProcessModulesNextResults(ctx context.Context, lastResults ProcessModuleInfoCollection) (result ProcessModuleInfoCollection, err error) {
	req, err := lastResults.processModuleInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessModulesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceProcessModulesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessModulesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceProcessModulesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessModulesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceProcessModulesComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceProcessModulesComplete(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result ProcessModuleInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessModules")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceProcessModules(ctx, resourceGroupName, name, processID, instanceID)
	return
}

// ListInstanceProcessModulesSlot list module information for a process by its ID for a specific scaled-out instance in
// a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) ListInstanceProcessModulesSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result ProcessModuleInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessModulesSlot")
		defer func() {
			sc := -1
			if result.pmic.Response.Response != nil {
				sc = result.pmic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceProcessModulesSlot", err.Error())
	}

	result.fn = client.listInstanceProcessModulesSlotNextResults
	req, err := client.ListInstanceProcessModulesSlotPreparer(ctx, resourceGroupName, name, processID, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessModulesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceProcessModulesSlotSender(req)
	if err != nil {
		result.pmic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessModulesSlot", resp, "Failure sending request")
		return
	}

	result.pmic, err = client.ListInstanceProcessModulesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessModulesSlot", resp, "Failure responding to request")
	}

	return
}

// ListInstanceProcessModulesSlotPreparer prepares the ListInstanceProcessModulesSlot request.
func (client AppsClient) ListInstanceProcessModulesSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceProcessModulesSlotSender sends the ListInstanceProcessModulesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceProcessModulesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceProcessModulesSlotResponder handles the response to the ListInstanceProcessModulesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceProcessModulesSlotResponder(resp *http.Response) (result ProcessModuleInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceProcessModulesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceProcessModulesSlotNextResults(ctx context.Context, lastResults ProcessModuleInfoCollection) (result ProcessModuleInfoCollection, err error) {
	req, err := lastResults.processModuleInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessModulesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceProcessModulesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessModulesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceProcessModulesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessModulesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceProcessModulesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceProcessModulesSlotComplete(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result ProcessModuleInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessModulesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceProcessModulesSlot(ctx, resourceGroupName, name, processID, slot, instanceID)
	return
}

// ListInstanceProcessThreads list the threads in a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) ListInstanceProcessThreads(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result ProcessThreadInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessThreads")
		defer func() {
			sc := -1
			if result.ptic.Response.Response != nil {
				sc = result.ptic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceProcessThreads", err.Error())
	}

	result.fn = client.listInstanceProcessThreadsNextResults
	req, err := client.ListInstanceProcessThreadsPreparer(ctx, resourceGroupName, name, processID, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessThreads", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceProcessThreadsSender(req)
	if err != nil {
		result.ptic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessThreads", resp, "Failure sending request")
		return
	}

	result.ptic, err = client.ListInstanceProcessThreadsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessThreads", resp, "Failure responding to request")
	}

	return
}

// ListInstanceProcessThreadsPreparer prepares the ListInstanceProcessThreads request.
func (client AppsClient) ListInstanceProcessThreadsPreparer(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceProcessThreadsSender sends the ListInstanceProcessThreads request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceProcessThreadsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceProcessThreadsResponder handles the response to the ListInstanceProcessThreads request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceProcessThreadsResponder(resp *http.Response) (result ProcessThreadInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceProcessThreadsNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceProcessThreadsNextResults(ctx context.Context, lastResults ProcessThreadInfoCollection) (result ProcessThreadInfoCollection, err error) {
	req, err := lastResults.processThreadInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessThreadsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceProcessThreadsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessThreadsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceProcessThreadsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessThreadsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceProcessThreadsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceProcessThreadsComplete(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string) (result ProcessThreadInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessThreads")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceProcessThreads(ctx, resourceGroupName, name, processID, instanceID)
	return
}

// ListInstanceProcessThreadsSlot list the threads in a process by its ID for a specific scaled-out instance in a web
// site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
// instanceID - ID of a specific scaled-out instance. This is the value of the name property in the JSON
// response from "GET api/sites/{siteName}/instances".
func (client AppsClient) ListInstanceProcessThreadsSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result ProcessThreadInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessThreadsSlot")
		defer func() {
			sc := -1
			if result.ptic.Response.Response != nil {
				sc = result.ptic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListInstanceProcessThreadsSlot", err.Error())
	}

	result.fn = client.listInstanceProcessThreadsSlotNextResults
	req, err := client.ListInstanceProcessThreadsSlotPreparer(ctx, resourceGroupName, name, processID, slot, instanceID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessThreadsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListInstanceProcessThreadsSlotSender(req)
	if err != nil {
		result.ptic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessThreadsSlot", resp, "Failure sending request")
		return
	}

	result.ptic, err = client.ListInstanceProcessThreadsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListInstanceProcessThreadsSlot", resp, "Failure responding to request")
	}

	return
}

// ListInstanceProcessThreadsSlotPreparer prepares the ListInstanceProcessThreadsSlot request.
func (client AppsClient) ListInstanceProcessThreadsSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"instanceId":        autorest.Encode("path", instanceID),
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListInstanceProcessThreadsSlotSender sends the ListInstanceProcessThreadsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListInstanceProcessThreadsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListInstanceProcessThreadsSlotResponder handles the response to the ListInstanceProcessThreadsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListInstanceProcessThreadsSlotResponder(resp *http.Response) (result ProcessThreadInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listInstanceProcessThreadsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listInstanceProcessThreadsSlotNextResults(ctx context.Context, lastResults ProcessThreadInfoCollection) (result ProcessThreadInfoCollection, err error) {
	req, err := lastResults.processThreadInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessThreadsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListInstanceProcessThreadsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessThreadsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListInstanceProcessThreadsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listInstanceProcessThreadsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListInstanceProcessThreadsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListInstanceProcessThreadsSlotComplete(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string) (result ProcessThreadInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListInstanceProcessThreadsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListInstanceProcessThreadsSlot(ctx, resourceGroupName, name, processID, slot, instanceID)
	return
}

// ListMetadata gets the metadata of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListMetadata(ctx context.Context, resourceGroupName string, name string) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetadata")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListMetadata", err.Error())
	}

	req, err := client.ListMetadataPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetadata", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListMetadataSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetadata", resp, "Failure sending request")
		return
	}

	result, err = client.ListMetadataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetadata", resp, "Failure responding to request")
	}

	return
}

// ListMetadataPreparer prepares the ListMetadata request.
func (client AppsClient) ListMetadataPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListMetadataSender sends the ListMetadata request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListMetadataSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListMetadataResponder handles the response to the ListMetadata request. The method always
// closes the http.Response Body.
func (client AppsClient) ListMetadataResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListMetadataSlot gets the metadata of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the metadata for the
// production slot.
func (client AppsClient) ListMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetadataSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListMetadataSlot", err.Error())
	}

	req, err := client.ListMetadataSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetadataSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListMetadataSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetadataSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListMetadataSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetadataSlot", resp, "Failure responding to request")
	}

	return
}

// ListMetadataSlotPreparer prepares the ListMetadataSlot request.
func (client AppsClient) ListMetadataSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListMetadataSlotSender sends the ListMetadataSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListMetadataSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListMetadataSlotResponder handles the response to the ListMetadataSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListMetadataSlotResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListMetricDefinitions gets all metric definitions of an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListMetricDefinitions(ctx context.Context, resourceGroupName string, name string) (result ResourceMetricDefinitionCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetricDefinitions")
		defer func() {
			sc := -1
			if result.rmdc.Response.Response != nil {
				sc = result.rmdc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListMetricDefinitions", err.Error())
	}

	result.fn = client.listMetricDefinitionsNextResults
	req, err := client.ListMetricDefinitionsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricDefinitions", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListMetricDefinitionsSender(req)
	if err != nil {
		result.rmdc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricDefinitions", resp, "Failure sending request")
		return
	}

	result.rmdc, err = client.ListMetricDefinitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricDefinitions", resp, "Failure responding to request")
	}

	return
}

// ListMetricDefinitionsPreparer prepares the ListMetricDefinitions request.
func (client AppsClient) ListMetricDefinitionsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metricdefinitions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListMetricDefinitionsSender sends the ListMetricDefinitions request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListMetricDefinitionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListMetricDefinitionsResponder handles the response to the ListMetricDefinitions request. The method always
// closes the http.Response Body.
func (client AppsClient) ListMetricDefinitionsResponder(resp *http.Response) (result ResourceMetricDefinitionCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listMetricDefinitionsNextResults retrieves the next set of results, if any.
func (client AppsClient) listMetricDefinitionsNextResults(ctx context.Context, lastResults ResourceMetricDefinitionCollection) (result ResourceMetricDefinitionCollection, err error) {
	req, err := lastResults.resourceMetricDefinitionCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricDefinitionsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListMetricDefinitionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricDefinitionsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListMetricDefinitionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listMetricDefinitionsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListMetricDefinitionsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListMetricDefinitionsComplete(ctx context.Context, resourceGroupName string, name string) (result ResourceMetricDefinitionCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetricDefinitions")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListMetricDefinitions(ctx, resourceGroupName, name)
	return
}

// ListMetricDefinitionsSlot gets all metric definitions of an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get metric definitions of the
// production slot.
func (client AppsClient) ListMetricDefinitionsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ResourceMetricDefinitionCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetricDefinitionsSlot")
		defer func() {
			sc := -1
			if result.rmdc.Response.Response != nil {
				sc = result.rmdc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListMetricDefinitionsSlot", err.Error())
	}

	result.fn = client.listMetricDefinitionsSlotNextResults
	req, err := client.ListMetricDefinitionsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricDefinitionsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListMetricDefinitionsSlotSender(req)
	if err != nil {
		result.rmdc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricDefinitionsSlot", resp, "Failure sending request")
		return
	}

	result.rmdc, err = client.ListMetricDefinitionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricDefinitionsSlot", resp, "Failure responding to request")
	}

	return
}

// ListMetricDefinitionsSlotPreparer prepares the ListMetricDefinitionsSlot request.
func (client AppsClient) ListMetricDefinitionsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metricdefinitions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListMetricDefinitionsSlotSender sends the ListMetricDefinitionsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListMetricDefinitionsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListMetricDefinitionsSlotResponder handles the response to the ListMetricDefinitionsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListMetricDefinitionsSlotResponder(resp *http.Response) (result ResourceMetricDefinitionCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listMetricDefinitionsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listMetricDefinitionsSlotNextResults(ctx context.Context, lastResults ResourceMetricDefinitionCollection) (result ResourceMetricDefinitionCollection, err error) {
	req, err := lastResults.resourceMetricDefinitionCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricDefinitionsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListMetricDefinitionsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricDefinitionsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListMetricDefinitionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listMetricDefinitionsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListMetricDefinitionsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListMetricDefinitionsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result ResourceMetricDefinitionCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetricDefinitionsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListMetricDefinitionsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListMetrics gets performance metrics of an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// details - specify "true" to include metric details in the response. It is "false" by default.
// filter - return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value
// eq 'Metric1' or name.value eq 'Metric2') and startTime eq 2014-01-01T00:00:00Z and endTime eq
// 2014-12-31T23:59:59Z and timeGrain eq duration'[Hour|Minute|Day]'.
func (client AppsClient) ListMetrics(ctx context.Context, resourceGroupName string, name string, details *bool, filter string) (result ResourceMetricCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetrics")
		defer func() {
			sc := -1
			if result.rmc.Response.Response != nil {
				sc = result.rmc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListMetrics", err.Error())
	}

	result.fn = client.listMetricsNextResults
	req, err := client.ListMetricsPreparer(ctx, resourceGroupName, name, details, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetrics", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListMetricsSender(req)
	if err != nil {
		result.rmc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetrics", resp, "Failure sending request")
		return
	}

	result.rmc, err = client.ListMetricsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetrics", resp, "Failure responding to request")
	}

	return
}

// ListMetricsPreparer prepares the ListMetrics request.
func (client AppsClient) ListMetricsPreparer(ctx context.Context, resourceGroupName string, name string, details *bool, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if details != nil {
		queryParameters["details"] = autorest.Encode("query", *details)
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = filter
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/metrics", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListMetricsSender sends the ListMetrics request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListMetricsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListMetricsResponder handles the response to the ListMetrics request. The method always
// closes the http.Response Body.
func (client AppsClient) ListMetricsResponder(resp *http.Response) (result ResourceMetricCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listMetricsNextResults retrieves the next set of results, if any.
func (client AppsClient) listMetricsNextResults(ctx context.Context, lastResults ResourceMetricCollection) (result ResourceMetricCollection, err error) {
	req, err := lastResults.resourceMetricCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListMetricsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListMetricsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listMetricsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListMetricsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListMetricsComplete(ctx context.Context, resourceGroupName string, name string, details *bool, filter string) (result ResourceMetricCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetrics")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListMetrics(ctx, resourceGroupName, name, details, filter)
	return
}

// ListMetricsSlot gets performance metrics of an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get metrics of the production
// slot.
// details - specify "true" to include metric details in the response. It is "false" by default.
// filter - return only metrics specified in the filter (using OData syntax). For example: $filter=(name.value
// eq 'Metric1' or name.value eq 'Metric2') and startTime eq 2014-01-01T00:00:00Z and endTime eq
// 2014-12-31T23:59:59Z and timeGrain eq duration'[Hour|Minute|Day]'.
func (client AppsClient) ListMetricsSlot(ctx context.Context, resourceGroupName string, name string, slot string, details *bool, filter string) (result ResourceMetricCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetricsSlot")
		defer func() {
			sc := -1
			if result.rmc.Response.Response != nil {
				sc = result.rmc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListMetricsSlot", err.Error())
	}

	result.fn = client.listMetricsSlotNextResults
	req, err := client.ListMetricsSlotPreparer(ctx, resourceGroupName, name, slot, details, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListMetricsSlotSender(req)
	if err != nil {
		result.rmc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricsSlot", resp, "Failure sending request")
		return
	}

	result.rmc, err = client.ListMetricsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListMetricsSlot", resp, "Failure responding to request")
	}

	return
}

// ListMetricsSlotPreparer prepares the ListMetricsSlot request.
func (client AppsClient) ListMetricsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, details *bool, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if details != nil {
		queryParameters["details"] = autorest.Encode("query", *details)
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = filter
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/metrics", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListMetricsSlotSender sends the ListMetricsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListMetricsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListMetricsSlotResponder handles the response to the ListMetricsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListMetricsSlotResponder(resp *http.Response) (result ResourceMetricCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listMetricsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listMetricsSlotNextResults(ctx context.Context, lastResults ResourceMetricCollection) (result ResourceMetricCollection, err error) {
	req, err := lastResults.resourceMetricCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListMetricsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listMetricsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListMetricsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listMetricsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListMetricsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListMetricsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string, details *bool, filter string) (result ResourceMetricCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListMetricsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListMetricsSlot(ctx, resourceGroupName, name, slot, details, filter)
	return
}

// ListNetworkFeatures gets all network features used by the app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// view - the type of view. This can either be "summary" or "detailed".
func (client AppsClient) ListNetworkFeatures(ctx context.Context, resourceGroupName string, name string, view string) (result NetworkFeatures, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListNetworkFeatures")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListNetworkFeatures", err.Error())
	}

	req, err := client.ListNetworkFeaturesPreparer(ctx, resourceGroupName, name, view)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListNetworkFeatures", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListNetworkFeaturesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListNetworkFeatures", resp, "Failure sending request")
		return
	}

	result, err = client.ListNetworkFeaturesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListNetworkFeatures", resp, "Failure responding to request")
	}

	return
}

// ListNetworkFeaturesPreparer prepares the ListNetworkFeatures request.
func (client AppsClient) ListNetworkFeaturesPreparer(ctx context.Context, resourceGroupName string, name string, view string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"view":              autorest.Encode("path", view),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListNetworkFeaturesSender sends the ListNetworkFeatures request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListNetworkFeaturesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListNetworkFeaturesResponder handles the response to the ListNetworkFeatures request. The method always
// closes the http.Response Body.
func (client AppsClient) ListNetworkFeaturesResponder(resp *http.Response) (result NetworkFeatures, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListNetworkFeaturesSlot gets all network features used by the app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// view - the type of view. This can either be "summary" or "detailed".
// slot - name of the deployment slot. If a slot is not specified, the API will get network features for the
// production slot.
func (client AppsClient) ListNetworkFeaturesSlot(ctx context.Context, resourceGroupName string, name string, view string, slot string) (result NetworkFeatures, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListNetworkFeaturesSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListNetworkFeaturesSlot", err.Error())
	}

	req, err := client.ListNetworkFeaturesSlotPreparer(ctx, resourceGroupName, name, view, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListNetworkFeaturesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListNetworkFeaturesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListNetworkFeaturesSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListNetworkFeaturesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListNetworkFeaturesSlot", resp, "Failure responding to request")
	}

	return
}

// ListNetworkFeaturesSlotPreparer prepares the ListNetworkFeaturesSlot request.
func (client AppsClient) ListNetworkFeaturesSlotPreparer(ctx context.Context, resourceGroupName string, name string, view string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"view":              autorest.Encode("path", view),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListNetworkFeaturesSlotSender sends the ListNetworkFeaturesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListNetworkFeaturesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListNetworkFeaturesSlotResponder handles the response to the ListNetworkFeaturesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListNetworkFeaturesSlotResponder(resp *http.Response) (result NetworkFeatures, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListPerfMonCounters gets perfmon counters for web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// filter - return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example:
// $filter=(startTime eq 2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z and timeGrain eq
// duration'[Hour|Minute|Day]'.
func (client AppsClient) ListPerfMonCounters(ctx context.Context, resourceGroupName string, name string, filter string) (result PerfMonCounterCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPerfMonCounters")
		defer func() {
			sc := -1
			if result.pmcc.Response.Response != nil {
				sc = result.pmcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPerfMonCounters", err.Error())
	}

	result.fn = client.listPerfMonCountersNextResults
	req, err := client.ListPerfMonCountersPreparer(ctx, resourceGroupName, name, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPerfMonCounters", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPerfMonCountersSender(req)
	if err != nil {
		result.pmcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPerfMonCounters", resp, "Failure sending request")
		return
	}

	result.pmcc, err = client.ListPerfMonCountersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPerfMonCounters", resp, "Failure responding to request")
	}

	return
}

// ListPerfMonCountersPreparer prepares the ListPerfMonCounters request.
func (client AppsClient) ListPerfMonCountersPreparer(ctx context.Context, resourceGroupName string, name string, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = filter
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPerfMonCountersSender sends the ListPerfMonCounters request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPerfMonCountersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPerfMonCountersResponder handles the response to the ListPerfMonCounters request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPerfMonCountersResponder(resp *http.Response) (result PerfMonCounterCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listPerfMonCountersNextResults retrieves the next set of results, if any.
func (client AppsClient) listPerfMonCountersNextResults(ctx context.Context, lastResults PerfMonCounterCollection) (result PerfMonCounterCollection, err error) {
	req, err := lastResults.perfMonCounterCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPerfMonCountersNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListPerfMonCountersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPerfMonCountersNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListPerfMonCountersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listPerfMonCountersNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListPerfMonCountersComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListPerfMonCountersComplete(ctx context.Context, resourceGroupName string, name string, filter string) (result PerfMonCounterCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPerfMonCounters")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListPerfMonCounters(ctx, resourceGroupName, name, filter)
	return
}

// ListPerfMonCountersSlot gets perfmon counters for web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
// filter - return only usages/metrics specified in the filter. Filter conforms to odata syntax. Example:
// $filter=(startTime eq 2014-01-01T00:00:00Z and endTime eq 2014-12-31T23:59:59Z and timeGrain eq
// duration'[Hour|Minute|Day]'.
func (client AppsClient) ListPerfMonCountersSlot(ctx context.Context, resourceGroupName string, name string, slot string, filter string) (result PerfMonCounterCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPerfMonCountersSlot")
		defer func() {
			sc := -1
			if result.pmcc.Response.Response != nil {
				sc = result.pmcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPerfMonCountersSlot", err.Error())
	}

	result.fn = client.listPerfMonCountersSlotNextResults
	req, err := client.ListPerfMonCountersSlotPreparer(ctx, resourceGroupName, name, slot, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPerfMonCountersSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPerfMonCountersSlotSender(req)
	if err != nil {
		result.pmcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPerfMonCountersSlot", resp, "Failure sending request")
		return
	}

	result.pmcc, err = client.ListPerfMonCountersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPerfMonCountersSlot", resp, "Failure responding to request")
	}

	return
}

// ListPerfMonCountersSlotPreparer prepares the ListPerfMonCountersSlot request.
func (client AppsClient) ListPerfMonCountersSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = filter
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPerfMonCountersSlotSender sends the ListPerfMonCountersSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPerfMonCountersSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPerfMonCountersSlotResponder handles the response to the ListPerfMonCountersSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPerfMonCountersSlotResponder(resp *http.Response) (result PerfMonCounterCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listPerfMonCountersSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listPerfMonCountersSlotNextResults(ctx context.Context, lastResults PerfMonCounterCollection) (result PerfMonCounterCollection, err error) {
	req, err := lastResults.perfMonCounterCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPerfMonCountersSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListPerfMonCountersSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPerfMonCountersSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListPerfMonCountersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listPerfMonCountersSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListPerfMonCountersSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListPerfMonCountersSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string, filter string) (result PerfMonCounterCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPerfMonCountersSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListPerfMonCountersSlot(ctx, resourceGroupName, name, slot, filter)
	return
}

// ListPremierAddOns gets the premier add-ons of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListPremierAddOns(ctx context.Context, resourceGroupName string, name string) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPremierAddOns")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPremierAddOns", err.Error())
	}

	req, err := client.ListPremierAddOnsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPremierAddOns", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPremierAddOnsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPremierAddOns", resp, "Failure sending request")
		return
	}

	result, err = client.ListPremierAddOnsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPremierAddOns", resp, "Failure responding to request")
	}

	return
}

// ListPremierAddOnsPreparer prepares the ListPremierAddOns request.
func (client AppsClient) ListPremierAddOnsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPremierAddOnsSender sends the ListPremierAddOns request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPremierAddOnsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPremierAddOnsResponder handles the response to the ListPremierAddOns request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPremierAddOnsResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListPremierAddOnsSlot gets the premier add-ons of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the premier add-ons for the
// production slot.
func (client AppsClient) ListPremierAddOnsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPremierAddOnsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPremierAddOnsSlot", err.Error())
	}

	req, err := client.ListPremierAddOnsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPremierAddOnsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPremierAddOnsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPremierAddOnsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListPremierAddOnsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPremierAddOnsSlot", resp, "Failure responding to request")
	}

	return
}

// ListPremierAddOnsSlotPreparer prepares the ListPremierAddOnsSlot request.
func (client AppsClient) ListPremierAddOnsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPremierAddOnsSlotSender sends the ListPremierAddOnsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPremierAddOnsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPremierAddOnsSlotResponder handles the response to the ListPremierAddOnsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPremierAddOnsSlotResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListProcesses get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a
// web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
func (client AppsClient) ListProcesses(ctx context.Context, resourceGroupName string, name string) (result ProcessInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcesses")
		defer func() {
			sc := -1
			if result.pic.Response.Response != nil {
				sc = result.pic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListProcesses", err.Error())
	}

	result.fn = client.listProcessesNextResults
	req, err := client.ListProcessesPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcesses", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProcessesSender(req)
	if err != nil {
		result.pic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcesses", resp, "Failure sending request")
		return
	}

	result.pic, err = client.ListProcessesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcesses", resp, "Failure responding to request")
	}

	return
}

// ListProcessesPreparer prepares the ListProcesses request.
func (client AppsClient) ListProcessesPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProcessesSender sends the ListProcesses request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListProcessesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListProcessesResponder handles the response to the ListProcesses request. The method always
// closes the http.Response Body.
func (client AppsClient) ListProcessesResponder(resp *http.Response) (result ProcessInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProcessesNextResults retrieves the next set of results, if any.
func (client AppsClient) listProcessesNextResults(ctx context.Context, lastResults ProcessInfoCollection) (result ProcessInfoCollection, err error) {
	req, err := lastResults.processInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProcessesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProcessesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listProcessesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProcessesComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListProcessesComplete(ctx context.Context, resourceGroupName string, name string) (result ProcessInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcesses")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProcesses(ctx, resourceGroupName, name)
	return
}

// ListProcessesSlot get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance
// in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) ListProcessesSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ProcessInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessesSlot")
		defer func() {
			sc := -1
			if result.pic.Response.Response != nil {
				sc = result.pic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListProcessesSlot", err.Error())
	}

	result.fn = client.listProcessesSlotNextResults
	req, err := client.ListProcessesSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProcessesSlotSender(req)
	if err != nil {
		result.pic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessesSlot", resp, "Failure sending request")
		return
	}

	result.pic, err = client.ListProcessesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessesSlot", resp, "Failure responding to request")
	}

	return
}

// ListProcessesSlotPreparer prepares the ListProcessesSlot request.
func (client AppsClient) ListProcessesSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProcessesSlotSender sends the ListProcessesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListProcessesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListProcessesSlotResponder handles the response to the ListProcessesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListProcessesSlotResponder(resp *http.Response) (result ProcessInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProcessesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listProcessesSlotNextResults(ctx context.Context, lastResults ProcessInfoCollection) (result ProcessInfoCollection, err error) {
	req, err := lastResults.processInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProcessesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProcessesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listProcessesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProcessesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListProcessesSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result ProcessInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProcessesSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListProcessModules list module information for a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
func (client AppsClient) ListProcessModules(ctx context.Context, resourceGroupName string, name string, processID string) (result ProcessModuleInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessModules")
		defer func() {
			sc := -1
			if result.pmic.Response.Response != nil {
				sc = result.pmic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListProcessModules", err.Error())
	}

	result.fn = client.listProcessModulesNextResults
	req, err := client.ListProcessModulesPreparer(ctx, resourceGroupName, name, processID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessModules", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProcessModulesSender(req)
	if err != nil {
		result.pmic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessModules", resp, "Failure sending request")
		return
	}

	result.pmic, err = client.ListProcessModulesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessModules", resp, "Failure responding to request")
	}

	return
}

// ListProcessModulesPreparer prepares the ListProcessModules request.
func (client AppsClient) ListProcessModulesPreparer(ctx context.Context, resourceGroupName string, name string, processID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProcessModulesSender sends the ListProcessModules request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListProcessModulesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListProcessModulesResponder handles the response to the ListProcessModules request. The method always
// closes the http.Response Body.
func (client AppsClient) ListProcessModulesResponder(resp *http.Response) (result ProcessModuleInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProcessModulesNextResults retrieves the next set of results, if any.
func (client AppsClient) listProcessModulesNextResults(ctx context.Context, lastResults ProcessModuleInfoCollection) (result ProcessModuleInfoCollection, err error) {
	req, err := lastResults.processModuleInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessModulesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProcessModulesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessModulesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProcessModulesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listProcessModulesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProcessModulesComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListProcessModulesComplete(ctx context.Context, resourceGroupName string, name string, processID string) (result ProcessModuleInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessModules")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProcessModules(ctx, resourceGroupName, name, processID)
	return
}

// ListProcessModulesSlot list module information for a process by its ID for a specific scaled-out instance in a web
// site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) ListProcessModulesSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result ProcessModuleInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessModulesSlot")
		defer func() {
			sc := -1
			if result.pmic.Response.Response != nil {
				sc = result.pmic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListProcessModulesSlot", err.Error())
	}

	result.fn = client.listProcessModulesSlotNextResults
	req, err := client.ListProcessModulesSlotPreparer(ctx, resourceGroupName, name, processID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessModulesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProcessModulesSlotSender(req)
	if err != nil {
		result.pmic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessModulesSlot", resp, "Failure sending request")
		return
	}

	result.pmic, err = client.ListProcessModulesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessModulesSlot", resp, "Failure responding to request")
	}

	return
}

// ListProcessModulesSlotPreparer prepares the ListProcessModulesSlot request.
func (client AppsClient) ListProcessModulesSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProcessModulesSlotSender sends the ListProcessModulesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListProcessModulesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListProcessModulesSlotResponder handles the response to the ListProcessModulesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListProcessModulesSlotResponder(resp *http.Response) (result ProcessModuleInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProcessModulesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listProcessModulesSlotNextResults(ctx context.Context, lastResults ProcessModuleInfoCollection) (result ProcessModuleInfoCollection, err error) {
	req, err := lastResults.processModuleInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessModulesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProcessModulesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessModulesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProcessModulesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listProcessModulesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProcessModulesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListProcessModulesSlotComplete(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result ProcessModuleInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessModulesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProcessModulesSlot(ctx, resourceGroupName, name, processID, slot)
	return
}

// ListProcessThreads list the threads in a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
func (client AppsClient) ListProcessThreads(ctx context.Context, resourceGroupName string, name string, processID string) (result ProcessThreadInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessThreads")
		defer func() {
			sc := -1
			if result.ptic.Response.Response != nil {
				sc = result.ptic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListProcessThreads", err.Error())
	}

	result.fn = client.listProcessThreadsNextResults
	req, err := client.ListProcessThreadsPreparer(ctx, resourceGroupName, name, processID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessThreads", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProcessThreadsSender(req)
	if err != nil {
		result.ptic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessThreads", resp, "Failure sending request")
		return
	}

	result.ptic, err = client.ListProcessThreadsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessThreads", resp, "Failure responding to request")
	}

	return
}

// ListProcessThreadsPreparer prepares the ListProcessThreads request.
func (client AppsClient) ListProcessThreadsPreparer(ctx context.Context, resourceGroupName string, name string, processID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProcessThreadsSender sends the ListProcessThreads request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListProcessThreadsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListProcessThreadsResponder handles the response to the ListProcessThreads request. The method always
// closes the http.Response Body.
func (client AppsClient) ListProcessThreadsResponder(resp *http.Response) (result ProcessThreadInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProcessThreadsNextResults retrieves the next set of results, if any.
func (client AppsClient) listProcessThreadsNextResults(ctx context.Context, lastResults ProcessThreadInfoCollection) (result ProcessThreadInfoCollection, err error) {
	req, err := lastResults.processThreadInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessThreadsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProcessThreadsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessThreadsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProcessThreadsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listProcessThreadsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProcessThreadsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListProcessThreadsComplete(ctx context.Context, resourceGroupName string, name string, processID string) (result ProcessThreadInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessThreads")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProcessThreads(ctx, resourceGroupName, name, processID)
	return
}

// ListProcessThreadsSlot list the threads in a process by its ID for a specific scaled-out instance in a web site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// processID - pID.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) ListProcessThreadsSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result ProcessThreadInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessThreadsSlot")
		defer func() {
			sc := -1
			if result.ptic.Response.Response != nil {
				sc = result.ptic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListProcessThreadsSlot", err.Error())
	}

	result.fn = client.listProcessThreadsSlotNextResults
	req, err := client.ListProcessThreadsSlotPreparer(ctx, resourceGroupName, name, processID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessThreadsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProcessThreadsSlotSender(req)
	if err != nil {
		result.ptic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessThreadsSlot", resp, "Failure sending request")
		return
	}

	result.ptic, err = client.ListProcessThreadsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListProcessThreadsSlot", resp, "Failure responding to request")
	}

	return
}

// ListProcessThreadsSlotPreparer prepares the ListProcessThreadsSlot request.
func (client AppsClient) ListProcessThreadsSlotPreparer(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"processId":         autorest.Encode("path", processID),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProcessThreadsSlotSender sends the ListProcessThreadsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListProcessThreadsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListProcessThreadsSlotResponder handles the response to the ListProcessThreadsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListProcessThreadsSlotResponder(resp *http.Response) (result ProcessThreadInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProcessThreadsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listProcessThreadsSlotNextResults(ctx context.Context, lastResults ProcessThreadInfoCollection) (result ProcessThreadInfoCollection, err error) {
	req, err := lastResults.processThreadInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessThreadsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProcessThreadsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listProcessThreadsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProcessThreadsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listProcessThreadsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProcessThreadsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListProcessThreadsSlotComplete(ctx context.Context, resourceGroupName string, name string, processID string, slot string) (result ProcessThreadInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListProcessThreadsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProcessThreadsSlot(ctx, resourceGroupName, name, processID, slot)
	return
}

// ListPublicCertificates get public certificates for an app or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListPublicCertificates(ctx context.Context, resourceGroupName string, name string) (result PublicCertificateCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublicCertificates")
		defer func() {
			sc := -1
			if result.pcc.Response.Response != nil {
				sc = result.pcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPublicCertificates", err.Error())
	}

	result.fn = client.listPublicCertificatesNextResults
	req, err := client.ListPublicCertificatesPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublicCertificates", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPublicCertificatesSender(req)
	if err != nil {
		result.pcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublicCertificates", resp, "Failure sending request")
		return
	}

	result.pcc, err = client.ListPublicCertificatesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublicCertificates", resp, "Failure responding to request")
	}

	return
}

// ListPublicCertificatesPreparer prepares the ListPublicCertificates request.
func (client AppsClient) ListPublicCertificatesPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPublicCertificatesSender sends the ListPublicCertificates request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPublicCertificatesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPublicCertificatesResponder handles the response to the ListPublicCertificates request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPublicCertificatesResponder(resp *http.Response) (result PublicCertificateCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listPublicCertificatesNextResults retrieves the next set of results, if any.
func (client AppsClient) listPublicCertificatesNextResults(ctx context.Context, lastResults PublicCertificateCollection) (result PublicCertificateCollection, err error) {
	req, err := lastResults.publicCertificateCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPublicCertificatesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListPublicCertificatesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPublicCertificatesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListPublicCertificatesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listPublicCertificatesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListPublicCertificatesComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListPublicCertificatesComplete(ctx context.Context, resourceGroupName string, name string) (result PublicCertificateCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublicCertificates")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListPublicCertificates(ctx, resourceGroupName, name)
	return
}

// ListPublicCertificatesSlot get public certificates for an app or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API gets hostname bindings for the
// production slot.
func (client AppsClient) ListPublicCertificatesSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result PublicCertificateCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublicCertificatesSlot")
		defer func() {
			sc := -1
			if result.pcc.Response.Response != nil {
				sc = result.pcc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPublicCertificatesSlot", err.Error())
	}

	result.fn = client.listPublicCertificatesSlotNextResults
	req, err := client.ListPublicCertificatesSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublicCertificatesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPublicCertificatesSlotSender(req)
	if err != nil {
		result.pcc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublicCertificatesSlot", resp, "Failure sending request")
		return
	}

	result.pcc, err = client.ListPublicCertificatesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublicCertificatesSlot", resp, "Failure responding to request")
	}

	return
}

// ListPublicCertificatesSlotPreparer prepares the ListPublicCertificatesSlot request.
func (client AppsClient) ListPublicCertificatesSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPublicCertificatesSlotSender sends the ListPublicCertificatesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPublicCertificatesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPublicCertificatesSlotResponder handles the response to the ListPublicCertificatesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPublicCertificatesSlotResponder(resp *http.Response) (result PublicCertificateCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listPublicCertificatesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listPublicCertificatesSlotNextResults(ctx context.Context, lastResults PublicCertificateCollection) (result PublicCertificateCollection, err error) {
	req, err := lastResults.publicCertificateCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPublicCertificatesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListPublicCertificatesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listPublicCertificatesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListPublicCertificatesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listPublicCertificatesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListPublicCertificatesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListPublicCertificatesSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result PublicCertificateCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublicCertificatesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListPublicCertificatesSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListPublishingCredentials gets the Git/FTP publishing credentials of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListPublishingCredentials(ctx context.Context, resourceGroupName string, name string) (result AppsListPublishingCredentialsFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublishingCredentials")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPublishingCredentials", err.Error())
	}

	req, err := client.ListPublishingCredentialsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingCredentials", nil, "Failure preparing request")
		return
	}

	result, err = client.ListPublishingCredentialsSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingCredentials", result.Response(), "Failure sending request")
		return
	}

	return
}

// ListPublishingCredentialsPreparer prepares the ListPublishingCredentials request.
func (client AppsClient) ListPublishingCredentialsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPublishingCredentialsSender sends the ListPublishingCredentials request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPublishingCredentialsSender(req *http.Request) (future AppsListPublishingCredentialsFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// ListPublishingCredentialsResponder handles the response to the ListPublishingCredentials request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPublishingCredentialsResponder(resp *http.Response) (result User, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListPublishingCredentialsSlot gets the Git/FTP publishing credentials of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get the publishing credentials
// for the production slot.
func (client AppsClient) ListPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result AppsListPublishingCredentialsSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublishingCredentialsSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPublishingCredentialsSlot", err.Error())
	}

	req, err := client.ListPublishingCredentialsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingCredentialsSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.ListPublishingCredentialsSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingCredentialsSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// ListPublishingCredentialsSlotPreparer prepares the ListPublishingCredentialsSlot request.
func (client AppsClient) ListPublishingCredentialsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPublishingCredentialsSlotSender sends the ListPublishingCredentialsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPublishingCredentialsSlotSender(req *http.Request) (future AppsListPublishingCredentialsSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// ListPublishingCredentialsSlotResponder handles the response to the ListPublishingCredentialsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPublishingCredentialsSlotResponder(resp *http.Response) (result User, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListPublishingProfileXMLWithSecrets gets the publishing profile for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// publishingProfileOptions - specifies publishingProfileOptions for publishing profile. For example, use
// {"format": "FileZilla3"} to get a FileZilla publishing profile.
func (client AppsClient) ListPublishingProfileXMLWithSecrets(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublishingProfileXMLWithSecrets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPublishingProfileXMLWithSecrets", err.Error())
	}

	req, err := client.ListPublishingProfileXMLWithSecretsPreparer(ctx, resourceGroupName, name, publishingProfileOptions)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingProfileXMLWithSecrets", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPublishingProfileXMLWithSecretsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingProfileXMLWithSecrets", resp, "Failure sending request")
		return
	}

	result, err = client.ListPublishingProfileXMLWithSecretsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingProfileXMLWithSecrets", resp, "Failure responding to request")
	}

	return
}

// ListPublishingProfileXMLWithSecretsPreparer prepares the ListPublishingProfileXMLWithSecrets request.
func (client AppsClient) ListPublishingProfileXMLWithSecretsPreparer(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml", pathParameters),
		autorest.WithJSON(publishingProfileOptions),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPublishingProfileXMLWithSecretsSender sends the ListPublishingProfileXMLWithSecrets request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPublishingProfileXMLWithSecretsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPublishingProfileXMLWithSecretsResponder handles the response to the ListPublishingProfileXMLWithSecrets request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPublishingProfileXMLWithSecretsResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// ListPublishingProfileXMLWithSecretsSlot gets the publishing profile for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// publishingProfileOptions - specifies publishingProfileOptions for publishing profile. For example, use
// {"format": "FileZilla3"} to get a FileZilla publishing profile.
// slot - name of the deployment slot. If a slot is not specified, the API will get the publishing profile for
// the production slot.
func (client AppsClient) ListPublishingProfileXMLWithSecretsSlot(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, slot string) (result ReadCloser, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListPublishingProfileXMLWithSecretsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListPublishingProfileXMLWithSecretsSlot", err.Error())
	}

	req, err := client.ListPublishingProfileXMLWithSecretsSlotPreparer(ctx, resourceGroupName, name, publishingProfileOptions, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingProfileXMLWithSecretsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPublishingProfileXMLWithSecretsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingProfileXMLWithSecretsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListPublishingProfileXMLWithSecretsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListPublishingProfileXMLWithSecretsSlot", resp, "Failure responding to request")
	}

	return
}

// ListPublishingProfileXMLWithSecretsSlotPreparer prepares the ListPublishingProfileXMLWithSecretsSlot request.
func (client AppsClient) ListPublishingProfileXMLWithSecretsSlotPreparer(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml", pathParameters),
		autorest.WithJSON(publishingProfileOptions),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPublishingProfileXMLWithSecretsSlotSender sends the ListPublishingProfileXMLWithSecretsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListPublishingProfileXMLWithSecretsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListPublishingProfileXMLWithSecretsSlotResponder handles the response to the ListPublishingProfileXMLWithSecretsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListPublishingProfileXMLWithSecretsSlotResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// ListRelayServiceConnections gets hybrid connections configured for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListRelayServiceConnections(ctx context.Context, resourceGroupName string, name string) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListRelayServiceConnections")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListRelayServiceConnections", err.Error())
	}

	req, err := client.ListRelayServiceConnectionsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListRelayServiceConnections", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListRelayServiceConnectionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListRelayServiceConnections", resp, "Failure sending request")
		return
	}

	result, err = client.ListRelayServiceConnectionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListRelayServiceConnections", resp, "Failure responding to request")
	}

	return
}

// ListRelayServiceConnectionsPreparer prepares the ListRelayServiceConnections request.
func (client AppsClient) ListRelayServiceConnectionsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListRelayServiceConnectionsSender sends the ListRelayServiceConnections request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListRelayServiceConnectionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListRelayServiceConnectionsResponder handles the response to the ListRelayServiceConnections request. The method always
// closes the http.Response Body.
func (client AppsClient) ListRelayServiceConnectionsResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListRelayServiceConnectionsSlot gets hybrid connections configured for an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get hybrid connections for the
// production slot.
func (client AppsClient) ListRelayServiceConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListRelayServiceConnectionsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListRelayServiceConnectionsSlot", err.Error())
	}

	req, err := client.ListRelayServiceConnectionsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListRelayServiceConnectionsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListRelayServiceConnectionsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListRelayServiceConnectionsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListRelayServiceConnectionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListRelayServiceConnectionsSlot", resp, "Failure responding to request")
	}

	return
}

// ListRelayServiceConnectionsSlotPreparer prepares the ListRelayServiceConnectionsSlot request.
func (client AppsClient) ListRelayServiceConnectionsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListRelayServiceConnectionsSlotSender sends the ListRelayServiceConnectionsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListRelayServiceConnectionsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListRelayServiceConnectionsSlotResponder handles the response to the ListRelayServiceConnectionsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListRelayServiceConnectionsSlotResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSiteExtensions get list of siteextensions for a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
func (client AppsClient) ListSiteExtensions(ctx context.Context, resourceGroupName string, name string) (result SiteExtensionInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSiteExtensions")
		defer func() {
			sc := -1
			if result.seic.Response.Response != nil {
				sc = result.seic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSiteExtensions", err.Error())
	}

	result.fn = client.listSiteExtensionsNextResults
	req, err := client.ListSiteExtensionsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSiteExtensions", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSiteExtensionsSender(req)
	if err != nil {
		result.seic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSiteExtensions", resp, "Failure sending request")
		return
	}

	result.seic, err = client.ListSiteExtensionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSiteExtensions", resp, "Failure responding to request")
	}

	return
}

// ListSiteExtensionsPreparer prepares the ListSiteExtensions request.
func (client AppsClient) ListSiteExtensionsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSiteExtensionsSender sends the ListSiteExtensions request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSiteExtensionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSiteExtensionsResponder handles the response to the ListSiteExtensions request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSiteExtensionsResponder(resp *http.Response) (result SiteExtensionInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSiteExtensionsNextResults retrieves the next set of results, if any.
func (client AppsClient) listSiteExtensionsNextResults(ctx context.Context, lastResults SiteExtensionInfoCollection) (result SiteExtensionInfoCollection, err error) {
	req, err := lastResults.siteExtensionInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSiteExtensionsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSiteExtensionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSiteExtensionsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSiteExtensionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSiteExtensionsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSiteExtensionsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSiteExtensionsComplete(ctx context.Context, resourceGroupName string, name string) (result SiteExtensionInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSiteExtensions")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSiteExtensions(ctx, resourceGroupName, name)
	return
}

// ListSiteExtensionsSlot get list of siteextensions for a web site, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) ListSiteExtensionsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteExtensionInfoCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSiteExtensionsSlot")
		defer func() {
			sc := -1
			if result.seic.Response.Response != nil {
				sc = result.seic.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSiteExtensionsSlot", err.Error())
	}

	result.fn = client.listSiteExtensionsSlotNextResults
	req, err := client.ListSiteExtensionsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSiteExtensionsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSiteExtensionsSlotSender(req)
	if err != nil {
		result.seic.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSiteExtensionsSlot", resp, "Failure sending request")
		return
	}

	result.seic, err = client.ListSiteExtensionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSiteExtensionsSlot", resp, "Failure responding to request")
	}

	return
}

// ListSiteExtensionsSlotPreparer prepares the ListSiteExtensionsSlot request.
func (client AppsClient) ListSiteExtensionsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSiteExtensionsSlotSender sends the ListSiteExtensionsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSiteExtensionsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSiteExtensionsSlotResponder handles the response to the ListSiteExtensionsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSiteExtensionsSlotResponder(resp *http.Response) (result SiteExtensionInfoCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSiteExtensionsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listSiteExtensionsSlotNextResults(ctx context.Context, lastResults SiteExtensionInfoCollection) (result SiteExtensionInfoCollection, err error) {
	req, err := lastResults.siteExtensionInfoCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSiteExtensionsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSiteExtensionsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSiteExtensionsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSiteExtensionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSiteExtensionsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSiteExtensionsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSiteExtensionsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result SiteExtensionInfoCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSiteExtensionsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSiteExtensionsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListSitePushSettings gets the Push settings associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) ListSitePushSettings(ctx context.Context, resourceGroupName string, name string) (result PushSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSitePushSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSitePushSettings", err.Error())
	}

	req, err := client.ListSitePushSettingsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSitePushSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSitePushSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSitePushSettings", resp, "Failure sending request")
		return
	}

	result, err = client.ListSitePushSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSitePushSettings", resp, "Failure responding to request")
	}

	return
}

// ListSitePushSettingsPreparer prepares the ListSitePushSettings request.
func (client AppsClient) ListSitePushSettingsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSitePushSettingsSender sends the ListSitePushSettings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSitePushSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSitePushSettingsResponder handles the response to the ListSitePushSettings request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSitePushSettingsResponder(resp *http.Response) (result PushSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSitePushSettingsSlot gets the Push settings associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) ListSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result PushSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSitePushSettingsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSitePushSettingsSlot", err.Error())
	}

	req, err := client.ListSitePushSettingsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSitePushSettingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSitePushSettingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSitePushSettingsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListSitePushSettingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSitePushSettingsSlot", resp, "Failure responding to request")
	}

	return
}

// ListSitePushSettingsSlotPreparer prepares the ListSitePushSettingsSlot request.
func (client AppsClient) ListSitePushSettingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSitePushSettingsSlotSender sends the ListSitePushSettingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSitePushSettingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSitePushSettingsSlotResponder handles the response to the ListSitePushSettingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSitePushSettingsSlotResponder(resp *http.Response) (result PushSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSlotConfigurationNames gets the names of app settings and connection strings that stick to the slot (not
// swapped).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string) (result SlotConfigNamesResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlotConfigurationNames")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSlotConfigurationNames", err.Error())
	}

	req, err := client.ListSlotConfigurationNamesPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotConfigurationNames", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSlotConfigurationNamesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotConfigurationNames", resp, "Failure sending request")
		return
	}

	result, err = client.ListSlotConfigurationNamesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotConfigurationNames", resp, "Failure responding to request")
	}

	return
}

// ListSlotConfigurationNamesPreparer prepares the ListSlotConfigurationNames request.
func (client AppsClient) ListSlotConfigurationNamesPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSlotConfigurationNamesSender sends the ListSlotConfigurationNames request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSlotConfigurationNamesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSlotConfigurationNamesResponder handles the response to the ListSlotConfigurationNames request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSlotConfigurationNamesResponder(resp *http.Response) (result SlotConfigNamesResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSlotDifferencesFromProduction get the difference in configuration settings between two web app slots.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
func (client AppsClient) ListSlotDifferencesFromProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (result SlotDifferenceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlotDifferencesFromProduction")
		defer func() {
			sc := -1
			if result.sdc.Response.Response != nil {
				sc = result.sdc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: slotSwapEntity,
			Constraints: []validation.Constraint{{Target: "slotSwapEntity.TargetSlot", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "slotSwapEntity.PreserveVnet", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSlotDifferencesFromProduction", err.Error())
	}

	result.fn = client.listSlotDifferencesFromProductionNextResults
	req, err := client.ListSlotDifferencesFromProductionPreparer(ctx, resourceGroupName, name, slotSwapEntity)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotDifferencesFromProduction", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSlotDifferencesFromProductionSender(req)
	if err != nil {
		result.sdc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotDifferencesFromProduction", resp, "Failure sending request")
		return
	}

	result.sdc, err = client.ListSlotDifferencesFromProductionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotDifferencesFromProduction", resp, "Failure responding to request")
	}

	return
}

// ListSlotDifferencesFromProductionPreparer prepares the ListSlotDifferencesFromProduction request.
func (client AppsClient) ListSlotDifferencesFromProductionPreparer(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs", pathParameters),
		autorest.WithJSON(slotSwapEntity),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSlotDifferencesFromProductionSender sends the ListSlotDifferencesFromProduction request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSlotDifferencesFromProductionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSlotDifferencesFromProductionResponder handles the response to the ListSlotDifferencesFromProduction request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSlotDifferencesFromProductionResponder(resp *http.Response) (result SlotDifferenceCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSlotDifferencesFromProductionNextResults retrieves the next set of results, if any.
func (client AppsClient) listSlotDifferencesFromProductionNextResults(ctx context.Context, lastResults SlotDifferenceCollection) (result SlotDifferenceCollection, err error) {
	req, err := lastResults.slotDifferenceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSlotDifferencesFromProductionNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSlotDifferencesFromProductionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSlotDifferencesFromProductionNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSlotDifferencesFromProductionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSlotDifferencesFromProductionNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSlotDifferencesFromProductionComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSlotDifferencesFromProductionComplete(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (result SlotDifferenceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlotDifferencesFromProduction")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSlotDifferencesFromProduction(ctx, resourceGroupName, name, slotSwapEntity)
	return
}

// ListSlotDifferencesSlot get the difference in configuration settings between two web app slots.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// slot - name of the source slot. If a slot is not specified, the production slot is used as the source slot.
func (client AppsClient) ListSlotDifferencesSlot(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (result SlotDifferenceCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlotDifferencesSlot")
		defer func() {
			sc := -1
			if result.sdc.Response.Response != nil {
				sc = result.sdc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: slotSwapEntity,
			Constraints: []validation.Constraint{{Target: "slotSwapEntity.TargetSlot", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "slotSwapEntity.PreserveVnet", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSlotDifferencesSlot", err.Error())
	}

	result.fn = client.listSlotDifferencesSlotNextResults
	req, err := client.ListSlotDifferencesSlotPreparer(ctx, resourceGroupName, name, slotSwapEntity, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotDifferencesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSlotDifferencesSlotSender(req)
	if err != nil {
		result.sdc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotDifferencesSlot", resp, "Failure sending request")
		return
	}

	result.sdc, err = client.ListSlotDifferencesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlotDifferencesSlot", resp, "Failure responding to request")
	}

	return
}

// ListSlotDifferencesSlotPreparer prepares the ListSlotDifferencesSlot request.
func (client AppsClient) ListSlotDifferencesSlotPreparer(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs", pathParameters),
		autorest.WithJSON(slotSwapEntity),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSlotDifferencesSlotSender sends the ListSlotDifferencesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSlotDifferencesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSlotDifferencesSlotResponder handles the response to the ListSlotDifferencesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSlotDifferencesSlotResponder(resp *http.Response) (result SlotDifferenceCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSlotDifferencesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listSlotDifferencesSlotNextResults(ctx context.Context, lastResults SlotDifferenceCollection) (result SlotDifferenceCollection, err error) {
	req, err := lastResults.slotDifferenceCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSlotDifferencesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSlotDifferencesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSlotDifferencesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSlotDifferencesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSlotDifferencesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSlotDifferencesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSlotDifferencesSlotComplete(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (result SlotDifferenceCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlotDifferencesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSlotDifferencesSlot(ctx, resourceGroupName, name, slotSwapEntity, slot)
	return
}

// ListSlots gets an app's deployment slots.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListSlots(ctx context.Context, resourceGroupName string, name string) (result AppCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlots")
		defer func() {
			sc := -1
			if result.ac.Response.Response != nil {
				sc = result.ac.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSlots", err.Error())
	}

	result.fn = client.listSlotsNextResults
	req, err := client.ListSlotsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlots", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSlotsSender(req)
	if err != nil {
		result.ac.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlots", resp, "Failure sending request")
		return
	}

	result.ac, err = client.ListSlotsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSlots", resp, "Failure responding to request")
	}

	return
}

// ListSlotsPreparer prepares the ListSlots request.
func (client AppsClient) ListSlotsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSlotsSender sends the ListSlots request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSlotsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSlotsResponder handles the response to the ListSlots request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSlotsResponder(resp *http.Response) (result AppCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSlotsNextResults retrieves the next set of results, if any.
func (client AppsClient) listSlotsNextResults(ctx context.Context, lastResults AppCollection) (result AppCollection, err error) {
	req, err := lastResults.appCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSlotsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSlotsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSlotsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSlotsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSlotsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSlotsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSlotsComplete(ctx context.Context, resourceGroupName string, name string) (result AppCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSlots")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSlots(ctx, resourceGroupName, name)
	return
}

// ListSnapshots returns all Snapshots to the user.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - website Name.
func (client AppsClient) ListSnapshots(ctx context.Context, resourceGroupName string, name string) (result SnapshotCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshots")
		defer func() {
			sc := -1
			if result.sc.Response.Response != nil {
				sc = result.sc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSnapshots", err.Error())
	}

	result.fn = client.listSnapshotsNextResults
	req, err := client.ListSnapshotsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshots", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSnapshotsSender(req)
	if err != nil {
		result.sc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshots", resp, "Failure sending request")
		return
	}

	result.sc, err = client.ListSnapshotsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshots", resp, "Failure responding to request")
	}

	return
}

// ListSnapshotsPreparer prepares the ListSnapshots request.
func (client AppsClient) ListSnapshotsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSnapshotsSender sends the ListSnapshots request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSnapshotsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSnapshotsResponder handles the response to the ListSnapshots request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSnapshotsResponder(resp *http.Response) (result SnapshotCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSnapshotsNextResults retrieves the next set of results, if any.
func (client AppsClient) listSnapshotsNextResults(ctx context.Context, lastResults SnapshotCollection) (result SnapshotCollection, err error) {
	req, err := lastResults.snapshotCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSnapshotsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSnapshotsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSnapshotsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSnapshotsComplete(ctx context.Context, resourceGroupName string, name string) (result SnapshotCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshots")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSnapshots(ctx, resourceGroupName, name)
	return
}

// ListSnapshotsFromDRSecondary returns all Snapshots to the user from DRSecondary endpoint.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - website Name.
func (client AppsClient) ListSnapshotsFromDRSecondary(ctx context.Context, resourceGroupName string, name string) (result SnapshotCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshotsFromDRSecondary")
		defer func() {
			sc := -1
			if result.sc.Response.Response != nil {
				sc = result.sc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSnapshotsFromDRSecondary", err.Error())
	}

	result.fn = client.listSnapshotsFromDRSecondaryNextResults
	req, err := client.ListSnapshotsFromDRSecondaryPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsFromDRSecondary", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSnapshotsFromDRSecondarySender(req)
	if err != nil {
		result.sc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsFromDRSecondary", resp, "Failure sending request")
		return
	}

	result.sc, err = client.ListSnapshotsFromDRSecondaryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsFromDRSecondary", resp, "Failure responding to request")
	}

	return
}

// ListSnapshotsFromDRSecondaryPreparer prepares the ListSnapshotsFromDRSecondary request.
func (client AppsClient) ListSnapshotsFromDRSecondaryPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSnapshotsFromDRSecondarySender sends the ListSnapshotsFromDRSecondary request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSnapshotsFromDRSecondarySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSnapshotsFromDRSecondaryResponder handles the response to the ListSnapshotsFromDRSecondary request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSnapshotsFromDRSecondaryResponder(resp *http.Response) (result SnapshotCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSnapshotsFromDRSecondaryNextResults retrieves the next set of results, if any.
func (client AppsClient) listSnapshotsFromDRSecondaryNextResults(ctx context.Context, lastResults SnapshotCollection) (result SnapshotCollection, err error) {
	req, err := lastResults.snapshotCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsFromDRSecondaryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSnapshotsFromDRSecondarySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsFromDRSecondaryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSnapshotsFromDRSecondaryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsFromDRSecondaryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSnapshotsFromDRSecondaryComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSnapshotsFromDRSecondaryComplete(ctx context.Context, resourceGroupName string, name string) (result SnapshotCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshotsFromDRSecondary")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSnapshotsFromDRSecondary(ctx, resourceGroupName, name)
	return
}

// ListSnapshotsFromDRSecondarySlot returns all Snapshots to the user from DRSecondary endpoint.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - website Name.
// slot - website Slot.
func (client AppsClient) ListSnapshotsFromDRSecondarySlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SnapshotCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshotsFromDRSecondarySlot")
		defer func() {
			sc := -1
			if result.sc.Response.Response != nil {
				sc = result.sc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSnapshotsFromDRSecondarySlot", err.Error())
	}

	result.fn = client.listSnapshotsFromDRSecondarySlotNextResults
	req, err := client.ListSnapshotsFromDRSecondarySlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsFromDRSecondarySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSnapshotsFromDRSecondarySlotSender(req)
	if err != nil {
		result.sc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsFromDRSecondarySlot", resp, "Failure sending request")
		return
	}

	result.sc, err = client.ListSnapshotsFromDRSecondarySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsFromDRSecondarySlot", resp, "Failure responding to request")
	}

	return
}

// ListSnapshotsFromDRSecondarySlotPreparer prepares the ListSnapshotsFromDRSecondarySlot request.
func (client AppsClient) ListSnapshotsFromDRSecondarySlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSnapshotsFromDRSecondarySlotSender sends the ListSnapshotsFromDRSecondarySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSnapshotsFromDRSecondarySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSnapshotsFromDRSecondarySlotResponder handles the response to the ListSnapshotsFromDRSecondarySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSnapshotsFromDRSecondarySlotResponder(resp *http.Response) (result SnapshotCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSnapshotsFromDRSecondarySlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listSnapshotsFromDRSecondarySlotNextResults(ctx context.Context, lastResults SnapshotCollection) (result SnapshotCollection, err error) {
	req, err := lastResults.snapshotCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsFromDRSecondarySlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSnapshotsFromDRSecondarySlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsFromDRSecondarySlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSnapshotsFromDRSecondarySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsFromDRSecondarySlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSnapshotsFromDRSecondarySlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSnapshotsFromDRSecondarySlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result SnapshotCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshotsFromDRSecondarySlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSnapshotsFromDRSecondarySlot(ctx, resourceGroupName, name, slot)
	return
}

// ListSnapshotsSlot returns all Snapshots to the user.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - website Name.
// slot - website Slot.
func (client AppsClient) ListSnapshotsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result SnapshotCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshotsSlot")
		defer func() {
			sc := -1
			if result.sc.Response.Response != nil {
				sc = result.sc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSnapshotsSlot", err.Error())
	}

	result.fn = client.listSnapshotsSlotNextResults
	req, err := client.ListSnapshotsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSnapshotsSlotSender(req)
	if err != nil {
		result.sc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsSlot", resp, "Failure sending request")
		return
	}

	result.sc, err = client.ListSnapshotsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSnapshotsSlot", resp, "Failure responding to request")
	}

	return
}

// ListSnapshotsSlotPreparer prepares the ListSnapshotsSlot request.
func (client AppsClient) ListSnapshotsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSnapshotsSlotSender sends the ListSnapshotsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSnapshotsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSnapshotsSlotResponder handles the response to the ListSnapshotsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSnapshotsSlotResponder(resp *http.Response) (result SnapshotCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSnapshotsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listSnapshotsSlotNextResults(ctx context.Context, lastResults SnapshotCollection) (result SnapshotCollection, err error) {
	req, err := lastResults.snapshotCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSnapshotsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSnapshotsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listSnapshotsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSnapshotsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListSnapshotsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result SnapshotCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSnapshotsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSnapshotsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListSyncFunctionTriggers this is to allow calling via powershell and ARM template.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListSyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string) (result FunctionSecrets, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSyncFunctionTriggers")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSyncFunctionTriggers", err.Error())
	}

	req, err := client.ListSyncFunctionTriggersPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSyncFunctionTriggers", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSyncFunctionTriggersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSyncFunctionTriggers", resp, "Failure sending request")
		return
	}

	result, err = client.ListSyncFunctionTriggersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSyncFunctionTriggers", resp, "Failure responding to request")
	}

	return
}

// ListSyncFunctionTriggersPreparer prepares the ListSyncFunctionTriggers request.
func (client AppsClient) ListSyncFunctionTriggersPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSyncFunctionTriggersSender sends the ListSyncFunctionTriggers request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSyncFunctionTriggersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSyncFunctionTriggersResponder handles the response to the ListSyncFunctionTriggers request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSyncFunctionTriggersResponder(resp *http.Response) (result FunctionSecrets, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSyncFunctionTriggersSlot this is to allow calling via powershell and ARM template.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will restore a backup of the
// production slot.
func (client AppsClient) ListSyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result FunctionSecrets, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListSyncFunctionTriggersSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListSyncFunctionTriggersSlot", err.Error())
	}

	req, err := client.ListSyncFunctionTriggersSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSyncFunctionTriggersSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSyncFunctionTriggersSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSyncFunctionTriggersSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListSyncFunctionTriggersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListSyncFunctionTriggersSlot", resp, "Failure responding to request")
	}

	return
}

// ListSyncFunctionTriggersSlotPreparer prepares the ListSyncFunctionTriggersSlot request.
func (client AppsClient) ListSyncFunctionTriggersSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSyncFunctionTriggersSlotSender sends the ListSyncFunctionTriggersSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListSyncFunctionTriggersSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListSyncFunctionTriggersSlotResponder handles the response to the ListSyncFunctionTriggersSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListSyncFunctionTriggersSlotResponder(resp *http.Response) (result FunctionSecrets, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListTriggeredWebJobHistory list a triggered web job's history for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) ListTriggeredWebJobHistory(ctx context.Context, resourceGroupName string, name string, webJobName string) (result TriggeredJobHistoryCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobHistory")
		defer func() {
			sc := -1
			if result.tjhc.Response.Response != nil {
				sc = result.tjhc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListTriggeredWebJobHistory", err.Error())
	}

	result.fn = client.listTriggeredWebJobHistoryNextResults
	req, err := client.ListTriggeredWebJobHistoryPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobHistory", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTriggeredWebJobHistorySender(req)
	if err != nil {
		result.tjhc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobHistory", resp, "Failure sending request")
		return
	}

	result.tjhc, err = client.ListTriggeredWebJobHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobHistory", resp, "Failure responding to request")
	}

	return
}

// ListTriggeredWebJobHistoryPreparer prepares the ListTriggeredWebJobHistory request.
func (client AppsClient) ListTriggeredWebJobHistoryPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListTriggeredWebJobHistorySender sends the ListTriggeredWebJobHistory request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListTriggeredWebJobHistorySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListTriggeredWebJobHistoryResponder handles the response to the ListTriggeredWebJobHistory request. The method always
// closes the http.Response Body.
func (client AppsClient) ListTriggeredWebJobHistoryResponder(resp *http.Response) (result TriggeredJobHistoryCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listTriggeredWebJobHistoryNextResults retrieves the next set of results, if any.
func (client AppsClient) listTriggeredWebJobHistoryNextResults(ctx context.Context, lastResults TriggeredJobHistoryCollection) (result TriggeredJobHistoryCollection, err error) {
	req, err := lastResults.triggeredJobHistoryCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobHistoryNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListTriggeredWebJobHistorySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobHistoryNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListTriggeredWebJobHistoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobHistoryNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListTriggeredWebJobHistoryComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListTriggeredWebJobHistoryComplete(ctx context.Context, resourceGroupName string, name string, webJobName string) (result TriggeredJobHistoryCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobHistory")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListTriggeredWebJobHistory(ctx, resourceGroupName, name, webJobName)
	return
}

// ListTriggeredWebJobHistorySlot list a triggered web job's history for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) ListTriggeredWebJobHistorySlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result TriggeredJobHistoryCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobHistorySlot")
		defer func() {
			sc := -1
			if result.tjhc.Response.Response != nil {
				sc = result.tjhc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListTriggeredWebJobHistorySlot", err.Error())
	}

	result.fn = client.listTriggeredWebJobHistorySlotNextResults
	req, err := client.ListTriggeredWebJobHistorySlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobHistorySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTriggeredWebJobHistorySlotSender(req)
	if err != nil {
		result.tjhc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobHistorySlot", resp, "Failure sending request")
		return
	}

	result.tjhc, err = client.ListTriggeredWebJobHistorySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobHistorySlot", resp, "Failure responding to request")
	}

	return
}

// ListTriggeredWebJobHistorySlotPreparer prepares the ListTriggeredWebJobHistorySlot request.
func (client AppsClient) ListTriggeredWebJobHistorySlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListTriggeredWebJobHistorySlotSender sends the ListTriggeredWebJobHistorySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListTriggeredWebJobHistorySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListTriggeredWebJobHistorySlotResponder handles the response to the ListTriggeredWebJobHistorySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListTriggeredWebJobHistorySlotResponder(resp *http.Response) (result TriggeredJobHistoryCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listTriggeredWebJobHistorySlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listTriggeredWebJobHistorySlotNextResults(ctx context.Context, lastResults TriggeredJobHistoryCollection) (result TriggeredJobHistoryCollection, err error) {
	req, err := lastResults.triggeredJobHistoryCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobHistorySlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListTriggeredWebJobHistorySlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobHistorySlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListTriggeredWebJobHistorySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobHistorySlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListTriggeredWebJobHistorySlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListTriggeredWebJobHistorySlotComplete(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result TriggeredJobHistoryCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobHistorySlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListTriggeredWebJobHistorySlot(ctx, resourceGroupName, name, webJobName, slot)
	return
}

// ListTriggeredWebJobs list triggered web jobs for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
func (client AppsClient) ListTriggeredWebJobs(ctx context.Context, resourceGroupName string, name string) (result TriggeredWebJobCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobs")
		defer func() {
			sc := -1
			if result.twjc.Response.Response != nil {
				sc = result.twjc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListTriggeredWebJobs", err.Error())
	}

	result.fn = client.listTriggeredWebJobsNextResults
	req, err := client.ListTriggeredWebJobsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobs", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTriggeredWebJobsSender(req)
	if err != nil {
		result.twjc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobs", resp, "Failure sending request")
		return
	}

	result.twjc, err = client.ListTriggeredWebJobsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobs", resp, "Failure responding to request")
	}

	return
}

// ListTriggeredWebJobsPreparer prepares the ListTriggeredWebJobs request.
func (client AppsClient) ListTriggeredWebJobsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListTriggeredWebJobsSender sends the ListTriggeredWebJobs request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListTriggeredWebJobsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListTriggeredWebJobsResponder handles the response to the ListTriggeredWebJobs request. The method always
// closes the http.Response Body.
func (client AppsClient) ListTriggeredWebJobsResponder(resp *http.Response) (result TriggeredWebJobCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listTriggeredWebJobsNextResults retrieves the next set of results, if any.
func (client AppsClient) listTriggeredWebJobsNextResults(ctx context.Context, lastResults TriggeredWebJobCollection) (result TriggeredWebJobCollection, err error) {
	req, err := lastResults.triggeredWebJobCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListTriggeredWebJobsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListTriggeredWebJobsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListTriggeredWebJobsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListTriggeredWebJobsComplete(ctx context.Context, resourceGroupName string, name string) (result TriggeredWebJobCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobs")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListTriggeredWebJobs(ctx, resourceGroupName, name)
	return
}

// ListTriggeredWebJobsSlot list triggered web jobs for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) ListTriggeredWebJobsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result TriggeredWebJobCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobsSlot")
		defer func() {
			sc := -1
			if result.twjc.Response.Response != nil {
				sc = result.twjc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListTriggeredWebJobsSlot", err.Error())
	}

	result.fn = client.listTriggeredWebJobsSlotNextResults
	req, err := client.ListTriggeredWebJobsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListTriggeredWebJobsSlotSender(req)
	if err != nil {
		result.twjc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobsSlot", resp, "Failure sending request")
		return
	}

	result.twjc, err = client.ListTriggeredWebJobsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListTriggeredWebJobsSlot", resp, "Failure responding to request")
	}

	return
}

// ListTriggeredWebJobsSlotPreparer prepares the ListTriggeredWebJobsSlot request.
func (client AppsClient) ListTriggeredWebJobsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListTriggeredWebJobsSlotSender sends the ListTriggeredWebJobsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListTriggeredWebJobsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListTriggeredWebJobsSlotResponder handles the response to the ListTriggeredWebJobsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListTriggeredWebJobsSlotResponder(resp *http.Response) (result TriggeredWebJobCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listTriggeredWebJobsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listTriggeredWebJobsSlotNextResults(ctx context.Context, lastResults TriggeredWebJobCollection) (result TriggeredWebJobCollection, err error) {
	req, err := lastResults.triggeredWebJobCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListTriggeredWebJobsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListTriggeredWebJobsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listTriggeredWebJobsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListTriggeredWebJobsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListTriggeredWebJobsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result TriggeredWebJobCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListTriggeredWebJobsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListTriggeredWebJobsSlot(ctx, resourceGroupName, name, slot)
	return
}

// ListUsages gets the quota usage information of an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// filter - return only information specified in the filter (using OData syntax). For example:
// $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq 2014-01-01T00:00:00Z and
// endTime eq 2014-12-31T23:59:59Z and timeGrain eq duration'[Hour|Minute|Day]'.
func (client AppsClient) ListUsages(ctx context.Context, resourceGroupName string, name string, filter string) (result CsmUsageQuotaCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListUsages")
		defer func() {
			sc := -1
			if result.cuqc.Response.Response != nil {
				sc = result.cuqc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListUsages", err.Error())
	}

	result.fn = client.listUsagesNextResults
	req, err := client.ListUsagesPreparer(ctx, resourceGroupName, name, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListUsages", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListUsagesSender(req)
	if err != nil {
		result.cuqc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListUsages", resp, "Failure sending request")
		return
	}

	result.cuqc, err = client.ListUsagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListUsages", resp, "Failure responding to request")
	}

	return
}

// ListUsagesPreparer prepares the ListUsages request.
func (client AppsClient) ListUsagesPreparer(ctx context.Context, resourceGroupName string, name string, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = filter
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListUsagesSender sends the ListUsages request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListUsagesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListUsagesResponder handles the response to the ListUsages request. The method always
// closes the http.Response Body.
func (client AppsClient) ListUsagesResponder(resp *http.Response) (result CsmUsageQuotaCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listUsagesNextResults retrieves the next set of results, if any.
func (client AppsClient) listUsagesNextResults(ctx context.Context, lastResults CsmUsageQuotaCollection) (result CsmUsageQuotaCollection, err error) {
	req, err := lastResults.csmUsageQuotaCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listUsagesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListUsagesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listUsagesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListUsagesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listUsagesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListUsagesComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListUsagesComplete(ctx context.Context, resourceGroupName string, name string, filter string) (result CsmUsageQuotaCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListUsages")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListUsages(ctx, resourceGroupName, name, filter)
	return
}

// ListUsagesSlot gets the quota usage information of an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get quota information of the
// production slot.
// filter - return only information specified in the filter (using OData syntax). For example:
// $filter=(name.value eq 'Metric1' or name.value eq 'Metric2') and startTime eq 2014-01-01T00:00:00Z and
// endTime eq 2014-12-31T23:59:59Z and timeGrain eq duration'[Hour|Minute|Day]'.
func (client AppsClient) ListUsagesSlot(ctx context.Context, resourceGroupName string, name string, slot string, filter string) (result CsmUsageQuotaCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListUsagesSlot")
		defer func() {
			sc := -1
			if result.cuqc.Response.Response != nil {
				sc = result.cuqc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListUsagesSlot", err.Error())
	}

	result.fn = client.listUsagesSlotNextResults
	req, err := client.ListUsagesSlotPreparer(ctx, resourceGroupName, name, slot, filter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListUsagesSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListUsagesSlotSender(req)
	if err != nil {
		result.cuqc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListUsagesSlot", resp, "Failure sending request")
		return
	}

	result.cuqc, err = client.ListUsagesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListUsagesSlot", resp, "Failure responding to request")
	}

	return
}

// ListUsagesSlotPreparer prepares the ListUsagesSlot request.
func (client AppsClient) ListUsagesSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, filter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = filter
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListUsagesSlotSender sends the ListUsagesSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListUsagesSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListUsagesSlotResponder handles the response to the ListUsagesSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListUsagesSlotResponder(resp *http.Response) (result CsmUsageQuotaCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listUsagesSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listUsagesSlotNextResults(ctx context.Context, lastResults CsmUsageQuotaCollection) (result CsmUsageQuotaCollection, err error) {
	req, err := lastResults.csmUsageQuotaCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listUsagesSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListUsagesSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listUsagesSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListUsagesSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listUsagesSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListUsagesSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListUsagesSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string, filter string) (result CsmUsageQuotaCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListUsagesSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListUsagesSlot(ctx, resourceGroupName, name, slot, filter)
	return
}

// ListVnetConnections gets the virtual networks the app (or deployment slot) is connected to.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ListVnetConnections(ctx context.Context, resourceGroupName string, name string) (result ListVnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListVnetConnections")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListVnetConnections", err.Error())
	}

	req, err := client.ListVnetConnectionsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListVnetConnections", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListVnetConnectionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListVnetConnections", resp, "Failure sending request")
		return
	}

	result, err = client.ListVnetConnectionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListVnetConnections", resp, "Failure responding to request")
	}

	return
}

// ListVnetConnectionsPreparer prepares the ListVnetConnections request.
func (client AppsClient) ListVnetConnectionsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListVnetConnectionsSender sends the ListVnetConnections request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListVnetConnectionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListVnetConnectionsResponder handles the response to the ListVnetConnections request. The method always
// closes the http.Response Body.
func (client AppsClient) ListVnetConnectionsResponder(resp *http.Response) (result ListVnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListVnetConnectionsSlot gets the virtual networks the app (or deployment slot) is connected to.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will get virtual network connections
// for the production slot.
func (client AppsClient) ListVnetConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result ListVnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListVnetConnectionsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListVnetConnectionsSlot", err.Error())
	}

	req, err := client.ListVnetConnectionsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListVnetConnectionsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListVnetConnectionsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListVnetConnectionsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ListVnetConnectionsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListVnetConnectionsSlot", resp, "Failure responding to request")
	}

	return
}

// ListVnetConnectionsSlotPreparer prepares the ListVnetConnectionsSlot request.
func (client AppsClient) ListVnetConnectionsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListVnetConnectionsSlotSender sends the ListVnetConnectionsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListVnetConnectionsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListVnetConnectionsSlotResponder handles the response to the ListVnetConnectionsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListVnetConnectionsSlotResponder(resp *http.Response) (result ListVnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListWebJobs list webjobs for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
func (client AppsClient) ListWebJobs(ctx context.Context, resourceGroupName string, name string) (result JobCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListWebJobs")
		defer func() {
			sc := -1
			if result.jc.Response.Response != nil {
				sc = result.jc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListWebJobs", err.Error())
	}

	result.fn = client.listWebJobsNextResults
	req, err := client.ListWebJobsPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListWebJobs", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListWebJobsSender(req)
	if err != nil {
		result.jc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListWebJobs", resp, "Failure sending request")
		return
	}

	result.jc, err = client.ListWebJobsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListWebJobs", resp, "Failure responding to request")
	}

	return
}

// ListWebJobsPreparer prepares the ListWebJobs request.
func (client AppsClient) ListWebJobsPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListWebJobsSender sends the ListWebJobs request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListWebJobsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListWebJobsResponder handles the response to the ListWebJobs request. The method always
// closes the http.Response Body.
func (client AppsClient) ListWebJobsResponder(resp *http.Response) (result JobCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listWebJobsNextResults retrieves the next set of results, if any.
func (client AppsClient) listWebJobsNextResults(ctx context.Context, lastResults JobCollection) (result JobCollection, err error) {
	req, err := lastResults.jobCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listWebJobsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListWebJobsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listWebJobsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListWebJobsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listWebJobsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListWebJobsComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListWebJobsComplete(ctx context.Context, resourceGroupName string, name string) (result JobCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListWebJobs")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListWebJobs(ctx, resourceGroupName, name)
	return
}

// ListWebJobsSlot list webjobs for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// slot - name of the deployment slot. If a slot is not specified, the API returns deployments for the
// production slot.
func (client AppsClient) ListWebJobsSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result JobCollectionPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListWebJobsSlot")
		defer func() {
			sc := -1
			if result.jc.Response.Response != nil {
				sc = result.jc.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ListWebJobsSlot", err.Error())
	}

	result.fn = client.listWebJobsSlotNextResults
	req, err := client.ListWebJobsSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListWebJobsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListWebJobsSlotSender(req)
	if err != nil {
		result.jc.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListWebJobsSlot", resp, "Failure sending request")
		return
	}

	result.jc, err = client.ListWebJobsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ListWebJobsSlot", resp, "Failure responding to request")
	}

	return
}

// ListWebJobsSlotPreparer prepares the ListWebJobsSlot request.
func (client AppsClient) ListWebJobsSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListWebJobsSlotSender sends the ListWebJobsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ListWebJobsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ListWebJobsSlotResponder handles the response to the ListWebJobsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ListWebJobsSlotResponder(resp *http.Response) (result JobCollection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listWebJobsSlotNextResults retrieves the next set of results, if any.
func (client AppsClient) listWebJobsSlotNextResults(ctx context.Context, lastResults JobCollection) (result JobCollection, err error) {
	req, err := lastResults.jobCollectionPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listWebJobsSlotNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListWebJobsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "web.AppsClient", "listWebJobsSlotNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListWebJobsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "listWebJobsSlotNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListWebJobsSlotComplete enumerates all values, automatically crossing page boundaries as required.
func (client AppsClient) ListWebJobsSlotComplete(ctx context.Context, resourceGroupName string, name string, slot string) (result JobCollectionIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ListWebJobsSlot")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListWebJobsSlot(ctx, resourceGroupName, name, slot)
	return
}

// MigrateMySQL migrates a local (in-app) MySql database to a remote MySql database.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// migrationRequestEnvelope - mySql migration options.
func (client AppsClient) MigrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest) (result AppsMigrateMySQLFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.MigrateMySQL")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: migrationRequestEnvelope,
			Constraints: []validation.Constraint{{Target: "migrationRequestEnvelope.MigrateMySQLRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "migrationRequestEnvelope.MigrateMySQLRequestProperties.ConnectionString", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "MigrateMySQL", err.Error())
	}

	req, err := client.MigrateMySQLPreparer(ctx, resourceGroupName, name, migrationRequestEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "MigrateMySQL", nil, "Failure preparing request")
		return
	}

	result, err = client.MigrateMySQLSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "MigrateMySQL", result.Response(), "Failure sending request")
		return
	}

	return
}

// MigrateMySQLPreparer prepares the MigrateMySQL request.
func (client AppsClient) MigrateMySQLPreparer(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql", pathParameters),
		autorest.WithJSON(migrationRequestEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// MigrateMySQLSender sends the MigrateMySQL request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) MigrateMySQLSender(req *http.Request) (future AppsMigrateMySQLFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// MigrateMySQLResponder handles the response to the MigrateMySQL request. The method always
// closes the http.Response Body.
func (client AppsClient) MigrateMySQLResponder(resp *http.Response) (result Operation, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// MigrateStorage restores a web app.
// Parameters:
// subscriptionName - azure subscription.
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// migrationOptions - migration migrationOptions.
func (client AppsClient) MigrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions) (result AppsMigrateStorageFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.MigrateStorage")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: migrationOptions,
			Constraints: []validation.Constraint{{Target: "migrationOptions.StorageMigrationOptionsProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "migrationOptions.StorageMigrationOptionsProperties.AzurefilesConnectionString", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "migrationOptions.StorageMigrationOptionsProperties.AzurefilesShare", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "MigrateStorage", err.Error())
	}

	req, err := client.MigrateStoragePreparer(ctx, subscriptionName, resourceGroupName, name, migrationOptions)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "MigrateStorage", nil, "Failure preparing request")
		return
	}

	result, err = client.MigrateStorageSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "MigrateStorage", result.Response(), "Failure sending request")
		return
	}

	return
}

// MigrateStoragePreparer prepares the MigrateStorage request.
func (client AppsClient) MigrateStoragePreparer(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version":      APIVersion,
		"subscriptionName": autorest.Encode("query", subscriptionName),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate", pathParameters),
		autorest.WithJSON(migrationOptions),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// MigrateStorageSender sends the MigrateStorage request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) MigrateStorageSender(req *http.Request) (future AppsMigrateStorageFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// MigrateStorageResponder handles the response to the MigrateStorage request. The method always
// closes the http.Response Body.
func (client AppsClient) MigrateStorageResponder(resp *http.Response) (result StorageMigrationResponse, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutPrivateAccessVnet sets data around private site access enablement and authorized Virtual Networks that can access
// the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// access - the information for the private access
func (client AppsClient) PutPrivateAccessVnet(ctx context.Context, resourceGroupName string, name string, access PrivateAccess) (result PrivateAccess, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.PutPrivateAccessVnet")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "PutPrivateAccessVnet", err.Error())
	}

	req, err := client.PutPrivateAccessVnetPreparer(ctx, resourceGroupName, name, access)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "PutPrivateAccessVnet", nil, "Failure preparing request")
		return
	}

	resp, err := client.PutPrivateAccessVnetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "PutPrivateAccessVnet", resp, "Failure sending request")
		return
	}

	result, err = client.PutPrivateAccessVnetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "PutPrivateAccessVnet", resp, "Failure responding to request")
	}

	return
}

// PutPrivateAccessVnetPreparer prepares the PutPrivateAccessVnet request.
func (client AppsClient) PutPrivateAccessVnetPreparer(ctx context.Context, resourceGroupName string, name string, access PrivateAccess) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks", pathParameters),
		autorest.WithJSON(access),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutPrivateAccessVnetSender sends the PutPrivateAccessVnet request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) PutPrivateAccessVnetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// PutPrivateAccessVnetResponder handles the response to the PutPrivateAccessVnet request. The method always
// closes the http.Response Body.
func (client AppsClient) PutPrivateAccessVnetResponder(resp *http.Response) (result PrivateAccess, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// PutPrivateAccessVnetSlot sets data around private site access enablement and authorized Virtual Networks that can
// access the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// access - the information for the private access
// slot - the name of the slot for the web app.
func (client AppsClient) PutPrivateAccessVnetSlot(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, slot string) (result PrivateAccess, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.PutPrivateAccessVnetSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "PutPrivateAccessVnetSlot", err.Error())
	}

	req, err := client.PutPrivateAccessVnetSlotPreparer(ctx, resourceGroupName, name, access, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "PutPrivateAccessVnetSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.PutPrivateAccessVnetSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "PutPrivateAccessVnetSlot", resp, "Failure sending request")
		return
	}

	result, err = client.PutPrivateAccessVnetSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "PutPrivateAccessVnetSlot", resp, "Failure responding to request")
	}

	return
}

// PutPrivateAccessVnetSlotPreparer prepares the PutPrivateAccessVnetSlot request.
func (client AppsClient) PutPrivateAccessVnetSlotPreparer(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks", pathParameters),
		autorest.WithJSON(access),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// PutPrivateAccessVnetSlotSender sends the PutPrivateAccessVnetSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) PutPrivateAccessVnetSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// PutPrivateAccessVnetSlotResponder handles the response to the PutPrivateAccessVnetSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) PutPrivateAccessVnetSlotResponder(resp *http.Response) (result PrivateAccess, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// RecoverSiteConfigurationSnapshot reverts the configuration of an app to a previous snapshot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// snapshotID - the ID of the snapshot to read.
func (client AppsClient) RecoverSiteConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RecoverSiteConfigurationSnapshot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RecoverSiteConfigurationSnapshot", err.Error())
	}

	req, err := client.RecoverSiteConfigurationSnapshotPreparer(ctx, resourceGroupName, name, snapshotID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RecoverSiteConfigurationSnapshot", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverSiteConfigurationSnapshotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RecoverSiteConfigurationSnapshot", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverSiteConfigurationSnapshotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RecoverSiteConfigurationSnapshot", resp, "Failure responding to request")
	}

	return
}

// RecoverSiteConfigurationSnapshotPreparer prepares the RecoverSiteConfigurationSnapshot request.
func (client AppsClient) RecoverSiteConfigurationSnapshotPreparer(ctx context.Context, resourceGroupName string, name string, snapshotID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"snapshotId":        autorest.Encode("path", snapshotID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RecoverSiteConfigurationSnapshotSender sends the RecoverSiteConfigurationSnapshot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RecoverSiteConfigurationSnapshotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// RecoverSiteConfigurationSnapshotResponder handles the response to the RecoverSiteConfigurationSnapshot request. The method always
// closes the http.Response Body.
func (client AppsClient) RecoverSiteConfigurationSnapshotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RecoverSiteConfigurationSnapshotSlot reverts the configuration of an app to a previous snapshot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// snapshotID - the ID of the snapshot to read.
// slot - name of the deployment slot. If a slot is not specified, the API will return configuration for the
// production slot.
func (client AppsClient) RecoverSiteConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RecoverSiteConfigurationSnapshotSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RecoverSiteConfigurationSnapshotSlot", err.Error())
	}

	req, err := client.RecoverSiteConfigurationSnapshotSlotPreparer(ctx, resourceGroupName, name, snapshotID, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RecoverSiteConfigurationSnapshotSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.RecoverSiteConfigurationSnapshotSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RecoverSiteConfigurationSnapshotSlot", resp, "Failure sending request")
		return
	}

	result, err = client.RecoverSiteConfigurationSnapshotSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RecoverSiteConfigurationSnapshotSlot", resp, "Failure responding to request")
	}

	return
}

// RecoverSiteConfigurationSnapshotSlotPreparer prepares the RecoverSiteConfigurationSnapshotSlot request.
func (client AppsClient) RecoverSiteConfigurationSnapshotSlotPreparer(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"snapshotId":        autorest.Encode("path", snapshotID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RecoverSiteConfigurationSnapshotSlotSender sends the RecoverSiteConfigurationSnapshotSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RecoverSiteConfigurationSnapshotSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// RecoverSiteConfigurationSnapshotSlotResponder handles the response to the RecoverSiteConfigurationSnapshotSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RecoverSiteConfigurationSnapshotSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResetProductionSlotConfig resets the configuration settings of the current slot if they were previously modified by
// calling the API with POST.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) ResetProductionSlotConfig(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ResetProductionSlotConfig")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ResetProductionSlotConfig", err.Error())
	}

	req, err := client.ResetProductionSlotConfigPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ResetProductionSlotConfig", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResetProductionSlotConfigSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ResetProductionSlotConfig", resp, "Failure sending request")
		return
	}

	result, err = client.ResetProductionSlotConfigResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ResetProductionSlotConfig", resp, "Failure responding to request")
	}

	return
}

// ResetProductionSlotConfigPreparer prepares the ResetProductionSlotConfig request.
func (client AppsClient) ResetProductionSlotConfigPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResetProductionSlotConfigSender sends the ResetProductionSlotConfig request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ResetProductionSlotConfigSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ResetProductionSlotConfigResponder handles the response to the ResetProductionSlotConfig request. The method always
// closes the http.Response Body.
func (client AppsClient) ResetProductionSlotConfigResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ResetSlotConfigurationSlot resets the configuration settings of the current slot if they were previously modified by
// calling the API with POST.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API resets configuration settings for
// the production slot.
func (client AppsClient) ResetSlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.ResetSlotConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "ResetSlotConfigurationSlot", err.Error())
	}

	req, err := client.ResetSlotConfigurationSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ResetSlotConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.ResetSlotConfigurationSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ResetSlotConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.ResetSlotConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "ResetSlotConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// ResetSlotConfigurationSlotPreparer prepares the ResetSlotConfigurationSlot request.
func (client AppsClient) ResetSlotConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ResetSlotConfigurationSlotSender sends the ResetSlotConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) ResetSlotConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// ResetSlotConfigurationSlotResponder handles the response to the ResetSlotConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) ResetSlotConfigurationSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Restart restarts an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// softRestart - specify true to apply the configuration settings and restarts the app only if necessary. By
// default, the API always restarts and reprovisions the app.
// synchronous - specify true to block until the app is restarted. By default, it is set to false, and the API
// responds immediately (asynchronous).
func (client AppsClient) Restart(ctx context.Context, resourceGroupName string, name string, softRestart *bool, synchronous *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Restart")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Restart", err.Error())
	}

	req, err := client.RestartPreparer(ctx, resourceGroupName, name, softRestart, synchronous)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Restart", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Restart", resp, "Failure sending request")
		return
	}

	result, err = client.RestartResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Restart", resp, "Failure responding to request")
	}

	return
}

// RestartPreparer prepares the Restart request.
func (client AppsClient) RestartPreparer(ctx context.Context, resourceGroupName string, name string, softRestart *bool, synchronous *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if softRestart != nil {
		queryParameters["softRestart"] = autorest.Encode("query", *softRestart)
	}
	if synchronous != nil {
		queryParameters["synchronous"] = autorest.Encode("query", *synchronous)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestartSender sends the Restart request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestartSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// RestartResponder handles the response to the Restart request. The method always
// closes the http.Response Body.
func (client AppsClient) RestartResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestartSlot restarts an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will restart the production slot.
// softRestart - specify true to apply the configuration settings and restarts the app only if necessary. By
// default, the API always restarts and reprovisions the app.
// synchronous - specify true to block until the app is restarted. By default, it is set to false, and the API
// responds immediately (asynchronous).
func (client AppsClient) RestartSlot(ctx context.Context, resourceGroupName string, name string, slot string, softRestart *bool, synchronous *bool) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestartSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestartSlot", err.Error())
	}

	req, err := client.RestartSlotPreparer(ctx, resourceGroupName, name, slot, softRestart, synchronous)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestartSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.RestartSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestartSlot", resp, "Failure sending request")
		return
	}

	result, err = client.RestartSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestartSlot", resp, "Failure responding to request")
	}

	return
}

// RestartSlotPreparer prepares the RestartSlot request.
func (client AppsClient) RestartSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, softRestart *bool, synchronous *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if softRestart != nil {
		queryParameters["softRestart"] = autorest.Encode("query", *softRestart)
	}
	if synchronous != nil {
		queryParameters["synchronous"] = autorest.Encode("query", *synchronous)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestartSlotSender sends the RestartSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestartSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// RestartSlotResponder handles the response to the RestartSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RestartSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Restore restores a specific backup to another app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// backupID - ID of the backup.
// request - information on restore request .
func (client AppsClient) Restore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest) (result AppsRestoreFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Restore")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.RestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.RestoreRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.RestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Restore", err.Error())
	}

	req, err := client.RestorePreparer(ctx, resourceGroupName, name, backupID, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Restore", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Restore", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestorePreparer prepares the Restore request.
func (client AppsClient) RestorePreparer(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreSender sends the Restore request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreSender(req *http.Request) (future AppsRestoreFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreResponder handles the response to the Restore request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreFromBackupBlob restores an app from a backup blob in Azure Storage.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - information on restore request .
func (client AppsClient) RestoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest) (result AppsRestoreFromBackupBlobFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreFromBackupBlob")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.RestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.RestoreRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.RestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreFromBackupBlob", err.Error())
	}

	req, err := client.RestoreFromBackupBlobPreparer(ctx, resourceGroupName, name, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromBackupBlob", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreFromBackupBlobSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromBackupBlob", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreFromBackupBlobPreparer prepares the RestoreFromBackupBlob request.
func (client AppsClient) RestoreFromBackupBlobPreparer(ctx context.Context, resourceGroupName string, name string, request RestoreRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreFromBackupBlobSender sends the RestoreFromBackupBlob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreFromBackupBlobSender(req *http.Request) (future AppsRestoreFromBackupBlobFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreFromBackupBlobResponder handles the response to the RestoreFromBackupBlob request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreFromBackupBlobResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreFromBackupBlobSlot restores an app from a backup blob in Azure Storage.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - information on restore request .
// slot - name of the deployment slot. If a slot is not specified, the API will restore a backup of the
// production slot.
func (client AppsClient) RestoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, slot string) (result AppsRestoreFromBackupBlobSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreFromBackupBlobSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.RestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.RestoreRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.RestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreFromBackupBlobSlot", err.Error())
	}

	req, err := client.RestoreFromBackupBlobSlotPreparer(ctx, resourceGroupName, name, request, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromBackupBlobSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreFromBackupBlobSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromBackupBlobSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreFromBackupBlobSlotPreparer prepares the RestoreFromBackupBlobSlot request.
func (client AppsClient) RestoreFromBackupBlobSlotPreparer(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreFromBackupBlobSlotSender sends the RestoreFromBackupBlobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreFromBackupBlobSlotSender(req *http.Request) (future AppsRestoreFromBackupBlobSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreFromBackupBlobSlotResponder handles the response to the RestoreFromBackupBlobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreFromBackupBlobSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreFromDeletedApp restores a deleted web app to this web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// restoreRequest - deleted web app restore information.
func (client AppsClient) RestoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest) (result AppsRestoreFromDeletedAppFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreFromDeletedApp")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreFromDeletedApp", err.Error())
	}

	req, err := client.RestoreFromDeletedAppPreparer(ctx, resourceGroupName, name, restoreRequest)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromDeletedApp", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreFromDeletedAppSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromDeletedApp", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreFromDeletedAppPreparer prepares the RestoreFromDeletedApp request.
func (client AppsClient) RestoreFromDeletedAppPreparer(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp", pathParameters),
		autorest.WithJSON(restoreRequest),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreFromDeletedAppSender sends the RestoreFromDeletedApp request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreFromDeletedAppSender(req *http.Request) (future AppsRestoreFromDeletedAppFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreFromDeletedAppResponder handles the response to the RestoreFromDeletedApp request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreFromDeletedAppResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreFromDeletedAppSlot restores a deleted web app to this web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// restoreRequest - deleted web app restore information.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) RestoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, slot string) (result AppsRestoreFromDeletedAppSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreFromDeletedAppSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreFromDeletedAppSlot", err.Error())
	}

	req, err := client.RestoreFromDeletedAppSlotPreparer(ctx, resourceGroupName, name, restoreRequest, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromDeletedAppSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreFromDeletedAppSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreFromDeletedAppSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreFromDeletedAppSlotPreparer prepares the RestoreFromDeletedAppSlot request.
func (client AppsClient) RestoreFromDeletedAppSlotPreparer(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp", pathParameters),
		autorest.WithJSON(restoreRequest),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreFromDeletedAppSlotSender sends the RestoreFromDeletedAppSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreFromDeletedAppSlotSender(req *http.Request) (future AppsRestoreFromDeletedAppSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreFromDeletedAppSlotResponder handles the response to the RestoreFromDeletedAppSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreFromDeletedAppSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreSlot restores a specific backup to another app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// backupID - ID of the backup.
// request - information on restore request .
// slot - name of the deployment slot. If a slot is not specified, the API will restore a backup of the
// production slot.
func (client AppsClient) RestoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, slot string) (result AppsRestoreSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.RestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.RestoreRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.RestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreSlot", err.Error())
	}

	req, err := client.RestoreSlotPreparer(ctx, resourceGroupName, name, backupID, request, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreSlotPreparer prepares the RestoreSlot request.
func (client AppsClient) RestoreSlotPreparer(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"backupId":          autorest.Encode("path", backupID),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreSlotSender sends the RestoreSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreSlotSender(req *http.Request) (future AppsRestoreSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreSlotResponder handles the response to the RestoreSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreSnapshot restores a web app from a snapshot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// restoreRequest - snapshot restore settings. Snapshot information can be obtained by calling GetDeletedSites
// or GetSiteSnapshots API.
func (client AppsClient) RestoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest) (result AppsRestoreSnapshotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreSnapshot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: restoreRequest,
			Constraints: []validation.Constraint{{Target: "restoreRequest.SnapshotRestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "restoreRequest.SnapshotRestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreSnapshot", err.Error())
	}

	req, err := client.RestoreSnapshotPreparer(ctx, resourceGroupName, name, restoreRequest)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreSnapshot", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreSnapshotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreSnapshot", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreSnapshotPreparer prepares the RestoreSnapshot request.
func (client AppsClient) RestoreSnapshotPreparer(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot", pathParameters),
		autorest.WithJSON(restoreRequest),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreSnapshotSender sends the RestoreSnapshot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreSnapshotSender(req *http.Request) (future AppsRestoreSnapshotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreSnapshotResponder handles the response to the RestoreSnapshot request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreSnapshotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RestoreSnapshotSlot restores a web app from a snapshot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// restoreRequest - snapshot restore settings. Snapshot information can be obtained by calling GetDeletedSites
// or GetSiteSnapshots API.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) RestoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, slot string) (result AppsRestoreSnapshotSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RestoreSnapshotSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: restoreRequest,
			Constraints: []validation.Constraint{{Target: "restoreRequest.SnapshotRestoreRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "restoreRequest.SnapshotRestoreRequestProperties.Overwrite", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RestoreSnapshotSlot", err.Error())
	}

	req, err := client.RestoreSnapshotSlotPreparer(ctx, resourceGroupName, name, restoreRequest, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreSnapshotSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.RestoreSnapshotSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RestoreSnapshotSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// RestoreSnapshotSlotPreparer prepares the RestoreSnapshotSlot request.
func (client AppsClient) RestoreSnapshotSlotPreparer(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot", pathParameters),
		autorest.WithJSON(restoreRequest),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RestoreSnapshotSlotSender sends the RestoreSnapshotSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RestoreSnapshotSlotSender(req *http.Request) (future AppsRestoreSnapshotSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// RestoreSnapshotSlotResponder handles the response to the RestoreSnapshotSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RestoreSnapshotSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RunTriggeredWebJob run a triggered web job for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) RunTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RunTriggeredWebJob")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RunTriggeredWebJob", err.Error())
	}

	req, err := client.RunTriggeredWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RunTriggeredWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.RunTriggeredWebJobSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RunTriggeredWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.RunTriggeredWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RunTriggeredWebJob", resp, "Failure responding to request")
	}

	return
}

// RunTriggeredWebJobPreparer prepares the RunTriggeredWebJob request.
func (client AppsClient) RunTriggeredWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RunTriggeredWebJobSender sends the RunTriggeredWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RunTriggeredWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// RunTriggeredWebJobResponder handles the response to the RunTriggeredWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) RunTriggeredWebJobResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RunTriggeredWebJobSlot run a triggered web job for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) RunTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.RunTriggeredWebJobSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "RunTriggeredWebJobSlot", err.Error())
	}

	req, err := client.RunTriggeredWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RunTriggeredWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.RunTriggeredWebJobSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RunTriggeredWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.RunTriggeredWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "RunTriggeredWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// RunTriggeredWebJobSlotPreparer prepares the RunTriggeredWebJobSlot request.
func (client AppsClient) RunTriggeredWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// RunTriggeredWebJobSlotSender sends the RunTriggeredWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) RunTriggeredWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// RunTriggeredWebJobSlotResponder handles the response to the RunTriggeredWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) RunTriggeredWebJobSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Start starts an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) Start(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Start")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Start", err.Error())
	}

	req, err := client.StartPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Start", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Start", resp, "Failure sending request")
		return
	}

	result, err = client.StartResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Start", resp, "Failure responding to request")
	}

	return
}

// StartPreparer prepares the Start request.
func (client AppsClient) StartPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartSender sends the Start request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StartResponder handles the response to the Start request. The method always
// closes the http.Response Body.
func (client AppsClient) StartResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartContinuousWebJob start a continuous web job for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) StartContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartContinuousWebJob")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartContinuousWebJob", err.Error())
	}

	req, err := client.StartContinuousWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartContinuousWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartContinuousWebJobSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartContinuousWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.StartContinuousWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartContinuousWebJob", resp, "Failure responding to request")
	}

	return
}

// StartContinuousWebJobPreparer prepares the StartContinuousWebJob request.
func (client AppsClient) StartContinuousWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartContinuousWebJobSender sends the StartContinuousWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartContinuousWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StartContinuousWebJobResponder handles the response to the StartContinuousWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) StartContinuousWebJobResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartContinuousWebJobSlot start a continuous web job for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) StartContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartContinuousWebJobSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartContinuousWebJobSlot", err.Error())
	}

	req, err := client.StartContinuousWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartContinuousWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartContinuousWebJobSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartContinuousWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StartContinuousWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartContinuousWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// StartContinuousWebJobSlotPreparer prepares the StartContinuousWebJobSlot request.
func (client AppsClient) StartContinuousWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartContinuousWebJobSlotSender sends the StartContinuousWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartContinuousWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StartContinuousWebJobSlotResponder handles the response to the StartContinuousWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StartContinuousWebJobSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartNetworkTrace start capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// durationInSeconds - the duration to keep capturing in seconds.
// maxFrameLength - the maximum frame length in bytes (Optional).
// sasURL - the Blob URL to store capture file.
func (client AppsClient) StartNetworkTrace(ctx context.Context, resourceGroupName string, name string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (result AppsStartNetworkTraceFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartNetworkTrace")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartNetworkTrace", err.Error())
	}

	req, err := client.StartNetworkTracePreparer(ctx, resourceGroupName, name, durationInSeconds, maxFrameLength, sasURL)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartNetworkTrace", nil, "Failure preparing request")
		return
	}

	result, err = client.StartNetworkTraceSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartNetworkTrace", result.Response(), "Failure sending request")
		return
	}

	return
}

// StartNetworkTracePreparer prepares the StartNetworkTrace request.
func (client AppsClient) StartNetworkTracePreparer(ctx context.Context, resourceGroupName string, name string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if durationInSeconds != nil {
		queryParameters["durationInSeconds"] = autorest.Encode("query", *durationInSeconds)
	}
	if maxFrameLength != nil {
		queryParameters["maxFrameLength"] = autorest.Encode("query", *maxFrameLength)
	}
	if len(sasURL) > 0 {
		queryParameters["sasUrl"] = autorest.Encode("query", sasURL)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartNetworkTraceSender sends the StartNetworkTrace request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartNetworkTraceSender(req *http.Request) (future AppsStartNetworkTraceFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// StartNetworkTraceResponder handles the response to the StartNetworkTrace request. The method always
// closes the http.Response Body.
func (client AppsClient) StartNetworkTraceResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartNetworkTraceSlot start capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for this web app.
// durationInSeconds - the duration to keep capturing in seconds.
// maxFrameLength - the maximum frame length in bytes (Optional).
// sasURL - the Blob URL to store capture file.
func (client AppsClient) StartNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (result AppsStartNetworkTraceSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartNetworkTraceSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartNetworkTraceSlot", err.Error())
	}

	req, err := client.StartNetworkTraceSlotPreparer(ctx, resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasURL)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartNetworkTraceSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.StartNetworkTraceSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartNetworkTraceSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// StartNetworkTraceSlotPreparer prepares the StartNetworkTraceSlot request.
func (client AppsClient) StartNetworkTraceSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if durationInSeconds != nil {
		queryParameters["durationInSeconds"] = autorest.Encode("query", *durationInSeconds)
	}
	if maxFrameLength != nil {
		queryParameters["maxFrameLength"] = autorest.Encode("query", *maxFrameLength)
	}
	if len(sasURL) > 0 {
		queryParameters["sasUrl"] = autorest.Encode("query", sasURL)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartNetworkTraceSlotSender sends the StartNetworkTraceSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartNetworkTraceSlotSender(req *http.Request) (future AppsStartNetworkTraceSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// StartNetworkTraceSlotResponder handles the response to the StartNetworkTraceSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StartNetworkTraceSlotResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartSlot starts an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will start the production slot.
func (client AppsClient) StartSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartSlot", err.Error())
	}

	req, err := client.StartSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StartSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartSlot", resp, "Failure responding to request")
	}

	return
}

// StartSlotPreparer prepares the StartSlot request.
func (client AppsClient) StartSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartSlotSender sends the StartSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StartSlotResponder handles the response to the StartSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StartSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StartWebSiteNetworkTrace start capturing network packets for the site (To be deprecated).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// durationInSeconds - the duration to keep capturing in seconds.
// maxFrameLength - the maximum frame length in bytes (Optional).
// sasURL - the Blob URL to store capture file.
func (client AppsClient) StartWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartWebSiteNetworkTrace")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartWebSiteNetworkTrace", err.Error())
	}

	req, err := client.StartWebSiteNetworkTracePreparer(ctx, resourceGroupName, name, durationInSeconds, maxFrameLength, sasURL)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTrace", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartWebSiteNetworkTraceSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTrace", resp, "Failure sending request")
		return
	}

	result, err = client.StartWebSiteNetworkTraceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTrace", resp, "Failure responding to request")
	}

	return
}

// StartWebSiteNetworkTracePreparer prepares the StartWebSiteNetworkTrace request.
func (client AppsClient) StartWebSiteNetworkTracePreparer(ctx context.Context, resourceGroupName string, name string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if durationInSeconds != nil {
		queryParameters["durationInSeconds"] = autorest.Encode("query", *durationInSeconds)
	}
	if maxFrameLength != nil {
		queryParameters["maxFrameLength"] = autorest.Encode("query", *maxFrameLength)
	}
	if len(sasURL) > 0 {
		queryParameters["sasUrl"] = autorest.Encode("query", sasURL)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartWebSiteNetworkTraceSender sends the StartWebSiteNetworkTrace request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartWebSiteNetworkTraceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StartWebSiteNetworkTraceResponder handles the response to the StartWebSiteNetworkTrace request. The method always
// closes the http.Response Body.
func (client AppsClient) StartWebSiteNetworkTraceResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartWebSiteNetworkTraceOperation start capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// durationInSeconds - the duration to keep capturing in seconds.
// maxFrameLength - the maximum frame length in bytes (Optional).
// sasURL - the Blob URL to store capture file.
func (client AppsClient) StartWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (result AppsStartWebSiteNetworkTraceOperationFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartWebSiteNetworkTraceOperation")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartWebSiteNetworkTraceOperation", err.Error())
	}

	req, err := client.StartWebSiteNetworkTraceOperationPreparer(ctx, resourceGroupName, name, durationInSeconds, maxFrameLength, sasURL)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceOperation", nil, "Failure preparing request")
		return
	}

	result, err = client.StartWebSiteNetworkTraceOperationSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceOperation", result.Response(), "Failure sending request")
		return
	}

	return
}

// StartWebSiteNetworkTraceOperationPreparer prepares the StartWebSiteNetworkTraceOperation request.
func (client AppsClient) StartWebSiteNetworkTraceOperationPreparer(ctx context.Context, resourceGroupName string, name string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if durationInSeconds != nil {
		queryParameters["durationInSeconds"] = autorest.Encode("query", *durationInSeconds)
	}
	if maxFrameLength != nil {
		queryParameters["maxFrameLength"] = autorest.Encode("query", *maxFrameLength)
	}
	if len(sasURL) > 0 {
		queryParameters["sasUrl"] = autorest.Encode("query", sasURL)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartWebSiteNetworkTraceOperationSender sends the StartWebSiteNetworkTraceOperation request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartWebSiteNetworkTraceOperationSender(req *http.Request) (future AppsStartWebSiteNetworkTraceOperationFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// StartWebSiteNetworkTraceOperationResponder handles the response to the StartWebSiteNetworkTraceOperation request. The method always
// closes the http.Response Body.
func (client AppsClient) StartWebSiteNetworkTraceOperationResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartWebSiteNetworkTraceOperationSlot start capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for this web app.
// durationInSeconds - the duration to keep capturing in seconds.
// maxFrameLength - the maximum frame length in bytes (Optional).
// sasURL - the Blob URL to store capture file.
func (client AppsClient) StartWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (result AppsStartWebSiteNetworkTraceOperationSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartWebSiteNetworkTraceOperationSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartWebSiteNetworkTraceOperationSlot", err.Error())
	}

	req, err := client.StartWebSiteNetworkTraceOperationSlotPreparer(ctx, resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasURL)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceOperationSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.StartWebSiteNetworkTraceOperationSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceOperationSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// StartWebSiteNetworkTraceOperationSlotPreparer prepares the StartWebSiteNetworkTraceOperationSlot request.
func (client AppsClient) StartWebSiteNetworkTraceOperationSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if durationInSeconds != nil {
		queryParameters["durationInSeconds"] = autorest.Encode("query", *durationInSeconds)
	}
	if maxFrameLength != nil {
		queryParameters["maxFrameLength"] = autorest.Encode("query", *maxFrameLength)
	}
	if len(sasURL) > 0 {
		queryParameters["sasUrl"] = autorest.Encode("query", sasURL)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartWebSiteNetworkTraceOperationSlotSender sends the StartWebSiteNetworkTraceOperationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartWebSiteNetworkTraceOperationSlotSender(req *http.Request) (future AppsStartWebSiteNetworkTraceOperationSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// StartWebSiteNetworkTraceOperationSlotResponder handles the response to the StartWebSiteNetworkTraceOperationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StartWebSiteNetworkTraceOperationSlotResponder(resp *http.Response) (result ListNetworkTrace, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// StartWebSiteNetworkTraceSlot start capturing network packets for the site (To be deprecated).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for this web app.
// durationInSeconds - the duration to keep capturing in seconds.
// maxFrameLength - the maximum frame length in bytes (Optional).
// sasURL - the Blob URL to store capture file.
func (client AppsClient) StartWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (result String, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StartWebSiteNetworkTraceSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StartWebSiteNetworkTraceSlot", err.Error())
	}

	req, err := client.StartWebSiteNetworkTraceSlotPreparer(ctx, resourceGroupName, name, slot, durationInSeconds, maxFrameLength, sasURL)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StartWebSiteNetworkTraceSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StartWebSiteNetworkTraceSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StartWebSiteNetworkTraceSlot", resp, "Failure responding to request")
	}

	return
}

// StartWebSiteNetworkTraceSlotPreparer prepares the StartWebSiteNetworkTraceSlot request.
func (client AppsClient) StartWebSiteNetworkTraceSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string, durationInSeconds *int32, maxFrameLength *int32, sasURL string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if durationInSeconds != nil {
		queryParameters["durationInSeconds"] = autorest.Encode("query", *durationInSeconds)
	}
	if maxFrameLength != nil {
		queryParameters["maxFrameLength"] = autorest.Encode("query", *maxFrameLength)
	}
	if len(sasURL) > 0 {
		queryParameters["sasUrl"] = autorest.Encode("query", sasURL)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StartWebSiteNetworkTraceSlotSender sends the StartWebSiteNetworkTraceSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StartWebSiteNetworkTraceSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StartWebSiteNetworkTraceSlotResponder handles the response to the StartWebSiteNetworkTraceSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StartWebSiteNetworkTraceSlotResponder(resp *http.Response) (result String, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Stop stops an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) Stop(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Stop")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Stop", err.Error())
	}

	req, err := client.StopPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Stop", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Stop", resp, "Failure sending request")
		return
	}

	result, err = client.StopResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Stop", resp, "Failure responding to request")
	}

	return
}

// StopPreparer prepares the Stop request.
func (client AppsClient) StopPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopSender sends the Stop request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopResponder handles the response to the Stop request. The method always
// closes the http.Response Body.
func (client AppsClient) StopResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopContinuousWebJob stop a continuous web job for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
func (client AppsClient) StopContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopContinuousWebJob")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopContinuousWebJob", err.Error())
	}

	req, err := client.StopContinuousWebJobPreparer(ctx, resourceGroupName, name, webJobName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopContinuousWebJob", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopContinuousWebJobSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopContinuousWebJob", resp, "Failure sending request")
		return
	}

	result, err = client.StopContinuousWebJobResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopContinuousWebJob", resp, "Failure responding to request")
	}

	return
}

// StopContinuousWebJobPreparer prepares the StopContinuousWebJob request.
func (client AppsClient) StopContinuousWebJobPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopContinuousWebJobSender sends the StopContinuousWebJob request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopContinuousWebJobSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopContinuousWebJobResponder handles the response to the StopContinuousWebJob request. The method always
// closes the http.Response Body.
func (client AppsClient) StopContinuousWebJobResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopContinuousWebJobSlot stop a continuous web job for an app, or a deployment slot.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - site name.
// webJobName - name of Web Job.
// slot - name of the deployment slot. If a slot is not specified, the API deletes a deployment for the
// production slot.
func (client AppsClient) StopContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopContinuousWebJobSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopContinuousWebJobSlot", err.Error())
	}

	req, err := client.StopContinuousWebJobSlotPreparer(ctx, resourceGroupName, name, webJobName, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopContinuousWebJobSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopContinuousWebJobSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopContinuousWebJobSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StopContinuousWebJobSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopContinuousWebJobSlot", resp, "Failure responding to request")
	}

	return
}

// StopContinuousWebJobSlotPreparer prepares the StopContinuousWebJobSlot request.
func (client AppsClient) StopContinuousWebJobSlotPreparer(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"webJobName":        autorest.Encode("path", webJobName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopContinuousWebJobSlotSender sends the StopContinuousWebJobSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopContinuousWebJobSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopContinuousWebJobSlotResponder handles the response to the StopContinuousWebJobSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StopContinuousWebJobSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNotFound),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopNetworkTrace stop ongoing capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
func (client AppsClient) StopNetworkTrace(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopNetworkTrace")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopNetworkTrace", err.Error())
	}

	req, err := client.StopNetworkTracePreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopNetworkTrace", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopNetworkTraceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopNetworkTrace", resp, "Failure sending request")
		return
	}

	result, err = client.StopNetworkTraceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopNetworkTrace", resp, "Failure responding to request")
	}

	return
}

// StopNetworkTracePreparer prepares the StopNetworkTrace request.
func (client AppsClient) StopNetworkTracePreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopNetworkTraceSender sends the StopNetworkTrace request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopNetworkTraceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopNetworkTraceResponder handles the response to the StopNetworkTrace request. The method always
// closes the http.Response Body.
func (client AppsClient) StopNetworkTraceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopNetworkTraceSlot stop ongoing capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for this web app.
func (client AppsClient) StopNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopNetworkTraceSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopNetworkTraceSlot", err.Error())
	}

	req, err := client.StopNetworkTraceSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopNetworkTraceSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopNetworkTraceSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopNetworkTraceSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StopNetworkTraceSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopNetworkTraceSlot", resp, "Failure responding to request")
	}

	return
}

// StopNetworkTraceSlotPreparer prepares the StopNetworkTraceSlot request.
func (client AppsClient) StopNetworkTraceSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopNetworkTraceSlotSender sends the StopNetworkTraceSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopNetworkTraceSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopNetworkTraceSlotResponder handles the response to the StopNetworkTraceSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StopNetworkTraceSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopSlot stops an app (or deployment slot, if specified).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will stop the production slot.
func (client AppsClient) StopSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopSlot", err.Error())
	}

	req, err := client.StopSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StopSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopSlot", resp, "Failure responding to request")
	}

	return
}

// StopSlotPreparer prepares the StopSlot request.
func (client AppsClient) StopSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopSlotSender sends the StopSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopSlotResponder handles the response to the StopSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StopSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopWebSiteNetworkTrace stop ongoing capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
func (client AppsClient) StopWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopWebSiteNetworkTrace")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopWebSiteNetworkTrace", err.Error())
	}

	req, err := client.StopWebSiteNetworkTracePreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopWebSiteNetworkTrace", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopWebSiteNetworkTraceSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopWebSiteNetworkTrace", resp, "Failure sending request")
		return
	}

	result, err = client.StopWebSiteNetworkTraceResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopWebSiteNetworkTrace", resp, "Failure responding to request")
	}

	return
}

// StopWebSiteNetworkTracePreparer prepares the StopWebSiteNetworkTrace request.
func (client AppsClient) StopWebSiteNetworkTracePreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopWebSiteNetworkTraceSender sends the StopWebSiteNetworkTrace request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopWebSiteNetworkTraceSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopWebSiteNetworkTraceResponder handles the response to the StopWebSiteNetworkTrace request. The method always
// closes the http.Response Body.
func (client AppsClient) StopWebSiteNetworkTraceResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// StopWebSiteNetworkTraceSlot stop ongoing capturing network packets for the site.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// slot - the name of the slot for this web app.
func (client AppsClient) StopWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.StopWebSiteNetworkTraceSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "StopWebSiteNetworkTraceSlot", err.Error())
	}

	req, err := client.StopWebSiteNetworkTraceSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopWebSiteNetworkTraceSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.StopWebSiteNetworkTraceSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopWebSiteNetworkTraceSlot", resp, "Failure sending request")
		return
	}

	result, err = client.StopWebSiteNetworkTraceSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "StopWebSiteNetworkTraceSlot", resp, "Failure responding to request")
	}

	return
}

// StopWebSiteNetworkTraceSlotPreparer prepares the StopWebSiteNetworkTraceSlot request.
func (client AppsClient) StopWebSiteNetworkTraceSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// StopWebSiteNetworkTraceSlotSender sends the StopWebSiteNetworkTraceSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) StopWebSiteNetworkTraceSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// StopWebSiteNetworkTraceSlotResponder handles the response to the StopWebSiteNetworkTraceSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) StopWebSiteNetworkTraceSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SwapSlotSlot swaps two deployment slots of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
// slot - name of the source slot. If a slot is not specified, the production slot is used as the source slot.
func (client AppsClient) SwapSlotSlot(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (result AppsSwapSlotSlotFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.SwapSlotSlot")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: slotSwapEntity,
			Constraints: []validation.Constraint{{Target: "slotSwapEntity.TargetSlot", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "slotSwapEntity.PreserveVnet", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "SwapSlotSlot", err.Error())
	}

	req, err := client.SwapSlotSlotPreparer(ctx, resourceGroupName, name, slotSwapEntity, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SwapSlotSlot", nil, "Failure preparing request")
		return
	}

	result, err = client.SwapSlotSlotSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SwapSlotSlot", result.Response(), "Failure sending request")
		return
	}

	return
}

// SwapSlotSlotPreparer prepares the SwapSlotSlot request.
func (client AppsClient) SwapSlotSlotPreparer(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap", pathParameters),
		autorest.WithJSON(slotSwapEntity),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SwapSlotSlotSender sends the SwapSlotSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) SwapSlotSlotSender(req *http.Request) (future AppsSwapSlotSlotFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// SwapSlotSlotResponder handles the response to the SwapSlotSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) SwapSlotSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SwapSlotWithProduction swaps two deployment slots of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotSwapEntity - JSON object that contains the target slot name. See example.
func (client AppsClient) SwapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (result AppsSwapSlotWithProductionFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.SwapSlotWithProduction")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: slotSwapEntity,
			Constraints: []validation.Constraint{{Target: "slotSwapEntity.TargetSlot", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "slotSwapEntity.PreserveVnet", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "SwapSlotWithProduction", err.Error())
	}

	req, err := client.SwapSlotWithProductionPreparer(ctx, resourceGroupName, name, slotSwapEntity)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SwapSlotWithProduction", nil, "Failure preparing request")
		return
	}

	result, err = client.SwapSlotWithProductionSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SwapSlotWithProduction", result.Response(), "Failure sending request")
		return
	}

	return
}

// SwapSlotWithProductionPreparer prepares the SwapSlotWithProduction request.
func (client AppsClient) SwapSlotWithProductionPreparer(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap", pathParameters),
		autorest.WithJSON(slotSwapEntity),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SwapSlotWithProductionSender sends the SwapSlotWithProduction request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) SwapSlotWithProductionSender(req *http.Request) (future AppsSwapSlotWithProductionFuture, err error) {
	var resp *http.Response
	resp, err = autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// SwapSlotWithProductionResponder handles the response to the SwapSlotWithProduction request. The method always
// closes the http.Response Body.
func (client AppsClient) SwapSlotWithProductionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SyncFunctionTriggers syncs function trigger metadata to the scale controller
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
func (client AppsClient) SyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.SyncFunctionTriggers")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "SyncFunctionTriggers", err.Error())
	}

	req, err := client.SyncFunctionTriggersPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncFunctionTriggers", nil, "Failure preparing request")
		return
	}

	resp, err := client.SyncFunctionTriggersSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncFunctionTriggers", resp, "Failure sending request")
		return
	}

	result, err = client.SyncFunctionTriggersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncFunctionTriggers", resp, "Failure responding to request")
	}

	return
}

// SyncFunctionTriggersPreparer prepares the SyncFunctionTriggers request.
func (client AppsClient) SyncFunctionTriggersPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SyncFunctionTriggersSender sends the SyncFunctionTriggers request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) SyncFunctionTriggersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// SyncFunctionTriggersResponder handles the response to the SyncFunctionTriggers request. The method always
// closes the http.Response Body.
func (client AppsClient) SyncFunctionTriggersResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SyncFunctionTriggersSlot syncs function trigger metadata to the scale controller
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will restore a backup of the
// production slot.
func (client AppsClient) SyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.SyncFunctionTriggersSlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "SyncFunctionTriggersSlot", err.Error())
	}

	req, err := client.SyncFunctionTriggersSlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncFunctionTriggersSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.SyncFunctionTriggersSlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncFunctionTriggersSlot", resp, "Failure sending request")
		return
	}

	result, err = client.SyncFunctionTriggersSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncFunctionTriggersSlot", resp, "Failure responding to request")
	}

	return
}

// SyncFunctionTriggersSlotPreparer prepares the SyncFunctionTriggersSlot request.
func (client AppsClient) SyncFunctionTriggersSlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SyncFunctionTriggersSlotSender sends the SyncFunctionTriggersSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) SyncFunctionTriggersSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// SyncFunctionTriggersSlotResponder handles the response to the SyncFunctionTriggersSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) SyncFunctionTriggersSlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SyncRepository sync web app repository.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
func (client AppsClient) SyncRepository(ctx context.Context, resourceGroupName string, name string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.SyncRepository")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "SyncRepository", err.Error())
	}

	req, err := client.SyncRepositoryPreparer(ctx, resourceGroupName, name)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncRepository", nil, "Failure preparing request")
		return
	}

	resp, err := client.SyncRepositorySender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncRepository", resp, "Failure sending request")
		return
	}

	result, err = client.SyncRepositoryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncRepository", resp, "Failure responding to request")
	}

	return
}

// SyncRepositoryPreparer prepares the SyncRepository request.
func (client AppsClient) SyncRepositoryPreparer(ctx context.Context, resourceGroupName string, name string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SyncRepositorySender sends the SyncRepository request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) SyncRepositorySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// SyncRepositoryResponder handles the response to the SyncRepository request. The method always
// closes the http.Response Body.
func (client AppsClient) SyncRepositoryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SyncRepositorySlot sync web app repository.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) SyncRepositorySlot(ctx context.Context, resourceGroupName string, name string, slot string) (result autorest.Response, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.SyncRepositorySlot")
		defer func() {
			sc := -1
			if result.Response != nil {
				sc = result.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "SyncRepositorySlot", err.Error())
	}

	req, err := client.SyncRepositorySlotPreparer(ctx, resourceGroupName, name, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncRepositorySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.SyncRepositorySlotSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncRepositorySlot", resp, "Failure sending request")
		return
	}

	result, err = client.SyncRepositorySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "SyncRepositorySlot", resp, "Failure responding to request")
	}

	return
}

// SyncRepositorySlotPreparer prepares the SyncRepositorySlot request.
func (client AppsClient) SyncRepositorySlotPreparer(ctx context.Context, resourceGroupName string, name string, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// SyncRepositorySlotSender sends the SyncRepositorySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) SyncRepositorySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// SyncRepositorySlotResponder handles the response to the SyncRepositorySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) SyncRepositorySlotResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Update creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - unique name of the app to create or update. To create or update a deployment slot, use the {slot}
// parameter.
// siteEnvelope - a JSON representation of the app properties. See example.
func (client AppsClient) Update(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource) (result Site, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.Update")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "Update", err.Error())
	}

	req, err := client.UpdatePreparer(ctx, resourceGroupName, name, siteEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Update", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Update", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "Update", resp, "Failure responding to request")
	}

	return
}

// UpdatePreparer prepares the Update request.
func (client AppsClient) UpdatePreparer(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}", pathParameters),
		autorest.WithJSON(siteEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSender sends the Update request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateResponder handles the response to the Update request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateResponder(resp *http.Response) (result Site, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateApplicationSettings replaces the application settings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// appSettings - application settings of the app.
func (client AppsClient) UpdateApplicationSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateApplicationSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateApplicationSettings", err.Error())
	}

	req, err := client.UpdateApplicationSettingsPreparer(ctx, resourceGroupName, name, appSettings)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateApplicationSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateApplicationSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateApplicationSettings", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateApplicationSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateApplicationSettings", resp, "Failure responding to request")
	}

	return
}

// UpdateApplicationSettingsPreparer prepares the UpdateApplicationSettings request.
func (client AppsClient) UpdateApplicationSettingsPreparer(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings", pathParameters),
		autorest.WithJSON(appSettings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateApplicationSettingsSender sends the UpdateApplicationSettings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateApplicationSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateApplicationSettingsResponder handles the response to the UpdateApplicationSettings request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateApplicationSettingsResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateApplicationSettingsSlot replaces the application settings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// appSettings - application settings of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will update the application settings
// for the production slot.
func (client AppsClient) UpdateApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, slot string) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateApplicationSettingsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateApplicationSettingsSlot", err.Error())
	}

	req, err := client.UpdateApplicationSettingsSlotPreparer(ctx, resourceGroupName, name, appSettings, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateApplicationSettingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateApplicationSettingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateApplicationSettingsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateApplicationSettingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateApplicationSettingsSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateApplicationSettingsSlotPreparer prepares the UpdateApplicationSettingsSlot request.
func (client AppsClient) UpdateApplicationSettingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings", pathParameters),
		autorest.WithJSON(appSettings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateApplicationSettingsSlotSender sends the UpdateApplicationSettingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateApplicationSettingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateApplicationSettingsSlotResponder handles the response to the UpdateApplicationSettingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateApplicationSettingsSlotResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateAuthSettings updates the Authentication / Authorization settings associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// siteAuthSettings - auth settings associated with web app.
func (client AppsClient) UpdateAuthSettings(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings) (result SiteAuthSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateAuthSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateAuthSettings", err.Error())
	}

	req, err := client.UpdateAuthSettingsPreparer(ctx, resourceGroupName, name, siteAuthSettings)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAuthSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateAuthSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAuthSettings", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateAuthSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAuthSettings", resp, "Failure responding to request")
	}

	return
}

// UpdateAuthSettingsPreparer prepares the UpdateAuthSettings request.
func (client AppsClient) UpdateAuthSettingsPreparer(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings", pathParameters),
		autorest.WithJSON(siteAuthSettings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateAuthSettingsSender sends the UpdateAuthSettings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateAuthSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateAuthSettingsResponder handles the response to the UpdateAuthSettings request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateAuthSettingsResponder(resp *http.Response) (result SiteAuthSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateAuthSettingsSlot updates the Authentication / Authorization settings associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// siteAuthSettings - auth settings associated with web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) UpdateAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, slot string) (result SiteAuthSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateAuthSettingsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateAuthSettingsSlot", err.Error())
	}

	req, err := client.UpdateAuthSettingsSlotPreparer(ctx, resourceGroupName, name, siteAuthSettings, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAuthSettingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateAuthSettingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAuthSettingsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateAuthSettingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAuthSettingsSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateAuthSettingsSlotPreparer prepares the UpdateAuthSettingsSlot request.
func (client AppsClient) UpdateAuthSettingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings", pathParameters),
		autorest.WithJSON(siteAuthSettings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateAuthSettingsSlotSender sends the UpdateAuthSettingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateAuthSettingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateAuthSettingsSlotResponder handles the response to the UpdateAuthSettingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateAuthSettingsSlotResponder(resp *http.Response) (result SiteAuthSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateAzureStorageAccounts updates the Azure storage account configurations of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// azureStorageAccounts - azure storage accounts of the app.
func (client AppsClient) UpdateAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource) (result AzureStoragePropertyDictionaryResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateAzureStorageAccounts")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateAzureStorageAccounts", err.Error())
	}

	req, err := client.UpdateAzureStorageAccountsPreparer(ctx, resourceGroupName, name, azureStorageAccounts)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAzureStorageAccounts", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateAzureStorageAccountsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAzureStorageAccounts", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateAzureStorageAccountsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAzureStorageAccounts", resp, "Failure responding to request")
	}

	return
}

// UpdateAzureStorageAccountsPreparer prepares the UpdateAzureStorageAccounts request.
func (client AppsClient) UpdateAzureStorageAccountsPreparer(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts", pathParameters),
		autorest.WithJSON(azureStorageAccounts),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateAzureStorageAccountsSender sends the UpdateAzureStorageAccounts request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateAzureStorageAccountsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateAzureStorageAccountsResponder handles the response to the UpdateAzureStorageAccounts request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateAzureStorageAccountsResponder(resp *http.Response) (result AzureStoragePropertyDictionaryResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateAzureStorageAccountsSlot updates the Azure storage account configurations of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// azureStorageAccounts - azure storage accounts of the app.
// slot - name of the deployment slot. If a slot is not specified, the API will update the Azure storage
// account configurations for the production slot.
func (client AppsClient) UpdateAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, slot string) (result AzureStoragePropertyDictionaryResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateAzureStorageAccountsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateAzureStorageAccountsSlot", err.Error())
	}

	req, err := client.UpdateAzureStorageAccountsSlotPreparer(ctx, resourceGroupName, name, azureStorageAccounts, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAzureStorageAccountsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateAzureStorageAccountsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAzureStorageAccountsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateAzureStorageAccountsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateAzureStorageAccountsSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateAzureStorageAccountsSlotPreparer prepares the UpdateAzureStorageAccountsSlot request.
func (client AppsClient) UpdateAzureStorageAccountsSlotPreparer(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts", pathParameters),
		autorest.WithJSON(azureStorageAccounts),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateAzureStorageAccountsSlotSender sends the UpdateAzureStorageAccountsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateAzureStorageAccountsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateAzureStorageAccountsSlotResponder handles the response to the UpdateAzureStorageAccountsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateAzureStorageAccountsSlotResponder(resp *http.Response) (result AzureStoragePropertyDictionaryResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateBackupConfiguration updates the backup configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - edited backup configuration.
func (client AppsClient) UpdateBackupConfiguration(ctx context.Context, resourceGroupName string, name string, request BackupRequest) (result BackupRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateBackupConfiguration")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.BackupRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.BackupRequestProperties.BackupSchedule", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.BackupSchedule.FrequencyInterval", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.KeepAtLeastOneBackup", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.RetentionPeriodInDays", Name: validation.Null, Rule: true, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateBackupConfiguration", err.Error())
	}

	req, err := client.UpdateBackupConfigurationPreparer(ctx, resourceGroupName, name, request)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateBackupConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateBackupConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateBackupConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateBackupConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateBackupConfiguration", resp, "Failure responding to request")
	}

	return
}

// UpdateBackupConfigurationPreparer prepares the UpdateBackupConfiguration request.
func (client AppsClient) UpdateBackupConfigurationPreparer(ctx context.Context, resourceGroupName string, name string, request BackupRequest) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateBackupConfigurationSender sends the UpdateBackupConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateBackupConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateBackupConfigurationResponder handles the response to the UpdateBackupConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateBackupConfigurationResponder(resp *http.Response) (result BackupRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateBackupConfigurationSlot updates the backup configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// request - edited backup configuration.
// slot - name of the deployment slot. If a slot is not specified, the API will update the backup configuration
// for the production slot.
func (client AppsClient) UpdateBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, request BackupRequest, slot string) (result BackupRequest, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateBackupConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: request,
			Constraints: []validation.Constraint{{Target: "request.BackupRequestProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.StorageAccountURL", Name: validation.Null, Rule: true, Chain: nil},
					{Target: "request.BackupRequestProperties.BackupSchedule", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "request.BackupRequestProperties.BackupSchedule.FrequencyInterval", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.KeepAtLeastOneBackup", Name: validation.Null, Rule: true, Chain: nil},
							{Target: "request.BackupRequestProperties.BackupSchedule.RetentionPeriodInDays", Name: validation.Null, Rule: true, Chain: nil},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateBackupConfigurationSlot", err.Error())
	}

	req, err := client.UpdateBackupConfigurationSlotPreparer(ctx, resourceGroupName, name, request, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateBackupConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateBackupConfigurationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateBackupConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateBackupConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateBackupConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateBackupConfigurationSlotPreparer prepares the UpdateBackupConfigurationSlot request.
func (client AppsClient) UpdateBackupConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, request BackupRequest, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup", pathParameters),
		autorest.WithJSON(request),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateBackupConfigurationSlotSender sends the UpdateBackupConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateBackupConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateBackupConfigurationSlotResponder handles the response to the UpdateBackupConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateBackupConfigurationSlotResponder(resp *http.Response) (result BackupRequest, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateConfiguration updates the configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteConfig - JSON representation of a SiteConfig object. See example.
func (client AppsClient) UpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateConfiguration")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateConfiguration", err.Error())
	}

	req, err := client.UpdateConfigurationPreparer(ctx, resourceGroupName, name, siteConfig)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConfiguration", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateConfigurationSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConfiguration", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateConfigurationResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConfiguration", resp, "Failure responding to request")
	}

	return
}

// UpdateConfigurationPreparer prepares the UpdateConfiguration request.
func (client AppsClient) UpdateConfigurationPreparer(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web", pathParameters),
		autorest.WithJSON(siteConfig),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateConfigurationSender sends the UpdateConfiguration request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateConfigurationSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateConfigurationResponder handles the response to the UpdateConfiguration request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateConfigurationResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateConfigurationSlot updates the configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteConfig - JSON representation of a SiteConfig object. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will update configuration for the
// production slot.
func (client AppsClient) UpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, slot string) (result SiteConfigResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateConfigurationSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateConfigurationSlot", err.Error())
	}

	req, err := client.UpdateConfigurationSlotPreparer(ctx, resourceGroupName, name, siteConfig, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConfigurationSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateConfigurationSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConfigurationSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateConfigurationSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConfigurationSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateConfigurationSlotPreparer prepares the UpdateConfigurationSlot request.
func (client AppsClient) UpdateConfigurationSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web", pathParameters),
		autorest.WithJSON(siteConfig),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateConfigurationSlotSender sends the UpdateConfigurationSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateConfigurationSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateConfigurationSlotResponder handles the response to the UpdateConfigurationSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateConfigurationSlotResponder(resp *http.Response) (result SiteConfigResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateConnectionStrings replaces the connection strings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// connectionStrings - connection strings of the app or deployment slot. See example.
func (client AppsClient) UpdateConnectionStrings(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary) (result ConnectionStringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateConnectionStrings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateConnectionStrings", err.Error())
	}

	req, err := client.UpdateConnectionStringsPreparer(ctx, resourceGroupName, name, connectionStrings)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConnectionStrings", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateConnectionStringsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConnectionStrings", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateConnectionStringsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConnectionStrings", resp, "Failure responding to request")
	}

	return
}

// UpdateConnectionStringsPreparer prepares the UpdateConnectionStrings request.
func (client AppsClient) UpdateConnectionStringsPreparer(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings", pathParameters),
		autorest.WithJSON(connectionStrings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateConnectionStringsSender sends the UpdateConnectionStrings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateConnectionStringsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateConnectionStringsResponder handles the response to the UpdateConnectionStrings request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateConnectionStringsResponder(resp *http.Response) (result ConnectionStringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateConnectionStringsSlot replaces the connection strings of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// connectionStrings - connection strings of the app or deployment slot. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will update the connection settings
// for the production slot.
func (client AppsClient) UpdateConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, slot string) (result ConnectionStringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateConnectionStringsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateConnectionStringsSlot", err.Error())
	}

	req, err := client.UpdateConnectionStringsSlotPreparer(ctx, resourceGroupName, name, connectionStrings, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConnectionStringsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateConnectionStringsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConnectionStringsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateConnectionStringsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateConnectionStringsSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateConnectionStringsSlotPreparer prepares the UpdateConnectionStringsSlot request.
func (client AppsClient) UpdateConnectionStringsSlotPreparer(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings", pathParameters),
		autorest.WithJSON(connectionStrings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateConnectionStringsSlotSender sends the UpdateConnectionStringsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateConnectionStringsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateConnectionStringsSlotResponder handles the response to the UpdateConnectionStringsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateConnectionStringsSlotResponder(resp *http.Response) (result ConnectionStringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDiagnosticLogsConfig updates the logging configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteLogsConfig - a SiteLogsConfig JSON object that contains the logging configuration to change in the
// "properties" property.
func (client AppsClient) UpdateDiagnosticLogsConfig(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig) (result SiteLogsConfig, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateDiagnosticLogsConfig")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: siteLogsConfig,
			Constraints: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.ApplicationLogs", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.ApplicationLogs.AzureTableStorage", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.ApplicationLogs.AzureTableStorage.SasURL", Name: validation.Null, Rule: true, Chain: nil}}},
					}},
					{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem.RetentionInMb", Name: validation.Null, Rule: false,
								Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem.RetentionInMb", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
									{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem.RetentionInMb", Name: validation.InclusiveMinimum, Rule: 25, Chain: nil},
								}},
							}},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateDiagnosticLogsConfig", err.Error())
	}

	req, err := client.UpdateDiagnosticLogsConfigPreparer(ctx, resourceGroupName, name, siteLogsConfig)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDiagnosticLogsConfig", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDiagnosticLogsConfigSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDiagnosticLogsConfig", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDiagnosticLogsConfigResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDiagnosticLogsConfig", resp, "Failure responding to request")
	}

	return
}

// UpdateDiagnosticLogsConfigPreparer prepares the UpdateDiagnosticLogsConfig request.
func (client AppsClient) UpdateDiagnosticLogsConfigPreparer(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs", pathParameters),
		autorest.WithJSON(siteLogsConfig),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDiagnosticLogsConfigSender sends the UpdateDiagnosticLogsConfig request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateDiagnosticLogsConfigSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateDiagnosticLogsConfigResponder handles the response to the UpdateDiagnosticLogsConfig request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateDiagnosticLogsConfigResponder(resp *http.Response) (result SiteLogsConfig, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDiagnosticLogsConfigSlot updates the logging configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteLogsConfig - a SiteLogsConfig JSON object that contains the logging configuration to change in the
// "properties" property.
// slot - name of the deployment slot. If a slot is not specified, the API will update the logging
// configuration for the production slot.
func (client AppsClient) UpdateDiagnosticLogsConfigSlot(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, slot string) (result SiteLogsConfig, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateDiagnosticLogsConfigSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: siteLogsConfig,
			Constraints: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.ApplicationLogs", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.ApplicationLogs.AzureTableStorage", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.ApplicationLogs.AzureTableStorage.SasURL", Name: validation.Null, Rule: true, Chain: nil}}},
					}},
					{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs", Name: validation.Null, Rule: false,
						Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem", Name: validation.Null, Rule: false,
							Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem.RetentionInMb", Name: validation.Null, Rule: false,
								Chain: []validation.Constraint{{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem.RetentionInMb", Name: validation.InclusiveMaximum, Rule: int64(100), Chain: nil},
									{Target: "siteLogsConfig.SiteLogsConfigProperties.HTTPLogs.FileSystem.RetentionInMb", Name: validation.InclusiveMinimum, Rule: 25, Chain: nil},
								}},
							}},
						}},
				}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateDiagnosticLogsConfigSlot", err.Error())
	}

	req, err := client.UpdateDiagnosticLogsConfigSlotPreparer(ctx, resourceGroupName, name, siteLogsConfig, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDiagnosticLogsConfigSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDiagnosticLogsConfigSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDiagnosticLogsConfigSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDiagnosticLogsConfigSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDiagnosticLogsConfigSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateDiagnosticLogsConfigSlotPreparer prepares the UpdateDiagnosticLogsConfigSlot request.
func (client AppsClient) UpdateDiagnosticLogsConfigSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs", pathParameters),
		autorest.WithJSON(siteLogsConfig),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDiagnosticLogsConfigSlotSender sends the UpdateDiagnosticLogsConfigSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateDiagnosticLogsConfigSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateDiagnosticLogsConfigSlotResponder handles the response to the UpdateDiagnosticLogsConfigSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateDiagnosticLogsConfigSlotResponder(resp *http.Response) (result SiteLogsConfig, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDomainOwnershipIdentifier creates a domain ownership identifier for web app, or updates an existing ownership
// identifier.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
// domainOwnershipIdentifier - a JSON representation of the domain ownership properties.
func (client AppsClient) UpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier) (result Identifier, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateDomainOwnershipIdentifier")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateDomainOwnershipIdentifier", err.Error())
	}

	req, err := client.UpdateDomainOwnershipIdentifierPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDomainOwnershipIdentifier", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDomainOwnershipIdentifierSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDomainOwnershipIdentifier", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDomainOwnershipIdentifierResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDomainOwnershipIdentifier", resp, "Failure responding to request")
	}

	return
}

// UpdateDomainOwnershipIdentifierPreparer prepares the UpdateDomainOwnershipIdentifier request.
func (client AppsClient) UpdateDomainOwnershipIdentifierPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithJSON(domainOwnershipIdentifier),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDomainOwnershipIdentifierSender sends the UpdateDomainOwnershipIdentifier request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateDomainOwnershipIdentifierSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateDomainOwnershipIdentifierResponder handles the response to the UpdateDomainOwnershipIdentifier request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateDomainOwnershipIdentifierResponder(resp *http.Response) (result Identifier, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDomainOwnershipIdentifierSlot creates a domain ownership identifier for web app, or updates an existing
// ownership identifier.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// domainOwnershipIdentifierName - name of domain ownership identifier.
// domainOwnershipIdentifier - a JSON representation of the domain ownership properties.
// slot - name of the deployment slot. If a slot is not specified, the API will delete the binding for the
// production slot.
func (client AppsClient) UpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, slot string) (result Identifier, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateDomainOwnershipIdentifierSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateDomainOwnershipIdentifierSlot", err.Error())
	}

	req, err := client.UpdateDomainOwnershipIdentifierSlotPreparer(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDomainOwnershipIdentifierSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDomainOwnershipIdentifierSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDomainOwnershipIdentifierSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDomainOwnershipIdentifierSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateDomainOwnershipIdentifierSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateDomainOwnershipIdentifierSlotPreparer prepares the UpdateDomainOwnershipIdentifierSlot request.
func (client AppsClient) UpdateDomainOwnershipIdentifierSlotPreparer(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"domainOwnershipIdentifierName": autorest.Encode("path", domainOwnershipIdentifierName),
		"name":                          autorest.Encode("path", name),
		"resourceGroupName":             autorest.Encode("path", resourceGroupName),
		"slot":                          autorest.Encode("path", slot),
		"subscriptionId":                autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}", pathParameters),
		autorest.WithJSON(domainOwnershipIdentifier),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDomainOwnershipIdentifierSlotSender sends the UpdateDomainOwnershipIdentifierSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateDomainOwnershipIdentifierSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateDomainOwnershipIdentifierSlotResponder handles the response to the UpdateDomainOwnershipIdentifierSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateDomainOwnershipIdentifierSlotResponder(resp *http.Response) (result Identifier, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateHybridConnection creates a new Hybrid Connection using a Service Bus relay.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// connectionEnvelope - the details of the hybrid connection.
func (client AppsClient) UpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateHybridConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateHybridConnection", err.Error())
	}

	req, err := client.UpdateHybridConnectionPreparer(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateHybridConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateHybridConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateHybridConnection", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateHybridConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateHybridConnection", resp, "Failure responding to request")
	}

	return
}

// UpdateHybridConnectionPreparer prepares the UpdateHybridConnection request.
func (client AppsClient) UpdateHybridConnectionPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateHybridConnectionSender sends the UpdateHybridConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateHybridConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateHybridConnectionResponder handles the response to the UpdateHybridConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateHybridConnectionResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateHybridConnectionSlot creates a new Hybrid Connection using a Service Bus relay.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - the name of the web app.
// namespaceName - the namespace for this hybrid connection.
// relayName - the relay name for this hybrid connection.
// connectionEnvelope - the details of the hybrid connection.
// slot - the name of the slot for the web app.
func (client AppsClient) UpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, slot string) (result HybridConnection, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateHybridConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateHybridConnectionSlot", err.Error())
	}

	req, err := client.UpdateHybridConnectionSlotPreparer(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateHybridConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateHybridConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateHybridConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateHybridConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateHybridConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateHybridConnectionSlotPreparer prepares the UpdateHybridConnectionSlot request.
func (client AppsClient) UpdateHybridConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"namespaceName":     autorest.Encode("path", namespaceName),
		"relayName":         autorest.Encode("path", relayName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateHybridConnectionSlotSender sends the UpdateHybridConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateHybridConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateHybridConnectionSlotResponder handles the response to the UpdateHybridConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateHybridConnectionSlotResponder(resp *http.Response) (result HybridConnection, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateMetadata replaces the metadata of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// metadata - edited metadata of the app or deployment slot. See example.
func (client AppsClient) UpdateMetadata(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateMetadata")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateMetadata", err.Error())
	}

	req, err := client.UpdateMetadataPreparer(ctx, resourceGroupName, name, metadata)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateMetadata", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateMetadataSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateMetadata", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateMetadataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateMetadata", resp, "Failure responding to request")
	}

	return
}

// UpdateMetadataPreparer prepares the UpdateMetadata request.
func (client AppsClient) UpdateMetadataPreparer(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata", pathParameters),
		autorest.WithJSON(metadata),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateMetadataSender sends the UpdateMetadata request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateMetadataSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateMetadataResponder handles the response to the UpdateMetadata request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateMetadataResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateMetadataSlot replaces the metadata of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// metadata - edited metadata of the app or deployment slot. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will update the metadata for the
// production slot.
func (client AppsClient) UpdateMetadataSlot(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, slot string) (result StringDictionary, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateMetadataSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateMetadataSlot", err.Error())
	}

	req, err := client.UpdateMetadataSlotPreparer(ctx, resourceGroupName, name, metadata, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateMetadataSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateMetadataSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateMetadataSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateMetadataSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateMetadataSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateMetadataSlotPreparer prepares the UpdateMetadataSlot request.
func (client AppsClient) UpdateMetadataSlotPreparer(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata", pathParameters),
		autorest.WithJSON(metadata),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateMetadataSlotSender sends the UpdateMetadataSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateMetadataSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateMetadataSlotResponder handles the response to the UpdateMetadataSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateMetadataSlotResponder(resp *http.Response) (result StringDictionary, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdatePremierAddOn updates a named add-on of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
// premierAddOn - a JSON representation of the edited premier add-on.
func (client AppsClient) UpdatePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdatePremierAddOn")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdatePremierAddOn", err.Error())
	}

	req, err := client.UpdatePremierAddOnPreparer(ctx, resourceGroupName, name, premierAddOnName, premierAddOn)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdatePremierAddOn", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdatePremierAddOnSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdatePremierAddOn", resp, "Failure sending request")
		return
	}

	result, err = client.UpdatePremierAddOnResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdatePremierAddOn", resp, "Failure responding to request")
	}

	return
}

// UpdatePremierAddOnPreparer prepares the UpdatePremierAddOn request.
func (client AppsClient) UpdatePremierAddOnPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithJSON(premierAddOn),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdatePremierAddOnSender sends the UpdatePremierAddOn request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdatePremierAddOnSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdatePremierAddOnResponder handles the response to the UpdatePremierAddOn request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdatePremierAddOnResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdatePremierAddOnSlot updates a named add-on of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// premierAddOnName - add-on name.
// premierAddOn - a JSON representation of the edited premier add-on.
// slot - name of the deployment slot. If a slot is not specified, the API will update the named add-on for the
// production slot.
func (client AppsClient) UpdatePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, slot string) (result PremierAddOn, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdatePremierAddOnSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdatePremierAddOnSlot", err.Error())
	}

	req, err := client.UpdatePremierAddOnSlotPreparer(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdatePremierAddOnSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdatePremierAddOnSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdatePremierAddOnSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdatePremierAddOnSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdatePremierAddOnSlot", resp, "Failure responding to request")
	}

	return
}

// UpdatePremierAddOnSlotPreparer prepares the UpdatePremierAddOnSlot request.
func (client AppsClient) UpdatePremierAddOnSlotPreparer(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"premierAddOnName":  autorest.Encode("path", premierAddOnName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}", pathParameters),
		autorest.WithJSON(premierAddOn),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdatePremierAddOnSlotSender sends the UpdatePremierAddOnSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdatePremierAddOnSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdatePremierAddOnSlotResponder handles the response to the UpdatePremierAddOnSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdatePremierAddOnSlotResponder(resp *http.Response) (result PremierAddOn, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateRelayServiceConnection creates a new hybrid connection configuration (PUT), or updates an existing one
// (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection configuration.
// connectionEnvelope - details of the hybrid connection configuration.
func (client AppsClient) UpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateRelayServiceConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateRelayServiceConnection", err.Error())
	}

	req, err := client.UpdateRelayServiceConnectionPreparer(ctx, resourceGroupName, name, entityName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateRelayServiceConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRelayServiceConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateRelayServiceConnection", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRelayServiceConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateRelayServiceConnection", resp, "Failure responding to request")
	}

	return
}

// UpdateRelayServiceConnectionPreparer prepares the UpdateRelayServiceConnection request.
func (client AppsClient) UpdateRelayServiceConnectionPreparer(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateRelayServiceConnectionSender sends the UpdateRelayServiceConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateRelayServiceConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateRelayServiceConnectionResponder handles the response to the UpdateRelayServiceConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateRelayServiceConnectionResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateRelayServiceConnectionSlot creates a new hybrid connection configuration (PUT), or updates an existing one
// (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// entityName - name of the hybrid connection configuration.
// connectionEnvelope - details of the hybrid connection configuration.
// slot - name of the deployment slot. If a slot is not specified, the API will create or update a hybrid
// connection for the production slot.
func (client AppsClient) UpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, slot string) (result RelayServiceConnectionEntity, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateRelayServiceConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateRelayServiceConnectionSlot", err.Error())
	}

	req, err := client.UpdateRelayServiceConnectionSlotPreparer(ctx, resourceGroupName, name, entityName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateRelayServiceConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateRelayServiceConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateRelayServiceConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateRelayServiceConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateRelayServiceConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateRelayServiceConnectionSlotPreparer prepares the UpdateRelayServiceConnectionSlot request.
func (client AppsClient) UpdateRelayServiceConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"entityName":        autorest.Encode("path", entityName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateRelayServiceConnectionSlotSender sends the UpdateRelayServiceConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateRelayServiceConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateRelayServiceConnectionSlotResponder handles the response to the UpdateRelayServiceConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateRelayServiceConnectionSlotResponder(resp *http.Response) (result RelayServiceConnectionEntity, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSitePushSettings updates the Push settings associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// pushSettings - push settings associated with web app.
func (client AppsClient) UpdateSitePushSettings(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings) (result PushSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSitePushSettings")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: pushSettings,
			Constraints: []validation.Constraint{{Target: "pushSettings.PushSettingsProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "pushSettings.PushSettingsProperties.IsPushEnabled", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSitePushSettings", err.Error())
	}

	req, err := client.UpdateSitePushSettingsPreparer(ctx, resourceGroupName, name, pushSettings)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSitePushSettings", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSitePushSettingsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSitePushSettings", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSitePushSettingsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSitePushSettings", resp, "Failure responding to request")
	}

	return
}

// UpdateSitePushSettingsPreparer prepares the UpdateSitePushSettings request.
func (client AppsClient) UpdateSitePushSettingsPreparer(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings", pathParameters),
		autorest.WithJSON(pushSettings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSitePushSettingsSender sends the UpdateSitePushSettings request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSitePushSettingsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSitePushSettingsResponder handles the response to the UpdateSitePushSettings request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSitePushSettingsResponder(resp *http.Response) (result PushSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSitePushSettingsSlot updates the Push settings associated with web app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of web app.
// pushSettings - push settings associated with web app.
// slot - name of web app slot. If not specified then will default to production slot.
func (client AppsClient) UpdateSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, slot string) (result PushSettings, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSitePushSettingsSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}},
		{TargetValue: pushSettings,
			Constraints: []validation.Constraint{{Target: "pushSettings.PushSettingsProperties", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "pushSettings.PushSettingsProperties.IsPushEnabled", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSitePushSettingsSlot", err.Error())
	}

	req, err := client.UpdateSitePushSettingsSlotPreparer(ctx, resourceGroupName, name, pushSettings, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSitePushSettingsSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSitePushSettingsSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSitePushSettingsSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSitePushSettingsSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSitePushSettingsSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateSitePushSettingsSlotPreparer prepares the UpdateSitePushSettingsSlot request.
func (client AppsClient) UpdateSitePushSettingsSlotPreparer(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings", pathParameters),
		autorest.WithJSON(pushSettings),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSitePushSettingsSlotSender sends the UpdateSitePushSettingsSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSitePushSettingsSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSitePushSettingsSlotResponder handles the response to the UpdateSitePushSettingsSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSitePushSettingsSlotResponder(resp *http.Response) (result PushSettings, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSlot creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - unique name of the app to create or update. To create or update a deployment slot, use the {slot}
// parameter.
// siteEnvelope - a JSON representation of the app properties. See example.
// slot - name of the deployment slot to create or update. By default, this API attempts to create or modify
// the production slot.
func (client AppsClient) UpdateSlot(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, slot string) (result Site, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSlot", err.Error())
	}

	req, err := client.UpdateSlotPreparer(ctx, resourceGroupName, name, siteEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateSlotPreparer prepares the UpdateSlot request.
func (client AppsClient) UpdateSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}", pathParameters),
		autorest.WithJSON(siteEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSlotSender sends the UpdateSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSlotResponder handles the response to the UpdateSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSlotResponder(resp *http.Response) (result Site, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSlotConfigurationNames updates the names of application settings and connection string that remain with the
// slot during swap operation.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// slotConfigNames - names of application settings and connection strings. See example.
func (client AppsClient) UpdateSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource) (result SlotConfigNamesResource, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSlotConfigurationNames")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSlotConfigurationNames", err.Error())
	}

	req, err := client.UpdateSlotConfigurationNamesPreparer(ctx, resourceGroupName, name, slotConfigNames)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSlotConfigurationNames", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSlotConfigurationNamesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSlotConfigurationNames", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSlotConfigurationNamesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSlotConfigurationNames", resp, "Failure responding to request")
	}

	return
}

// UpdateSlotConfigurationNamesPreparer prepares the UpdateSlotConfigurationNames request.
func (client AppsClient) UpdateSlotConfigurationNamesPreparer(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames", pathParameters),
		autorest.WithJSON(slotConfigNames),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSlotConfigurationNamesSender sends the UpdateSlotConfigurationNames request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSlotConfigurationNamesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSlotConfigurationNamesResponder handles the response to the UpdateSlotConfigurationNames request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSlotConfigurationNamesResponder(resp *http.Response) (result SlotConfigNamesResource, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSourceControl updates the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
func (client AppsClient) UpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl) (result SiteSourceControl, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSourceControl")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSourceControl", err.Error())
	}

	req, err := client.UpdateSourceControlPreparer(ctx, resourceGroupName, name, siteSourceControl)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSourceControl", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSourceControlSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSourceControl", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSourceControlResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSourceControl", resp, "Failure responding to request")
	}

	return
}

// UpdateSourceControlPreparer prepares the UpdateSourceControl request.
func (client AppsClient) UpdateSourceControlPreparer(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web", pathParameters),
		autorest.WithJSON(siteSourceControl),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSourceControlSender sends the UpdateSourceControl request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSourceControlSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSourceControlResponder handles the response to the UpdateSourceControl request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSourceControlResponder(resp *http.Response) (result SiteSourceControl, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSourceControlSlot updates the source control configuration of an app.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// siteSourceControl - JSON representation of a SiteSourceControl object. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will update the source control
// configuration for the production slot.
func (client AppsClient) UpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, slot string) (result SiteSourceControl, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSourceControlSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSourceControlSlot", err.Error())
	}

	req, err := client.UpdateSourceControlSlotPreparer(ctx, resourceGroupName, name, siteSourceControl, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSourceControlSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSourceControlSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSourceControlSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSourceControlSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSourceControlSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateSourceControlSlotPreparer prepares the UpdateSourceControlSlot request.
func (client AppsClient) UpdateSourceControlSlotPreparer(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web", pathParameters),
		autorest.WithJSON(siteSourceControl),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSourceControlSlotSender sends the UpdateSourceControlSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSourceControlSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSourceControlSlotResponder handles the response to the UpdateSourceControlSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSourceControlSlotResponder(resp *http.Response) (result SiteSourceControl, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSwiftVirtualNetworkConnection integrates this Web App with a Virtual Network. This requires that 1)
// "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not
// in use by another App Service Plan other than the one this App is in.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// connectionEnvelope - properties of the Virtual Network connection. See example.
func (client AppsClient) UpdateSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork) (result SwiftVirtualNetwork, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSwiftVirtualNetworkConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSwiftVirtualNetworkConnection", err.Error())
	}

	req, err := client.UpdateSwiftVirtualNetworkConnectionPreparer(ctx, resourceGroupName, name, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSwiftVirtualNetworkConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSwiftVirtualNetworkConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSwiftVirtualNetworkConnection", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSwiftVirtualNetworkConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSwiftVirtualNetworkConnection", resp, "Failure responding to request")
	}

	return
}

// UpdateSwiftVirtualNetworkConnectionPreparer prepares the UpdateSwiftVirtualNetworkConnection request.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionPreparer(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSwiftVirtualNetworkConnectionSender sends the UpdateSwiftVirtualNetworkConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSwiftVirtualNetworkConnectionResponder handles the response to the UpdateSwiftVirtualNetworkConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionResponder(resp *http.Response) (result SwiftVirtualNetwork, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSwiftVirtualNetworkConnectionSlot integrates this Web App with a Virtual Network. This requires that 1)
// "swiftSupported" is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not
// in use by another App Service Plan other than the one this App is in.
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// connectionEnvelope - properties of the Virtual Network connection. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will add or update connections for
// the production slot.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, slot string) (result SwiftVirtualNetwork, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateSwiftVirtualNetworkConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateSwiftVirtualNetworkConnectionSlot", err.Error())
	}

	req, err := client.UpdateSwiftVirtualNetworkConnectionSlotPreparer(ctx, resourceGroupName, name, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSwiftVirtualNetworkConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateSwiftVirtualNetworkConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSwiftVirtualNetworkConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateSwiftVirtualNetworkConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateSwiftVirtualNetworkConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateSwiftVirtualNetworkConnectionSlotPreparer prepares the UpdateSwiftVirtualNetworkConnectionSlot request.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSwiftVirtualNetworkConnectionSlotSender sends the UpdateSwiftVirtualNetworkConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateSwiftVirtualNetworkConnectionSlotResponder handles the response to the UpdateSwiftVirtualNetworkConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateSwiftVirtualNetworkConnectionSlotResponder(resp *http.Response) (result SwiftVirtualNetwork, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVnetConnection adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties
// (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of an existing Virtual Network.
// connectionEnvelope - properties of the Virtual Network connection. See example.
func (client AppsClient) UpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo) (result VnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateVnetConnection")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateVnetConnection", err.Error())
	}

	req, err := client.UpdateVnetConnectionPreparer(ctx, resourceGroupName, name, vnetName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnection", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVnetConnectionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnection", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVnetConnectionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnection", resp, "Failure responding to request")
	}

	return
}

// UpdateVnetConnectionPreparer prepares the UpdateVnetConnection request.
func (client AppsClient) UpdateVnetConnectionPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVnetConnectionSender sends the UpdateVnetConnection request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateVnetConnectionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateVnetConnectionResponder handles the response to the UpdateVnetConnection request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateVnetConnectionResponder(resp *http.Response) (result VnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVnetConnectionGateway adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the Virtual Network.
// gatewayName - name of the gateway. Currently, the only supported string is "primary".
// connectionEnvelope - the properties to update this gateway with.
func (client AppsClient) UpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway) (result VnetGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateVnetConnectionGateway")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateVnetConnectionGateway", err.Error())
	}

	req, err := client.UpdateVnetConnectionGatewayPreparer(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionGateway", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVnetConnectionGatewaySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionGateway", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVnetConnectionGatewayResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionGateway", resp, "Failure responding to request")
	}

	return
}

// UpdateVnetConnectionGatewayPreparer prepares the UpdateVnetConnectionGateway request.
func (client AppsClient) UpdateVnetConnectionGatewayPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayName":       autorest.Encode("path", gatewayName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVnetConnectionGatewaySender sends the UpdateVnetConnectionGateway request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateVnetConnectionGatewaySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateVnetConnectionGatewayResponder handles the response to the UpdateVnetConnectionGateway request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateVnetConnectionGatewayResponder(resp *http.Response) (result VnetGateway, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVnetConnectionGatewaySlot adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of the Virtual Network.
// gatewayName - name of the gateway. Currently, the only supported string is "primary".
// connectionEnvelope - the properties to update this gateway with.
// slot - name of the deployment slot. If a slot is not specified, the API will add or update a gateway for the
// production slot's Virtual Network.
func (client AppsClient) UpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, slot string) (result VnetGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateVnetConnectionGatewaySlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateVnetConnectionGatewaySlot", err.Error())
	}

	req, err := client.UpdateVnetConnectionGatewaySlotPreparer(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionGatewaySlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVnetConnectionGatewaySlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionGatewaySlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVnetConnectionGatewaySlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionGatewaySlot", resp, "Failure responding to request")
	}

	return
}

// UpdateVnetConnectionGatewaySlotPreparer prepares the UpdateVnetConnectionGatewaySlot request.
func (client AppsClient) UpdateVnetConnectionGatewaySlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayName":       autorest.Encode("path", gatewayName),
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVnetConnectionGatewaySlotSender sends the UpdateVnetConnectionGatewaySlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateVnetConnectionGatewaySlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateVnetConnectionGatewaySlotResponder handles the response to the UpdateVnetConnectionGatewaySlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateVnetConnectionGatewaySlotResponder(resp *http.Response) (result VnetGateway, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVnetConnectionSlot adds a Virtual Network connection to an app or slot (PUT) or updates the connection
// properties (PATCH).
// Parameters:
// resourceGroupName - name of the resource group to which the resource belongs.
// name - name of the app.
// vnetName - name of an existing Virtual Network.
// connectionEnvelope - properties of the Virtual Network connection. See example.
// slot - name of the deployment slot. If a slot is not specified, the API will add or update connections for
// the production slot.
func (client AppsClient) UpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, slot string) (result VnetInfo, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppsClient.UpdateVnetConnectionSlot")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+[^\.]$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("web.AppsClient", "UpdateVnetConnectionSlot", err.Error())
	}

	req, err := client.UpdateVnetConnectionSlotPreparer(ctx, resourceGroupName, name, vnetName, connectionEnvelope, slot)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionSlot", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVnetConnectionSlotSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionSlot", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVnetConnectionSlotResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "web.AppsClient", "UpdateVnetConnectionSlot", resp, "Failure responding to request")
	}

	return
}

// UpdateVnetConnectionSlotPreparer prepares the UpdateVnetConnectionSlot request.
func (client AppsClient) UpdateVnetConnectionSlotPreparer(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfo, slot string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"slot":              autorest.Encode("path", slot),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vnetName":          autorest.Encode("path", vnetName),
	}

	const APIVersion = "2018-02-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}", pathParameters),
		autorest.WithJSON(connectionEnvelope),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVnetConnectionSlotSender sends the UpdateVnetConnectionSlot request. The method will close the
// http.Response Body if it receives an error.
func (client AppsClient) UpdateVnetConnectionSlotSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		azure.DoRetryWithRegistration(client.Client))
}

// UpdateVnetConnectionSlotResponder handles the response to the UpdateVnetConnectionSlot request. The method always
// closes the http.Response Body.
func (client AppsClient) UpdateVnetConnectionSlotResponder(resp *http.Response) (result VnetInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
