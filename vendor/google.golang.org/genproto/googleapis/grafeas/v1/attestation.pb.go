// Code generated by protoc-gen-go. DO NOT EDIT.
// source: grafeas/v1/attestation.proto

package grafeas

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Note kind that represents a logical attestation "role" or "authority". For
// example, an organization might have one `Authority` for "QA" and one for
// "build". This note is intended to act strictly as a grouping mechanism for
// the attached occurrences (Attestations). This grouping mechanism also
// provides a security boundary, since IAM ACLs gate the ability for a principle
// to attach an occurrence to a given note. It also provides a single point of
// lookup to find all attached attestation occurrences, even if they don't all
// live in the same project.
type AttestationNote struct {
	// Hint hints at the purpose of the attestation authority.
	Hint                 *AttestationNote_Hint `protobuf:"bytes,1,opt,name=hint,proto3" json:"hint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *AttestationNote) Reset()         { *m = AttestationNote{} }
func (m *AttestationNote) String() string { return proto.CompactTextString(m) }
func (*AttestationNote) ProtoMessage()    {}
func (*AttestationNote) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b5fa61d903b1ef3, []int{0}
}

func (m *AttestationNote) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttestationNote.Unmarshal(m, b)
}
func (m *AttestationNote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttestationNote.Marshal(b, m, deterministic)
}
func (m *AttestationNote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationNote.Merge(m, src)
}
func (m *AttestationNote) XXX_Size() int {
	return xxx_messageInfo_AttestationNote.Size(m)
}
func (m *AttestationNote) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationNote.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationNote proto.InternalMessageInfo

func (m *AttestationNote) GetHint() *AttestationNote_Hint {
	if m != nil {
		return m.Hint
	}
	return nil
}

// This submessage provides human-readable hints about the purpose of the
// authority. Because the name of a note acts as its resource reference, it is
// important to disambiguate the canonical name of the Note (which might be a
// UUID for security purposes) from "readable" names more suitable for debug
// output. Note that these hints should not be used to look up authorities in
// security sensitive contexts, such as when looking up attestations to
// verify.
type AttestationNote_Hint struct {
	// Required. The human readable name of this attestation authority, for
	// example "qa".
	HumanReadableName    string   `protobuf:"bytes,1,opt,name=human_readable_name,json=humanReadableName,proto3" json:"human_readable_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttestationNote_Hint) Reset()         { *m = AttestationNote_Hint{} }
func (m *AttestationNote_Hint) String() string { return proto.CompactTextString(m) }
func (*AttestationNote_Hint) ProtoMessage()    {}
func (*AttestationNote_Hint) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b5fa61d903b1ef3, []int{0, 0}
}

func (m *AttestationNote_Hint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttestationNote_Hint.Unmarshal(m, b)
}
func (m *AttestationNote_Hint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttestationNote_Hint.Marshal(b, m, deterministic)
}
func (m *AttestationNote_Hint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationNote_Hint.Merge(m, src)
}
func (m *AttestationNote_Hint) XXX_Size() int {
	return xxx_messageInfo_AttestationNote_Hint.Size(m)
}
func (m *AttestationNote_Hint) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationNote_Hint.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationNote_Hint proto.InternalMessageInfo

func (m *AttestationNote_Hint) GetHumanReadableName() string {
	if m != nil {
		return m.HumanReadableName
	}
	return ""
}

// Occurrence that represents a single "attestation". The authenticity of an
// attestation can be verified using the attached signature. If the verifier
// trusts the public key of the signer, then verifying the signature is
// sufficient to establish trust. In this circumstance, the authority to which
// this attestation is attached is primarily useful for lookup (how to find
// this attestation if you already know the authority and artifact to be
// verified) and intent (for which authority this attestation was intended to
// sign.
type AttestationOccurrence struct {
	// Required. The serialized payload that is verified by one or more
	// `signatures`.
	SerializedPayload []byte `protobuf:"bytes,1,opt,name=serialized_payload,json=serializedPayload,proto3" json:"serialized_payload,omitempty"`
	// One or more signatures over `serialized_payload`.  Verifier implementations
	// should consider this attestation message verified if at least one
	// `signature` verifies `serialized_payload`.  See `Signature` in common.proto
	// for more details on signature structure and verification.
	Signatures           []*Signature `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *AttestationOccurrence) Reset()         { *m = AttestationOccurrence{} }
func (m *AttestationOccurrence) String() string { return proto.CompactTextString(m) }
func (*AttestationOccurrence) ProtoMessage()    {}
func (*AttestationOccurrence) Descriptor() ([]byte, []int) {
	return fileDescriptor_7b5fa61d903b1ef3, []int{1}
}

func (m *AttestationOccurrence) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttestationOccurrence.Unmarshal(m, b)
}
func (m *AttestationOccurrence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttestationOccurrence.Marshal(b, m, deterministic)
}
func (m *AttestationOccurrence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationOccurrence.Merge(m, src)
}
func (m *AttestationOccurrence) XXX_Size() int {
	return xxx_messageInfo_AttestationOccurrence.Size(m)
}
func (m *AttestationOccurrence) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationOccurrence.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationOccurrence proto.InternalMessageInfo

func (m *AttestationOccurrence) GetSerializedPayload() []byte {
	if m != nil {
		return m.SerializedPayload
	}
	return nil
}

func (m *AttestationOccurrence) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func init() {
	proto.RegisterType((*AttestationNote)(nil), "grafeas.v1.AttestationNote")
	proto.RegisterType((*AttestationNote_Hint)(nil), "grafeas.v1.AttestationNote.Hint")
	proto.RegisterType((*AttestationOccurrence)(nil), "grafeas.v1.AttestationOccurrence")
}

func init() { proto.RegisterFile("grafeas/v1/attestation.proto", fileDescriptor_7b5fa61d903b1ef3) }

var fileDescriptor_7b5fa61d903b1ef3 = []byte{
	// 280 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x90, 0x4d, 0x4b, 0x33, 0x31,
	0x14, 0x46, 0xe9, 0x07, 0x2f, 0xbc, 0xa9, 0x22, 0x8d, 0x14, 0x4b, 0x71, 0x31, 0x74, 0xd5, 0x8d,
	0x19, 0x5a, 0x3f, 0x10, 0x5c, 0xd5, 0x8d, 0xae, 0x6a, 0x8d, 0x3b, 0x37, 0xc3, 0xed, 0xcc, 0x35,
	0x0d, 0xcc, 0xe4, 0x0e, 0x49, 0xa6, 0xa0, 0x20, 0xfe, 0x17, 0x7f, 0xa9, 0x98, 0x4e, 0x99, 0xc1,
	0x5d, 0xc2, 0x39, 0x39, 0x84, 0x87, 0x9d, 0x2b, 0x0b, 0x6f, 0x08, 0x2e, 0xde, 0xcd, 0x63, 0xf0,
	0x1e, 0x9d, 0x07, 0xaf, 0xc9, 0x88, 0xd2, 0x92, 0x27, 0xce, 0x6a, 0x2a, 0x76, 0xf3, 0xc9, 0x59,
	0xcb, 0x4c, 0xa9, 0x28, 0x0e, 0xd2, 0xf4, 0x8b, 0x9d, 0x2c, 0x9b, 0x97, 0x2b, 0xf2, 0xc8, 0xaf,
	0x58, 0x7f, 0xab, 0x8d, 0x1f, 0x77, 0xa2, 0xce, 0x6c, 0xb0, 0x88, 0x44, 0x93, 0x11, 0x7f, 0x54,
	0xf1, 0xa8, 0x8d, 0x97, 0xc1, 0x9e, 0xdc, 0xb0, 0xfe, 0xef, 0x8d, 0x0b, 0x76, 0xba, 0xad, 0x0a,
	0x30, 0x89, 0x45, 0xc8, 0x60, 0x93, 0x63, 0x62, 0xa0, 0xc0, 0x10, 0xfb, 0x2f, 0x87, 0x01, 0xc9,
	0x9a, 0xac, 0xa0, 0xc0, 0xe9, 0x27, 0x1b, 0xb5, 0xaa, 0x4f, 0x69, 0x5a, 0x59, 0x8b, 0x26, 0x45,
	0x7e, 0xc1, 0xb8, 0x43, 0xab, 0x21, 0xd7, 0x1f, 0x98, 0x25, 0x25, 0xbc, 0xe7, 0x04, 0x59, 0xe8,
	0x1c, 0xc9, 0x61, 0x43, 0xd6, 0x7b, 0xc0, 0xaf, 0x19, 0x73, 0x5a, 0x19, 0xf0, 0x95, 0x45, 0x37,
	0xee, 0x46, 0xbd, 0xd9, 0x60, 0x31, 0x6a, 0xff, 0xfd, 0xe5, 0x40, 0x65, 0x4b, 0xbc, 0x7f, 0x66,
	0xc7, 0x9a, 0x5a, 0xda, 0xba, 0xf3, 0x7a, 0xab, 0x88, 0x54, 0x8e, 0x42, 0x51, 0x0e, 0x46, 0x09,
	0xb2, 0x2a, 0x56, 0x68, 0xc2, 0x5c, 0xf1, 0x1e, 0x41, 0xa9, 0x5d, 0xdc, 0x2c, 0x7a, 0x57, 0x1f,
	0xbf, 0xbb, 0xbd, 0x07, 0xb9, 0xdc, 0xfc, 0x0b, 0xea, 0xe5, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xa2, 0x62, 0xca, 0x17, 0x9e, 0x01, 0x00, 0x00,
}
