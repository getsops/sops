// Code generated by protoc-gen-go. DO NOT EDIT.
// source: google/firestore/v1beta1/common.proto

/*
Package firestore is a generated protocol buffer package.

It is generated from these files:
	google/firestore/v1beta1/common.proto
	google/firestore/v1beta1/document.proto
	google/firestore/v1beta1/firestore.proto
	google/firestore/v1beta1/query.proto
	google/firestore/v1beta1/write.proto

It has these top-level messages:
	DocumentMask
	Precondition
	TransactionOptions
	Document
	Value
	ArrayValue
	MapValue
	GetDocumentRequest
	ListDocumentsRequest
	ListDocumentsResponse
	CreateDocumentRequest
	UpdateDocumentRequest
	DeleteDocumentRequest
	BatchGetDocumentsRequest
	BatchGetDocumentsResponse
	BeginTransactionRequest
	BeginTransactionResponse
	CommitRequest
	CommitResponse
	RollbackRequest
	RunQueryRequest
	RunQueryResponse
	WriteRequest
	WriteResponse
	ListenRequest
	ListenResponse
	Target
	TargetChange
	ListCollectionIdsRequest
	ListCollectionIdsResponse
	StructuredQuery
	Cursor
	Write
	DocumentTransform
	WriteResult
	DocumentChange
	DocumentDelete
	DocumentRemove
	ExistenceFilter
*/
package firestore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// A set of field paths on a document.
// Used to restrict a get or update operation on a document to a subset of its
// fields.
// This is different from standard field masks, as this is always scoped to a
// [Document][google.firestore.v1beta1.Document], and takes in account the dynamic nature of [Value][google.firestore.v1beta1.Value].
type DocumentMask struct {
	// The list of field paths in the mask. See [Document.fields][google.firestore.v1beta1.Document.fields] for a field
	// path syntax reference.
	FieldPaths []string `protobuf:"bytes,1,rep,name=field_paths,json=fieldPaths" json:"field_paths,omitempty"`
}

func (m *DocumentMask) Reset()                    { *m = DocumentMask{} }
func (m *DocumentMask) String() string            { return proto.CompactTextString(m) }
func (*DocumentMask) ProtoMessage()               {}
func (*DocumentMask) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DocumentMask) GetFieldPaths() []string {
	if m != nil {
		return m.FieldPaths
	}
	return nil
}

// A precondition on a document, used for conditional operations.
type Precondition struct {
	// The type of precondition.
	//
	// Types that are valid to be assigned to ConditionType:
	//	*Precondition_Exists
	//	*Precondition_UpdateTime
	ConditionType isPrecondition_ConditionType `protobuf_oneof:"condition_type"`
}

func (m *Precondition) Reset()                    { *m = Precondition{} }
func (m *Precondition) String() string            { return proto.CompactTextString(m) }
func (*Precondition) ProtoMessage()               {}
func (*Precondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isPrecondition_ConditionType interface {
	isPrecondition_ConditionType()
}

type Precondition_Exists struct {
	Exists bool `protobuf:"varint,1,opt,name=exists,oneof"`
}
type Precondition_UpdateTime struct {
	UpdateTime *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=update_time,json=updateTime,oneof"`
}

func (*Precondition_Exists) isPrecondition_ConditionType()     {}
func (*Precondition_UpdateTime) isPrecondition_ConditionType() {}

func (m *Precondition) GetConditionType() isPrecondition_ConditionType {
	if m != nil {
		return m.ConditionType
	}
	return nil
}

func (m *Precondition) GetExists() bool {
	if x, ok := m.GetConditionType().(*Precondition_Exists); ok {
		return x.Exists
	}
	return false
}

func (m *Precondition) GetUpdateTime() *google_protobuf1.Timestamp {
	if x, ok := m.GetConditionType().(*Precondition_UpdateTime); ok {
		return x.UpdateTime
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Precondition) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Precondition_OneofMarshaler, _Precondition_OneofUnmarshaler, _Precondition_OneofSizer, []interface{}{
		(*Precondition_Exists)(nil),
		(*Precondition_UpdateTime)(nil),
	}
}

func _Precondition_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Precondition)
	// condition_type
	switch x := m.ConditionType.(type) {
	case *Precondition_Exists:
		t := uint64(0)
		if x.Exists {
			t = 1
		}
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Precondition_UpdateTime:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UpdateTime); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Precondition.ConditionType has unexpected type %T", x)
	}
	return nil
}

func _Precondition_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Precondition)
	switch tag {
	case 1: // condition_type.exists
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ConditionType = &Precondition_Exists{x != 0}
		return true, err
	case 2: // condition_type.update_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Timestamp)
		err := b.DecodeMessage(msg)
		m.ConditionType = &Precondition_UpdateTime{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Precondition_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Precondition)
	// condition_type
	switch x := m.ConditionType.(type) {
	case *Precondition_Exists:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += 1
	case *Precondition_UpdateTime:
		s := proto.Size(x.UpdateTime)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Options for creating a new transaction.
type TransactionOptions struct {
	// The mode of the transaction.
	//
	// Types that are valid to be assigned to Mode:
	//	*TransactionOptions_ReadOnly_
	//	*TransactionOptions_ReadWrite_
	Mode isTransactionOptions_Mode `protobuf_oneof:"mode"`
}

func (m *TransactionOptions) Reset()                    { *m = TransactionOptions{} }
func (m *TransactionOptions) String() string            { return proto.CompactTextString(m) }
func (*TransactionOptions) ProtoMessage()               {}
func (*TransactionOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isTransactionOptions_Mode interface {
	isTransactionOptions_Mode()
}

type TransactionOptions_ReadOnly_ struct {
	ReadOnly *TransactionOptions_ReadOnly `protobuf:"bytes,2,opt,name=read_only,json=readOnly,oneof"`
}
type TransactionOptions_ReadWrite_ struct {
	ReadWrite *TransactionOptions_ReadWrite `protobuf:"bytes,3,opt,name=read_write,json=readWrite,oneof"`
}

func (*TransactionOptions_ReadOnly_) isTransactionOptions_Mode()  {}
func (*TransactionOptions_ReadWrite_) isTransactionOptions_Mode() {}

func (m *TransactionOptions) GetMode() isTransactionOptions_Mode {
	if m != nil {
		return m.Mode
	}
	return nil
}

func (m *TransactionOptions) GetReadOnly() *TransactionOptions_ReadOnly {
	if x, ok := m.GetMode().(*TransactionOptions_ReadOnly_); ok {
		return x.ReadOnly
	}
	return nil
}

func (m *TransactionOptions) GetReadWrite() *TransactionOptions_ReadWrite {
	if x, ok := m.GetMode().(*TransactionOptions_ReadWrite_); ok {
		return x.ReadWrite
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TransactionOptions) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TransactionOptions_OneofMarshaler, _TransactionOptions_OneofUnmarshaler, _TransactionOptions_OneofSizer, []interface{}{
		(*TransactionOptions_ReadOnly_)(nil),
		(*TransactionOptions_ReadWrite_)(nil),
	}
}

func _TransactionOptions_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TransactionOptions)
	// mode
	switch x := m.Mode.(type) {
	case *TransactionOptions_ReadOnly_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReadOnly); err != nil {
			return err
		}
	case *TransactionOptions_ReadWrite_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReadWrite); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TransactionOptions.Mode has unexpected type %T", x)
	}
	return nil
}

func _TransactionOptions_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TransactionOptions)
	switch tag {
	case 2: // mode.read_only
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransactionOptions_ReadOnly)
		err := b.DecodeMessage(msg)
		m.Mode = &TransactionOptions_ReadOnly_{msg}
		return true, err
	case 3: // mode.read_write
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TransactionOptions_ReadWrite)
		err := b.DecodeMessage(msg)
		m.Mode = &TransactionOptions_ReadWrite_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TransactionOptions_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TransactionOptions)
	// mode
	switch x := m.Mode.(type) {
	case *TransactionOptions_ReadOnly_:
		s := proto.Size(x.ReadOnly)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *TransactionOptions_ReadWrite_:
		s := proto.Size(x.ReadWrite)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Options for a transaction that can be used to read and write documents.
type TransactionOptions_ReadWrite struct {
	// An optional transaction to retry.
	RetryTransaction []byte `protobuf:"bytes,1,opt,name=retry_transaction,json=retryTransaction,proto3" json:"retry_transaction,omitempty"`
}

func (m *TransactionOptions_ReadWrite) Reset()                    { *m = TransactionOptions_ReadWrite{} }
func (m *TransactionOptions_ReadWrite) String() string            { return proto.CompactTextString(m) }
func (*TransactionOptions_ReadWrite) ProtoMessage()               {}
func (*TransactionOptions_ReadWrite) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

func (m *TransactionOptions_ReadWrite) GetRetryTransaction() []byte {
	if m != nil {
		return m.RetryTransaction
	}
	return nil
}

// Options for a transaction that can only be used to read documents.
type TransactionOptions_ReadOnly struct {
	// The consistency mode for this transaction. If not set, defaults to strong
	// consistency.
	//
	// Types that are valid to be assigned to ConsistencySelector:
	//	*TransactionOptions_ReadOnly_ReadTime
	ConsistencySelector isTransactionOptions_ReadOnly_ConsistencySelector `protobuf_oneof:"consistency_selector"`
}

func (m *TransactionOptions_ReadOnly) Reset()                    { *m = TransactionOptions_ReadOnly{} }
func (m *TransactionOptions_ReadOnly) String() string            { return proto.CompactTextString(m) }
func (*TransactionOptions_ReadOnly) ProtoMessage()               {}
func (*TransactionOptions_ReadOnly) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 1} }

type isTransactionOptions_ReadOnly_ConsistencySelector interface {
	isTransactionOptions_ReadOnly_ConsistencySelector()
}

type TransactionOptions_ReadOnly_ReadTime struct {
	ReadTime *google_protobuf1.Timestamp `protobuf:"bytes,2,opt,name=read_time,json=readTime,oneof"`
}

func (*TransactionOptions_ReadOnly_ReadTime) isTransactionOptions_ReadOnly_ConsistencySelector() {}

func (m *TransactionOptions_ReadOnly) GetConsistencySelector() isTransactionOptions_ReadOnly_ConsistencySelector {
	if m != nil {
		return m.ConsistencySelector
	}
	return nil
}

func (m *TransactionOptions_ReadOnly) GetReadTime() *google_protobuf1.Timestamp {
	if x, ok := m.GetConsistencySelector().(*TransactionOptions_ReadOnly_ReadTime); ok {
		return x.ReadTime
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TransactionOptions_ReadOnly) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TransactionOptions_ReadOnly_OneofMarshaler, _TransactionOptions_ReadOnly_OneofUnmarshaler, _TransactionOptions_ReadOnly_OneofSizer, []interface{}{
		(*TransactionOptions_ReadOnly_ReadTime)(nil),
	}
}

func _TransactionOptions_ReadOnly_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TransactionOptions_ReadOnly)
	// consistency_selector
	switch x := m.ConsistencySelector.(type) {
	case *TransactionOptions_ReadOnly_ReadTime:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReadTime); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TransactionOptions_ReadOnly.ConsistencySelector has unexpected type %T", x)
	}
	return nil
}

func _TransactionOptions_ReadOnly_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TransactionOptions_ReadOnly)
	switch tag {
	case 2: // consistency_selector.read_time
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(google_protobuf1.Timestamp)
		err := b.DecodeMessage(msg)
		m.ConsistencySelector = &TransactionOptions_ReadOnly_ReadTime{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TransactionOptions_ReadOnly_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TransactionOptions_ReadOnly)
	// consistency_selector
	switch x := m.ConsistencySelector.(type) {
	case *TransactionOptions_ReadOnly_ReadTime:
		s := proto.Size(x.ReadTime)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*DocumentMask)(nil), "google.firestore.v1beta1.DocumentMask")
	proto.RegisterType((*Precondition)(nil), "google.firestore.v1beta1.Precondition")
	proto.RegisterType((*TransactionOptions)(nil), "google.firestore.v1beta1.TransactionOptions")
	proto.RegisterType((*TransactionOptions_ReadWrite)(nil), "google.firestore.v1beta1.TransactionOptions.ReadWrite")
	proto.RegisterType((*TransactionOptions_ReadOnly)(nil), "google.firestore.v1beta1.TransactionOptions.ReadOnly")
}

func init() { proto.RegisterFile("google/firestore/v1beta1/common.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x52, 0x5f, 0x8b, 0xd3, 0x40,
	0x10, 0x6f, 0x7b, 0x47, 0x69, 0xa7, 0x45, 0xce, 0x20, 0x12, 0xc2, 0xe1, 0x1d, 0x05, 0xa1, 0x20,
	0x6c, 0xa8, 0xa2, 0x28, 0xe2, 0x83, 0xa9, 0xdc, 0xf5, 0x45, 0xae, 0xc4, 0xe2, 0x81, 0x20, 0x61,
	0x9b, 0x4c, 0xe3, 0x62, 0xb2, 0x13, 0x76, 0xb7, 0x6a, 0xbe, 0x89, 0xcf, 0x3e, 0xfa, 0xb9, 0xfc,
	0x20, 0x92, 0xcd, 0x36, 0x0a, 0xc7, 0x81, 0xbe, 0xed, 0xcc, 0xfc, 0xe6, 0xf7, 0x67, 0x58, 0x78,
	0x98, 0x13, 0xe5, 0x05, 0x86, 0x3b, 0xa1, 0x50, 0x1b, 0x52, 0x18, 0x7e, 0x59, 0x6c, 0xd1, 0xf0,
	0x45, 0x98, 0x52, 0x59, 0x92, 0x64, 0x95, 0x22, 0x43, 0x9e, 0xdf, 0xc2, 0x58, 0x07, 0x63, 0x0e,
	0x16, 0x9c, 0x3a, 0x02, 0x5e, 0x89, 0x90, 0x4b, 0x49, 0x86, 0x1b, 0x41, 0x52, 0xb7, 0x7b, 0xc1,
	0x99, 0x9b, 0xda, 0x6a, 0xbb, 0xdf, 0x85, 0x46, 0x94, 0xa8, 0x0d, 0x2f, 0xab, 0x16, 0x30, 0x0b,
	0x61, 0xfa, 0x86, 0xd2, 0x7d, 0x89, 0xd2, 0xbc, 0xe5, 0xfa, 0xb3, 0x77, 0x06, 0x93, 0x9d, 0xc0,
	0x22, 0x4b, 0x2a, 0x6e, 0x3e, 0x69, 0xbf, 0x7f, 0x7e, 0x34, 0x1f, 0xc7, 0x60, 0x5b, 0xeb, 0xa6,
	0x33, 0xab, 0x61, 0xba, 0x56, 0x98, 0x92, 0xcc, 0x44, 0x23, 0xe4, 0xf9, 0x30, 0xc4, 0x6f, 0x42,
	0x9b, 0x06, 0xdb, 0x9f, 0x8f, 0x56, 0xbd, 0xd8, 0xd5, 0xde, 0x2b, 0x98, 0xec, 0xab, 0x8c, 0x1b,
	0x4c, 0x1a, 0x51, 0x7f, 0x70, 0xde, 0x9f, 0x4f, 0x1e, 0x07, 0xcc, 0x25, 0x39, 0x38, 0x62, 0x9b,
	0x83, 0xa3, 0x55, 0x2f, 0x86, 0x76, 0xa1, 0x69, 0x45, 0x27, 0x70, 0xa7, 0x53, 0x49, 0x4c, 0x5d,
	0xe1, 0xec, 0xd7, 0x00, 0xbc, 0x8d, 0xe2, 0x52, 0xf3, 0xb4, 0x69, 0x5e, 0x55, 0x36, 0xa9, 0xb7,
	0x81, 0xb1, 0x42, 0x9e, 0x25, 0x24, 0x8b, 0xda, 0xa9, 0x3c, 0x65, 0xb7, 0xdd, 0x8b, 0xdd, 0x24,
	0x60, 0x31, 0xf2, 0xec, 0x4a, 0x16, 0xf5, 0xaa, 0x17, 0x8f, 0x94, 0x7b, 0x7b, 0xd7, 0x00, 0x96,
	0xf5, 0xab, 0x12, 0x06, 0xfd, 0x23, 0x4b, 0xfb, 0xec, 0xbf, 0x69, 0xaf, 0x9b, 0xed, 0x55, 0x2f,
	0xb6, 0x0e, 0x6d, 0x11, 0x3c, 0x87, 0x71, 0x37, 0xf1, 0x1e, 0xc1, 0x5d, 0x85, 0x46, 0xd5, 0x89,
	0xf9, 0xb3, 0x6f, 0x0f, 0x39, 0x8d, 0x4f, 0xec, 0xe0, 0x2f, 0xde, 0xe0, 0x23, 0x8c, 0x0e, 0x56,
	0xbd, 0x17, 0x2e, 0xf4, 0x3f, 0x9f, 0xd6, 0x26, 0xb3, 0x87, 0xbd, 0x0f, 0xf7, 0x52, 0x92, 0x5a,
	0x68, 0x83, 0x32, 0xad, 0x13, 0x8d, 0x05, 0xa6, 0x86, 0x54, 0x34, 0x84, 0xe3, 0x92, 0x32, 0x8c,
	0xbe, 0xf7, 0xe1, 0x34, 0xa5, 0xf2, 0xd6, 0xac, 0xd1, 0x64, 0x69, 0xbf, 0xe6, 0xba, 0x91, 0x59,
	0xf7, 0x3f, 0xbc, 0x76, 0xc0, 0x9c, 0x0a, 0x2e, 0x73, 0x46, 0x2a, 0x0f, 0x73, 0x94, 0xd6, 0x44,
	0xd8, 0x8e, 0x78, 0x25, 0xf4, 0xcd, 0x1f, 0xfe, 0xb2, 0xeb, 0xfc, 0x18, 0x1c, 0x5f, 0x2e, 0x2f,
	0xde, 0xfd, 0x1c, 0x3c, 0xb8, 0x6c, 0xa9, 0x96, 0x05, 0xed, 0x33, 0x76, 0xd1, 0x29, 0xbf, 0x5f,
	0x44, 0xcd, 0xc6, 0x76, 0x68, 0x59, 0x9f, 0xfc, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x27, 0x10, 0x0b,
	0x70, 0x36, 0x03, 0x00, 0x00,
}
